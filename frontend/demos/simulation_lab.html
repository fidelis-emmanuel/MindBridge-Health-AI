<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MindBridge Mentor ‚Äî Simulation Lab</title>
<style>
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --card: #22263a;
    --border: #2e3350;
    --accent: #4f8ef7;
    --green: #22c55e;
    --yellow: #f59e0b;
    --red: #ef4444;
    --purple: #a855f7;
    --text: #e2e8f0;
    --muted: #64748b;
    --sim-color: #f59e0b;
    --int-color: #a855f7;
    --con-color: #4f8ef7;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Segoe UI', system-ui, sans-serif;
    min-height: 100vh;
  }

  /* Header */
  .header {
    background: linear-gradient(135deg, #1a1d27 0%, #0f1117 100%);
    border-bottom: 1px solid var(--border);
    padding: 20px 32px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .header-left h1 { font-size: 20px; font-weight: 700; color: var(--text); }
  .header-left p { font-size: 13px; color: var(--muted); margin-top: 2px; }
  .target-badge {
    background: linear-gradient(135deg, #22c55e20, #22c55e10);
    border: 1px solid #22c55e40;
    border-radius: 20px;
    padding: 6px 16px;
    font-size: 13px;
    color: var(--green);
    font-weight: 600;
  }

  /* Layout */
  .container { display: flex; height: calc(100vh - 73px); }

  /* Sidebar */
  .sidebar {
    width: 280px;
    background: var(--surface);
    border-right: 1px solid var(--border);
    overflow-y: auto;
    flex-shrink: 0;
  }
  .sidebar-section { padding: 16px; border-bottom: 1px solid var(--border); }
  .sidebar-title {
    font-size: 11px;
    font-weight: 700;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 12px;
  }
  .scenario-btn {
    width: 100%;
    text-align: left;
    background: none;
    border: 1px solid transparent;
    border-radius: 8px;
    padding: 10px 12px;
    color: var(--text);
    cursor: pointer;
    margin-bottom: 4px;
    transition: all 0.15s;
    display: flex;
    align-items: flex-start;
    gap: 10px;
  }
  .scenario-btn:hover { background: var(--card); border-color: var(--border); }
  .scenario-btn.active { background: var(--card); border-color: var(--accent); }
  .scenario-btn .icon { font-size: 18px; flex-shrink: 0; margin-top: 1px; }
  .scenario-btn .info { flex: 1; }
  .scenario-btn .name { font-size: 13px; font-weight: 600; line-height: 1.3; }
  .scenario-btn .tag {
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    margin-top: 3px;
    letter-spacing: 0.06em;
  }
  .tag-sim { color: var(--sim-color); }
  .tag-int { color: var(--int-color); }
  .tag-con { color: var(--con-color); }

  /* Main area */
  .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

  /* Simulation stage */
  .stage {
    flex: 1;
    padding: 32px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  /* Scenario card */
  .scenario-header {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 24px;
  }
  .scenario-type {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    padding: 4px 10px;
    border-radius: 20px;
    margin-bottom: 14px;
  }
  .type-sim { background: #f59e0b20; color: var(--sim-color); border: 1px solid #f59e0b40; }
  .type-int { background: #a855f720; color: var(--int-color); border: 1px solid #a855f740; }
  .type-con { background: #4f8ef720; color: var(--con-color); border: 1px solid #4f8ef740; }
  .scenario-question {
    font-size: 17px;
    font-weight: 600;
    line-height: 1.5;
    color: var(--text);
  }
  .scenario-context {
    margin-top: 12px;
    font-size: 13px;
    color: var(--muted);
    line-height: 1.6;
    padding: 12px;
    background: #ffffff08;
    border-radius: 8px;
    border-left: 3px solid var(--accent);
  }

  /* Answer area */
  .answer-section { display: flex; flex-direction: column; gap: 12px; }
  .answer-label {
    font-size: 12px;
    font-weight: 700;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.06em;
  }
  .answer-textarea {
    width: 100%;
    min-height: 140px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px;
    color: var(--text);
    font-size: 14px;
    font-family: inherit;
    line-height: 1.6;
    resize: vertical;
    transition: border-color 0.15s;
    outline: none;
  }
  .answer-textarea:focus { border-color: var(--accent); }
  .answer-textarea::placeholder { color: var(--muted); }

  /* Buttons */
  .btn-row { display: flex; gap: 10px; align-items: center; }
  .btn {
    padding: 10px 20px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    border: none;
    transition: all 0.15s;
  }
  .btn-primary { background: var(--accent); color: white; }
  .btn-primary:hover { background: #3b7ce8; }
  .btn-secondary {
    background: var(--card);
    color: var(--text);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover { border-color: var(--accent); }
  .btn-disabled { opacity: 0.5; cursor: not-allowed; }

  /* Ideal answer reveal */
  .ideal-answer {
    background: var(--card);
    border: 1px solid #22c55e40;
    border-radius: 12px;
    padding: 20px;
    display: none;
  }
  .ideal-answer.show { display: block; }
  .ideal-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--green);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .ideal-text {
    font-size: 14px;
    line-height: 1.7;
    color: var(--text);
  }
  .ideal-text strong { color: var(--accent); }

  /* Rating */
  .rating-section {
    display: none;
    flex-direction: column;
    gap: 12px;
  }
  .rating-section.show { display: flex; }
  .rating-label {
    font-size: 13px;
    color: var(--muted);
    font-weight: 600;
  }
  .rating-buttons { display: flex; gap: 8px; flex-wrap: wrap; }
  .rating-btn {
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    border: 1px solid var(--border);
    background: var(--card);
    color: var(--text);
    transition: all 0.15s;
  }
  .rating-btn:hover { transform: translateY(-1px); }
  .rating-btn[data-r="1"]:hover { background: #ef444420; border-color: var(--red); color: var(--red); }
  .rating-btn[data-r="2"]:hover { background: #f59e0b20; border-color: var(--yellow); color: var(--yellow); }
  .rating-btn[data-r="3"]:hover { background: #22c55e20; border-color: var(--green); color: var(--green); }
  .rating-btn[data-r="4"]:hover { background: #4f8ef720; border-color: var(--accent); color: var(--accent); }

  /* Feedback panel */
  .feedback-panel {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    display: none;
  }
  .feedback-panel.show { display: block; }
  .feedback-title {
    font-size: 14px;
    font-weight: 700;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .feedback-text { font-size: 13px; line-height: 1.7; color: var(--text); }
  .feedback-tags { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 12px; }
  .feedback-tag {
    font-size: 11px;
    font-weight: 700;
    padding: 3px 8px;
    border-radius: 12px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  /* Stats bar */
  .stats-bar {
    background: var(--surface);
    border-top: 1px solid var(--border);
    padding: 12px 32px;
    display: flex;
    gap: 32px;
    align-items: center;
  }
  .stat { display: flex; align-items: center; gap: 8px; }
  .stat-value { font-size: 18px; font-weight: 700; color: var(--text); }
  .stat-label { font-size: 12px; color: var(--muted); }
  .stat-divider { width: 1px; height: 28px; background: var(--border); }

  /* Welcome screen */
  .welcome {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 40px;
    gap: 16px;
  }
  .welcome h2 { font-size: 24px; font-weight: 700; }
  .welcome p { font-size: 15px; color: var(--muted); max-width: 420px; line-height: 1.6; }
  .welcome-cards { display: flex; gap: 16px; margin-top: 8px; }
  .welcome-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    width: 160px;
    text-align: center;
  }
  .welcome-card .icon { font-size: 28px; margin-bottom: 8px; }
  .welcome-card .title { font-size: 13px; font-weight: 700; margin-bottom: 4px; }
  .welcome-card .desc { font-size: 11px; color: var(--muted); line-height: 1.5; }

  /* Loading */
  .loading {
    display: none;
    align-items: center;
    gap: 8px;
    color: var(--muted);
    font-size: 13px;
  }
  .loading.show { display: flex; }
  .spinner {
    width: 16px; height: 16px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
</style>
</head>
<body>

<div class="header">
  <div class="header-left">
    <h1>üè• MindBridge Mentor ‚Äî Simulation Lab</h1>
    <p>Interactive scenario practice for Healthcare AI Engineer interviews</p>
  </div>
  <div class="target-badge">üéØ Target: $200K‚Äì$300K</div>
</div>

<div class="container">

  <!-- Sidebar -->
  <div class="sidebar">
    <div class="sidebar-section">
      <div class="sidebar-title">üé≠ Simulations (13)</div>
      <button class="scenario-btn" onclick="loadScenario('login')" id="btn-login">
        <span class="icon">üîê</span>
        <span class="info">
          <div class="name">Patient Login Flow</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('screening')" id="btn-screening">
        <span class="icon">‚öïÔ∏è</span>
        <span class="info">
          <div class="name">Risk Screening Pipeline</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('apikey')" id="btn-apikey">
        <span class="icon">üîë</span>
        <span class="info">
          <div class="name">Junior Dev: API Keys</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('debug500')" id="btn-debug500">
        <span class="icon">üêõ</span>
        <span class="info">
          <div class="name">Debug 500 Error</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('slowapi')" id="btn-slowapi">
        <span class="icon">üêå</span>
        <span class="info">
          <div class="name">API Performance Issue</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('corserror')" id="btn-corserror">
        <span class="icon">üö´</span>
        <span class="info">
          <div class="name">CORS Error</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('ratelimit')" id="btn-ratelimit">
        <span class="icon">‚è±Ô∏è</span>
        <span class="info">
          <div class="name">Rate Limiting</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('circuitbreaker')" id="btn-circuitbreaker">
        <span class="icon">‚ö°</span>
        <span class="info">
          <div class="name">Circuit Breaker Pattern</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('caching')" id="btn-caching">
        <span class="icon">üíæ</span>
        <span class="info">
          <div class="name">Redis Caching</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('deployment')" id="btn-deployment">
        <span class="icon">üöÄ</span>
        <span class="info">
          <div class="name">Zero-Downtime Deploy</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('monitoring')" id="btn-monitoring">
        <span class="icon">üìä</span>
        <span class="info">
          <div class="name">Production Monitoring</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('incident')" id="btn-incident">
        <span class="icon">üö®</span>
        <span class="info">
          <div class="name">Incident Response</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('multitenancy')" id="btn-multitenancy">
        <span class="icon">üè¢</span>
        <span class="info">
          <div class="name">Multi-Tenant Architecture</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('vercel_build_fail')" id="btn-vercel_build_fail">
        <span class="icon">üî®</span>
        <span class="info">
          <div class="name">Vercel Build Fails</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('nextjs_404')" id="btn-nextjs_404">
        <span class="icon">üóÇÔ∏è</span>
        <span class="info">
          <div class="name">Dynamic Route 404</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('econnrefused')" id="btn-econnrefused">
        <span class="icon">üîå</span>
        <span class="info">
          <div class="name">ECONNREFUSED Debug</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('gitguardian')" id="btn-gitguardian">
        <span class="icon">üö®</span>
        <span class="info">
          <div class="name">Exposed Credentials Alert</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
    </div>

    <div class="sidebar-section">
      <div class="sidebar-title">üé§ Interview Practice (11)</div>
      <button class="scenario-btn" onclick="loadScenario('whyhire')" id="btn-whyhire">
        <span class="icon">üíº</span>
        <span class="info">
          <div class="name">Why Hire You?</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('project')" id="btn-project">
        <span class="icon">üöÄ</span>
        <span class="info">
          <div class="name">Tell Me About a Project</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('apidesign')" id="btn-apidesign">
        <span class="icon">üèóÔ∏è</span>
        <span class="info">
          <div class="name">API Design Process</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('sensitive')" id="btn-sensitive">
        <span class="icon">üîí</span>
        <span class="info">
          <div class="name">Handling Sensitive Data</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('testing')" id="btn-testing">
        <span class="icon">üß™</span>
        <span class="info">
          <div class="name">Testing Strategy</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('bulkimport')" id="btn-bulkimport">
        <span class="icon">üì§</span>
        <span class="info">
          <div class="name">Bulk CSV Import Design</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('medication')" id="btn-medication">
        <span class="icon">üíä</span>
        <span class="info">
          <div class="name">Medication Interactions</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('patientmatching')" id="btn-patientmatching">
        <span class="icon">üîç</span>
        <span class="info">
          <div class="name">Patient Matching</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('realtime')" id="btn-realtime">
        <span class="icon">‚ö°</span>
        <span class="info">
          <div class="name">Real-Time Updates</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('scaling')" id="btn-scaling">
        <span class="icon">üìà</span>
        <span class="info">
          <div class="name">Scale to 100K Patients</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('failover')" id="btn-failover">
        <span class="icon">üîß</span>
        <span class="info">
          <div class="name">Database Failover</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('frontend_arch')" id="btn-frontend_arch">
        <span class="icon">üèóÔ∏è</span>
        <span class="info">
          <div class="name">MindBridge Frontend Architecture</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('nextjs_vs_react')" id="btn-nextjs_vs_react">
        <span class="icon">‚öõÔ∏è</span>
        <span class="info">
          <div class="name">Why Next.js Over React?</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('add_auth')" id="btn-add_auth">
        <span class="icon">üîê</span>
        <span class="info">
          <div class="name">Add Auth to Dashboard</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('fullstack_connect')" id="btn-fullstack_connect">
        <span class="icon">üîó</span>
        <span class="info">
          <div class="name">Connect Frontend to Database</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
    </div>

    <div class="sidebar-section">
      <div class="sidebar-title">üí° Concept Check (6)</div>
      <button class="scenario-btn" onclick="loadScenario('docker')" id="btn-docker">
        <span class="icon">üê≥</span>
        <span class="info">
          <div class="name">Docker & Containers</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('postgres')" id="btn-postgres">
        <span class="icon">üóÑÔ∏è</span>
        <span class="info">
          <div class="name">PostgreSQL vs MongoDB</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('hipaa')" id="btn-hipaa">
        <span class="icon">üè•</span>
        <span class="info">
          <div class="name">HIPAA Requirements</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('pooling')" id="btn-pooling">
        <span class="icon">üîÑ</span>
        <span class="info">
          <div class="name">Connection Pooling</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('fhir')" id="btn-fhir">
        <span class="icon">üîó</span>
        <span class="info">
          <div class="name">FHIR Integration</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('hl7')" id="btn-hl7">
        <span class="icon">üìã</span>
        <span class="info">
          <div class="name">HL7 v2 Parsing</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('server_client')" id="btn-server_client">
        <span class="icon">‚ö°</span>
        <span class="info">
          <div class="name">Server vs Client Components</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('cicd_concept')" id="btn-cicd_concept">
        <span class="icon">üîÑ</span>
        <span class="info">
          <div class="name">CI/CD Pipeline</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('mindbridge_e2e')" id="btn-mindbridge_e2e">
        <span class="icon">üó∫Ô∏è</span>
        <span class="info">
          <div class="name">MindBridge End-to-End</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('env_vars')" id="btn-env_vars">
        <span class="icon">üîê</span>
        <span class="info">
          <div class="name">Environment Variables</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
    </div>
  </div>

  <!-- Main Stage -->
  <div class="main">
    <div class="stage" id="stage">

      <!-- Welcome screen shown by default -->
      <div class="welcome" id="welcome">
        <div style="font-size:48px">üè•</div>
        <h2>Welcome to Simulation Lab</h2>
        <p>Practice real scenarios you'll face in Healthcare AI Engineer interviews. 30 scenarios covering simulations, interviews, and technical concepts.</p>
        <div class="welcome-cards">
          <div class="welcome-card">
            <div class="icon">üé≠</div>
            <div class="title">Simulations</div>
            <div class="desc">13 real-world system scenarios including deployment and incident response</div>
          </div>
          <div class="welcome-card">
            <div class="icon">üé§</div>
            <div class="title">Interview</div>
            <div class="desc">11 interview scenarios including healthcare-specific design challenges</div>
          </div>
          <div class="welcome-card">
            <div class="icon">üí°</div>
            <div class="title">Concepts</div>
            <div class="desc">6 deep-dive technical concepts: Docker, PostgreSQL, HIPAA, FHIR, HL7, Pooling</div>
          </div>
        </div>
      </div>

      <!-- Scenario content (hidden until selected) -->
      <div id="scenario-content" style="display:none;">

        <div class="scenario-header">
          <div class="scenario-type" id="scenario-type-badge"></div>
          <div class="scenario-question" id="scenario-question"></div>
          <div class="scenario-context" id="scenario-context" style="display:none"></div>
        </div>

        <div class="answer-section">
          <div class="answer-label">Your Answer</div>
          <textarea
            class="answer-textarea"
            id="user-answer"
            placeholder="Type your answer here... Try to recall everything before revealing the ideal answer."
          ></textarea>
          <div class="btn-row">
            <button class="btn btn-primary" id="reveal-btn" onclick="revealAnswer()">
              Reveal Ideal Answer
            </button>
            <div class="loading" id="loading-indicator">
              <div class="spinner"></div>
              <span>Analyzing your answer...</span>
            </div>
          </div>
        </div>

        <div class="ideal-answer" id="ideal-answer">
          <div class="ideal-title">‚úÖ Ideal Answer</div>
          <div class="ideal-text" id="ideal-text"></div>
        </div>

        <div class="rating-section" id="rating-section">
          <div class="rating-label">How well did you know this?</div>
          <div class="rating-buttons">
            <button class="rating-btn" data-r="1" onclick="rateAnswer(1)">‚ùå No idea</button>
            <button class="rating-btn" data-r="2" onclick="rateAnswer(2)">üòì Partial</button>
            <button class="rating-btn" data-r="3" onclick="rateAnswer(3)">‚úì Good</button>
            <button class="rating-btn" data-r="4" onclick="rateAnswer(4)">‚≠ê Perfect</button>
          </div>
        </div>

        <div class="feedback-panel" id="feedback-panel">
          <div class="feedback-title" id="feedback-title"></div>
          <div class="feedback-text" id="feedback-text"></div>
          <div class="feedback-tags" id="feedback-tags"></div>
          <div style="margin-top:16px">
            <button class="btn btn-secondary" onclick="nextScenario()">Next Scenario ‚Üí</button>
          </div>
        </div>

      </div>
    </div>

    <!-- Stats bar -->
    <div class="stats-bar">
      <div class="stat">
        <div class="stat-value" id="stat-completed">0</div>
        <div class="stat-label">Completed Today</div>
      </div>
      <div class="stat-divider"></div>
      <div class="stat">
        <div class="stat-value" id="stat-score">‚Äî</div>
        <div class="stat-label">Avg Rating</div>
      </div>
      <div class="stat-divider"></div>
      <div class="stat">
        <div class="stat-value" style="color:var(--green)">Week 2</div>
        <div class="stat-label">Curriculum Phase</div>
      </div>
      <div class="stat-divider"></div>
      <div class="stat">
        <div class="stat-value" style="color:var(--accent)">42</div>
        <div class="stat-label">Total Scenarios</div>
      </div>
      <div class="stat-divider"></div>
      <div class="stat">
        <div class="stat-value" style="color:var(--green)">$200K+</div>
        <div class="stat-label">Target Role</div>
      </div>
    </div>
  </div>
</div>

<script>
const scenarios = {
  login: {
    type: "simulation",
    title: "Patient Login Flow Simulation",
    question: "You're a case manager at Oakwood Behavioral Health. Walk me through exactly what happens ‚Äî technically ‚Äî when you log into MindBridge. What systems are involved at each step?",
    context: "Scenario context: You're explaining this to a new developer joining the team. Be specific about each system, security measure, and what data flows where.",
    ideal: `<strong>Step 1 ‚Äî Browser to Frontend:</strong> You enter your email + password on the Next.js login page. The form submits to NextAuth.js, which handles the session layer.<br><br>
<strong>Step 2 ‚Äî Frontend to Backend:</strong> NextAuth sends credentials to FastAPI POST /api/auth/verify with email and password hash.<br><br>
<strong>Step 3 ‚Äî Database Validation:</strong> FastAPI queries PostgreSQL ‚Äî SELECT user WHERE email matches, then bcrypt.verify() checks the password hash. Plain passwords are NEVER stored.<br><br>
<strong>Step 4 ‚Äî MFA Check:</strong> If the user has MFA enabled (required for admin roles), FastAPI prompts for TOTP code before proceeding.<br><br>
<strong>Step 5 ‚Äî JWT Issued:</strong> FastAPI generates a signed JWT token containing user_id, role, clinic_id, and expiry. Signed with RS256 ‚Äî can't be forged.<br><br>
<strong>Step 6 ‚Äî Secure Cookie:</strong> NextAuth stores the session in an httpOnly, Secure cookie. JavaScript cannot read this cookie ‚Äî XSS-proof.<br><br>
<strong>Step 7 ‚Äî Scoped Dashboard:</strong> Dashboard loads ‚Äî every API call includes the Bearer token. FastAPI validates it and queries ONLY patients WHERE case_manager_id = your user_id.<br><br>
<strong>Step 8 ‚Äî HIPAA Audit:</strong> Every login is logged to audit_log table: user_id, timestamp, IP address, action='LOGIN'. This is required by HIPAA.`
  },

  screening: {
    type: "simulation",
    title: "Risk Screening Pipeline",
    question: "A case manager clicks 'Screen Patient' for Marcus Johnson (patient_id: uuid-123). Walk through the complete technical pipeline from button click to risk badge appearing on the dashboard.",
    context: "This is a common system design question. Show you understand async flows, AI integration, error handling, and HIPAA compliance.",
    ideal: `<strong>1. Frontend Request:</strong> Next.js sends POST /api/analysis { patient_id: 'uuid-123' } with Bearer JWT token in headers.<br><br>
<strong>2. Middleware Layer:</strong> FastAPI validates JWT (user authenticated), checks RBAC (has 'analyst' role), applies rate limiting (prevents abuse).<br><br>
<strong>3. Patient Fetch:</strong> Analysis Service queries PostgreSQL: SELECT * FROM patients WHERE id='uuid-123' AND deleted_at IS NULL. Confirms patient belongs to this case manager's clinic.<br><br>
<strong>4. Claude API Call:</strong> Structured prompt sent to Claude with patient data: appointments_missed, medication_adherence, crisis_calls_30days, diagnosis. Async ‚Äî doesn't block other requests.<br><br>
<strong>5. AI Response Parsed:</strong> Claude returns Risk Level, Primary Factor, Recommended Action. Pydantic validates the response structure.<br><br>
<strong>6. Database Write:</strong> ACID transaction: (a) INSERT screening result, (b) UPDATE patient risk_level, (c) INSERT audit_log. All three succeed or NONE do ‚Äî no partial writes.<br><br>
<strong>7. High Risk Alert:</strong> If risk_level = 'HIGH', Notification Service sends email to case manager's supervisor immediately. This is a patient safety feature.<br><br>
<strong>8. Response to Frontend:</strong> FastAPI returns { screening_id, risk_level, primary_factor, action, timestamp }. Next.js updates the dashboard with color-coded risk badge (Red/Orange/Green).`
  },

  apikey: {
    type: "simulation",
    title: "Junior Developer: API Key Security",
    question: "A new junior developer on your team just committed their Anthropic API key directly in the Python code and pushed to GitHub. They say 'it's fine, our repo is private.' How do you respond?",
    context: "This is both a technical and professional situation. Show you understand security, HIPAA implications, and how to mentor without being dismissive.",
    ideal: `<strong>First, act immediately:</strong> "Let's fix this right now before anything else. Private repos get made public, get transferred, get forked. Go to Anthropic's dashboard and revoke that key immediately. Generate a new one."<br><br>
<strong>Then explain why 'private' isn't safe:</strong> "Three reasons this is serious: (1) Git history is permanent ‚Äî even after you delete the file, the key exists in every commit forever. git log shows everything. (2) Private repos get breached ‚Äî GitHub has had security incidents. (3) For a healthcare app, an exposed key means an exposed Claude API ‚Äî that could mean patient data in prompts is accessible."<br><br>
<strong>Show the right way:</strong> "Use os.environ.get('ANTHROPIC_API_KEY'). In development, put it in a .env file that's in .gitignore. In production, use AWS Secrets Manager or environment variables in your deployment platform."<br><br>
<strong>HIPAA angle:</strong> "If this were a production system and patient data was in those API prompts, this could be a HIPAA breach notification situation ‚Äî not just a bug to fix."<br><br>
<strong>Make it a learning moment:</strong> "I'll send you our security checklist. This happens to everyone once ‚Äî the goal is it only happens once."`
  },

  debug500: {
    type: "simulation",
    title: "Debug 500 Error in Production",
    question: "Your FastAPI endpoint suddenly returns 500 Internal Server Error. Users are calling support. Walk me through debugging it step by step.",
    context: "This tests real-world debugging under pressure. Show methodical thinking, not panic.",
    ideal: `<strong>STEP 1 ‚Äî Check the logs immediately:</strong><br>
tail -f logs/app.log or check CloudWatch/Railway logs. The 500 error will have a stack trace showing exactly where it failed.<br><br>
<strong>STEP 2 ‚Äî Identify the error type:</strong><br>
DatabaseError = connection pool exhausted or DB down. Check: docker compose ps or Railway dashboard.<br>
ClientError (Anthropic) = API key invalid or rate limit hit. Check: Anthropic dashboard.<br>
ValidationError = data schema mismatch. Check: Pydantic model definitions.<br>
AttributeError = code trying to access None. Check: null checks before field access.<br><br>
<strong>STEP 3 ‚Äî Common MindBridge 500 causes and fixes:</strong><br>
'Connection pool exhausted' ‚Üí Increase pool_size in SQLAlchemy (default 5 is too low for production).<br>
'anthropic.APIError: Invalid API key' ‚Üí Environment variable not set correctly in production.<br>
'NoneType has no attribute' ‚Üí Database returned null, code didn't check. Fix: Add if patient is not None check.<br><br>
<strong>STEP 4 ‚Äî Reproduce locally:</strong><br>
Copy the exact request from logs, replay in Postman/curl. Fix the bug and deploy.<br><br>
<strong>STEP 5 ‚Äî Add monitoring:</strong><br>
After fixing, add logging around the failure point so next time you catch it earlier.<br><br>
<strong>Interview gold:</strong> "Read the logs first. The stack trace tells you exactly what failed. Most 500 errors are fixed in under 10 minutes if you read the error message carefully instead of guessing."`
  },

  slowapi: {
    type: "simulation",
    title: "API Performance - It's Too Slow",
    question: "A case manager reports the API is 'slow'. The dashboard takes 10 seconds to load. How do you diagnose and fix it?",
    context: "Performance debugging is a core skill. Show you know how to measure before optimizing.",
    ideal: `<strong>STEP 1 ‚Äî Define 'slow':</strong><br>
Get specifics: Which endpoint? How slow (2 seconds? 30 seconds?)? Happens always or intermittently?<br><br>
<strong>STEP 2 ‚Äî Check the obvious:</strong><br>
Is Claude API down? (Check status.anthropic.com)<br>
Is database connection pool exhausted? (Check logs for 'Timeout waiting for connection')<br>
Is the network slow? (Check CloudWatch/Railway metrics)<br><br>
<strong>STEP 3 ‚Äî Add timing logs:</strong><br>
import time; start = time.time(); result = await db.query(...); print(f'Query took {time.time()-start}s')<br>
This shows which part is slow: database? Claude API? Data processing?<br><br>
<strong>STEP 4 ‚Äî Common MindBridge performance issues:</strong><br>
<strong>N+1 queries</strong> ‚Äî Loading 50 patients then fetching each patient's screenings individually. Fix: Use JOIN or eager loading.<br>
<strong>Missing database index</strong> ‚Äî Querying WHERE clinic_id without an index scans entire table. Fix: CREATE INDEX idx_patients_clinic ON patients(clinic_id).<br>
<strong>Large response payloads</strong> ‚Äî Returning 10MB of data when frontend only needs 50KB. Fix: Use Pydantic response model to include only necessary fields.<br>
<strong>Synchronous blocking</strong> ‚Äî Claude API call blocks all other requests. Already fixed with async.<br><br>
<strong>STEP 5 ‚Äî Verify the fix:</strong><br>
Before: Dashboard loads in 10 seconds.<br>
After: Dashboard loads in 0.5 seconds.<br>
Log the improvement. Update monitoring.<br><br>
<strong>Interview gold:</strong> "Performance issues are usually database queries. Add timing, find the slow query, add an index. 90% of the time that's the fix. The other 10% is usually oversized API responses."`
  },

  corserror: {
    type: "simulation",
    title: "CORS Error - Frontend Can't Reach Backend",
    question: "Your Next.js frontend suddenly can't reach the FastAPI backend. Browser console shows: 'CORS policy: No Access-Control-Allow-Origin header'. What do you do?",
    context: "CORS errors confuse many developers. Show you understand web security fundamentals.",
    ideal: `<strong>What CORS is:</strong><br>
CORS (Cross-Origin Resource Sharing) is a browser security feature that blocks requests between different domains by default.<br><br>
<strong>Why it's failing:</strong><br>
Frontend runs on app.mindbridge.com (or localhost:3000 in dev).<br>
Backend runs on api.mindbridge.com (or localhost:8000 in dev).<br>
Browser blocks the request because origins don't match.<br><br>
<strong>THE FIX ‚Äî Add CORS middleware to FastAPI:</strong><br>
from fastapi.middleware.cors import CORSMiddleware<br>
app.add_middleware(CORSMiddleware, allow_origins=["https://app.mindbridge.com"], allow_credentials=True, allow_methods=["GET","POST","PUT","DELETE"], allow_headers=["Authorization","Content-Type"])<br><br>
<strong>Development config:</strong><br>
allow_origins=["http://localhost:3000"] ‚Äî for local Next.js dev server<br><br>
<strong>CRITICAL ‚Äî What NOT to do:</strong><br>
NEVER use allow_origins=["*"] in production for a healthcare app. That means ANY website can call your patient data API. For a HIPAA-compliant system, you must whitelist specific origins.<br><br>
<strong>How to test:</strong><br>
Open browser DevTools ‚Üí Network tab ‚Üí Try the API call ‚Üí Response headers should show Access-Control-Allow-Origin: https://app.mindbridge.com<br><br>
<strong>Interview gold:</strong> "CORS is a browser security feature, not a server problem. The fix is always on the backend ‚Äî add the CORS middleware with explicit origin whitelisting. Never use wildcards in healthcare applications."`
  },

  whyhire: {
    type: "interview",
    title: "Why Should We Hire You?",
    question: "We have several candidates with Computer Science degrees from top universities applying for this Healthcare AI Engineer role. Why should we hire you instead?",
    context: "This is your moment. Use your 10 years of clinical experience as the unfair advantage it is. Don't be defensive ‚Äî be confident.",
    ideal: `"Computer Science degrees teach algorithms, data structures, and systems ‚Äî all valuable. But they don't teach you what happens when a risk assessment algorithm flags the wrong patient, or why a case manager will ignore an alert that fires too often, or what a behavioral health crisis actually looks like at 2 AM.<br><br>
In my 10 years as a Mental Health Technician and CNA, I've lived those scenarios. I've watched high-risk patients fall through the cracks because the documentation system was too slow. I've seen staff ignore automated alerts because the false positive rate was too high. I know exactly the problems that MindBridge Health AI is designed to solve ‚Äî not from reading about them, but from experiencing them.<br><br>
That domain expertise changes how I build systems. When I designed the risk screening algorithm, I didn't just optimize for accuracy ‚Äî I designed the alert thresholds to minimize alert fatigue based on clinical workflows I've actually worked in. I built the audit logging not just for compliance, but because I know auditors show up after incidents, not before.<br><br>
You can teach a CS grad to use FastAPI in 6 months. You cannot teach 10 years of behavioral health experience. I bring both, and that's rare."`
  },

  project: {
    type: "interview",
    title: "Tell Me About a Recent Project",
    question: "Tell me about a technical project you've built recently. Walk me through the problem, your approach, and the outcome.",
    context: "Use the 3-part framework: Clinical Context ‚Üí Technical Solution ‚Üí Business Impact. Always anchor in your healthcare experience.",
    ideal: `<strong>CLINICAL CONTEXT:</strong> "In my 10 years as a Mental Health Technician, I watched case managers spend 6+ hours every day manually reviewing patient charts to assess risk ‚Äî checking medication adherence, counting missed appointments, reviewing crisis call logs. With 30-40 patients per case manager, high-risk patients sometimes fell through the cracks between reviews."<br><br>
<strong>TECHNICAL SOLUTION:</strong> "I built MindBridge Health AI ‚Äî a full-stack, HIPAA-compliant behavioral health risk screening platform. The backend is FastAPI with PostgreSQL, integrated with Claude AI for risk assessment. I built an automated pipeline that ingests patient data from CSV or direct entry, sends each patient through a structured Claude prompt with clinical guardrails, and generates professional reports in Word, Excel, and PDF. The system uses role-based access control and comprehensive audit logging for HIPAA compliance."<br><br>
<strong>BUSINESS IMPACT:</strong> "What used to take a case manager 6+ hours now takes under 2 minutes. The AI correctly identifies high-risk patients with high sensitivity, and the clinical guardrails I built ensure the AI can never automatically downgrade a patient who's been manually escalated ‚Äî a human is always in the loop for that decision. It's the kind of system I wish existed when I was doing direct patient care."`
  },

  apidesign: {
    type: "interview",
    title: "API Design Process",
    question: "Walk me through your API design process. How do you decide what endpoints to create, how to structure them, and what to prioritize?",
    context: "Show that you think about users first, then technical implementation. Demonstrate understanding of REST principles and healthcare-specific considerations.",
    ideal: `"My API design starts with the clinical workflow, not the technical spec.<br><br>
<strong>Step 1 ‚Äî Map the User Journey:</strong> I start by mapping what the end users ‚Äî case managers, clinicians, administrators ‚Äî actually do each day. Each workflow task becomes a candidate endpoint: 'view my patients', 'run a screening', 'download a report'.<br><br>
<strong>Step 2 ‚Äî Apply REST Principles:</strong> Resources are nouns (patients, screenings, reports), actions are HTTP methods. GET /patients for listing, POST /screenings for creating, GET /reports/{id}/download for retrieving. I avoid verbs in URLs ‚Äî /run-screening is wrong, POST /screenings is right.<br><br>
<strong>Step 3 ‚Äî Design Data Contracts First:</strong> Before writing any route code, I write Pydantic schemas. This forces me to think about what data flows in and out. Medication adherence must be 0.0-1.0, never null. This catches design flaws before they become production bugs.<br><br>
<strong>Step 4 ‚Äî Add Security Layers:</strong> Every endpoint gets RBAC defined before it's built. Who can call this? Case managers see only their patients. Admins see all. This is especially important in healthcare ‚Äî a case manager accidentally seeing another clinic's patients is a HIPAA incident.<br><br>
<strong>Step 5 ‚Äî Plan for Audit:</strong> Every data access endpoint gets HIPAA audit logging built in from day one, not added later. Later never comes."`
  },

  sensitive: {
    type: "interview",
    title: "Handling Sensitive Patient Data",
    question: "How do you handle sensitive patient data in your systems? Walk me through your approach to data security and HIPAA compliance in MindBridge.",
    context: "This question tests both technical knowledge and healthcare domain understanding. Show that HIPAA is baked into the architecture, not bolted on.",
    ideal: `"I treat HIPAA compliance as architecture, not an afterthought. There are four layers in MindBridge:<br><br>
<strong>1. Data at Rest:</strong> The PostgreSQL database volume is encrypted with AES-256. PHI fields ‚Äî patient names, dates of birth ‚Äî are additionally encrypted at the application layer using Fernet symmetric encryption. Two independent encryption layers means a database dump is useless without both keys.<br><br>
<strong>2. Data in Transit:</strong> TLS 1.3 for all API connections. We enforce HTTPS-only ‚Äî any HTTP request redirects to HTTPS. JWT tokens are signed with RS256 and expire after 8 hours.<br><br>
<strong>3. Access Control:</strong> Role-based access control at the API layer, plus Row-Level Security in PostgreSQL. A case manager's query literally cannot return another case manager's patients ‚Äî it's enforced at the database level, not just the application level. Defense in depth.<br><br>
<strong>4. Audit Logging:</strong> Every access to PHI ‚Äî every patient view, every screening, every report download ‚Äî is logged to an immutable audit table with user_id, timestamp, IP address, and action. This is what HIPAA auditors look for after an incident. We also never hard-delete records ‚Äî soft deletes with deleted_at timestamps, because HIPAA requires retention.<br><br>
<strong>5. Version Control Hygiene:</strong> .gitignore excludes all generated reports and patient data. Environment variables for all credentials ‚Äî never in code. The .gitignore itself is a HIPAA compliance document in our repository."`
  },

  testing: {
    type: "interview",
    title: "Your Testing Strategy",
    question: "Walk me through your testing strategy for MindBridge. How do you ensure the AI doesn't give dangerous medical advice?",
    context: "Healthcare AI requires rigorous testing. Show you understand both technical testing AND clinical safety.",
    ideal: `<strong>Three-layer testing strategy:</strong><br><br>
<strong>LAYER 1 ‚Äî Unit Tests (Technical Safety):</strong><br>
Test each function in isolation using pytest.<br>
Example: test_patient_risk_calculation() verifies that medication_adherence=0.3 + appointments_missed=4 correctly flags as HIGH risk.<br>
Example: test_pydantic_validation() ensures medication_adherence=5.0 is rejected (must be 0.0-1.0).<br>
Coverage target: 90% of backend code.<br><br>
<strong>LAYER 2 ‚Äî Integration Tests (System Safety):</strong><br>
Test complete workflows end-to-end.<br>
Example: POST /api/analysis with real patient data ‚Üí verify Claude API is called ‚Üí verify response saved to database ‚Üí verify audit log entry created.<br>
Example: Test authentication ‚Äî 401 if no token, 403 if wrong role.<br><br>
<strong>LAYER 3 ‚Äî Clinical Guardrails (Patient Safety):</strong><br>
This is where my 10 years of clinical experience matters.<br>
<strong>Guardrail 1:</strong> AI can never automatically downgrade a patient from HIGH to MEDIUM risk. Only a licensed clinician can do that.<br>
<strong>Guardrail 2:</strong> If patient has crisis_calls_30days > 0, risk level is minimum MEDIUM regardless of other factors.<br>
<strong>Guardrail 3:</strong> AI suggestions are always labeled "AI-Generated - Requires Clinical Review" in the UI.<br>
<strong>Guardrail 4:</strong> All AI assessments log the exact prompt and response to audit_log for post-incident review.<br><br>
<strong>Real-world testing:</strong><br>
I'd also pilot with 5 case managers for 2 weeks before full rollout. Track: How often do they override the AI? What patterns emerge? Are false positives causing alert fatigue?<br><br>
<strong>Interview gold:</strong> "In healthcare AI, testing isn't just about code correctness. It's about clinical safety. The AI is a tool to help clinicians, not replace their judgment. That's why the guardrails prevent automated decisions on critical actions."`
  },

  bulkimport: {
    type: "interview",
    title: "Design Challenge - Bulk CSV Import",
    question: "A clinic wants to import 500 existing patients from a CSV file. How would you design this feature from scratch?",
    context: "This tests system design thinking, not just coding. Show you think about users, errors, performance, and safety.",
    ideal: `<strong>USER WORKFLOW FIRST:</strong><br>
Case manager uploads CSV with 500 patients ‚Üí System validates ‚Üí Imports ‚Üí Returns summary: "450 imported, 50 errors with reasons"<br><br>
<strong>TECHNICAL DESIGN:</strong><br><br>
<strong>STEP 1 ‚Äî Endpoint Design:</strong><br>
POST /patients/import accepts file upload (multipart/form-data)<br>
Returns 202 Accepted immediately with task_id (don't block ‚Äî 500 patients is too slow for sync request)<br><br>
<strong>STEP 2 ‚Äî Validation (Fail Fast):</strong><br>
Check: Is it a valid CSV? Required columns present (name, DOB, medication_adherence)?<br>
Return 400 Bad Request immediately if malformed ‚Äî don't waste time processing garbage.<br><br>
<strong>STEP 3 ‚Äî Background Processing (Celery Worker):</strong><br>
500 patients √ó 2 seconds each = 1000 seconds (16 minutes). Can't block a web request that long.<br>
Use Celery to process async. Frontend polls GET /imports/{task_id} for status.<br><br>
<strong>STEP 4 ‚Äî Row-Level Validation:</strong><br>
For each row: Pydantic validates data types. Check for duplicates (same name + DOB already in DB). Log invalid rows separately ‚Äî don't fail entire import for one bad row.<br><br>
<strong>STEP 5 ‚Äî Database Transaction:</strong><br>
Wrap ALL inserts in a single transaction. If DB fails mid-import, rollback everything ‚Äî no partial imports (150 patients in, 350 missing = data corruption).<br><br>
<strong>STEP 6 ‚Äî HIPAA Audit:</strong><br>
Log: Who uploaded (user_id). When (timestamp). Which file (filename, hash). How many patients (count). Store the original CSV temporarily for post-incident review if needed.<br><br>
<strong>STEP 7 ‚Äî Result Endpoint:</strong><br>
GET /imports/{task_id} returns:<br>
{status: "processing|completed|failed", imported: 450, errors: [{row: 23, reason: "Invalid medication_adherence: must be 0.0-1.0"}]}<br><br>
<strong>SECURITY CONSIDERATIONS:</strong><br>
File size limit (10MB max ‚Äî prevent DOS)<br>
Virus scan the CSV<br>
RBAC ‚Äî only admins can bulk import<br>
Rate limit ‚Äî 1 import per hour per user<br><br>
<strong>Interview gold:</strong> "I'd prototype with synchronous processing for 50 patients first, then add Celery when we hit scale. Always validate MVP assumptions with real usage before building complex async systems. Over-engineering early kills velocity."`
  },

  docker: {
    type: "concept",
    title: "Docker & Containerization",
    question: "Explain Docker and why MindBridge uses it. What problem does it solve, and what would happen without it?",
    context: "Go beyond the textbook definition. Tie it to healthcare reliability and the specific MindBridge use case.",
    ideal: `<strong>What Docker is:</strong> Docker packages an application and ALL its dependencies ‚Äî Python version, libraries, OS configurations ‚Äî into a portable container that runs identically everywhere.<br><br>
<strong>The problem it solves:</strong> Without Docker, "it works on my machine" is a patient safety issue. If the development environment uses Python 3.11 and production uses Python 3.9, subtle behavioral differences could cause risk assessments to produce different results. In healthcare, that's not a bug ‚Äî it's a clinical liability.<br><br>
<strong>MindBridge's docker-compose.yml has three services:</strong><br>
‚Ä¢ backend ‚Äî FastAPI on port 8000 with hot-reload for development<br>
‚Ä¢ db ‚Äî PostgreSQL 16 on port 5432 with health checks<br>
‚Ä¢ redis ‚Äî Redis 7 on port 6379 for caching and sessions<br><br>
<strong>The health check matters:</strong> depends_on with service_healthy ensures FastAPI won't start until PostgreSQL is confirmed ready. Without this, the app crashes on startup and a case manager can't log in.<br><br>
<strong>For a new developer:</strong> git clone + docker compose up = complete local environment in 60 seconds. Same database version, same Python version, same Redis. No "it works on my machine."`
  },

  postgres: {
    type: "concept",
    title: "PostgreSQL vs MongoDB",
    question: "Why did you choose PostgreSQL over MongoDB for MindBridge? When would MongoDB be the right choice?",
    context: "Show you understand the tradeoffs, not just that 'relational is better'. Healthcare-specific reasoning is key.",
    ideal: `<strong>Three reasons PostgreSQL for MindBridge:</strong><br><br>
<strong>1. ACID Transactions:</strong> When we run a risk screening, three things happen: INSERT screening result, UPDATE patient risk_level, INSERT audit_log entry. ALL three must succeed or NONE do ‚Äî no partial writes. In healthcare, a partial write could show a patient as 'low risk' while the actual screening says 'high risk'. MongoDB's document model can handle transactions, but they're more complex and less reliable under failure conditions.<br><br>
<strong>2. Row-Level Security:</strong> We enforce at the DATABASE level that case managers can only query their own patients ‚Äî not just the application level. If there's ever a bug in our FastAPI code, the database itself won't return unauthorized patient records. This defense-in-depth is what HIPAA auditors look for.<br><br>
<strong>3. JSONB for flexibility:</strong> We don't lose MongoDB's flexibility ‚Äî PostgreSQL's JSONB columns store the semi-structured AI analysis output alongside structured patient data. Best of both worlds.<br><br>
<strong>When MongoDB would be right:</strong> If we were storing unstructured clinical notes, medical images metadata, or building a feature with rapidly evolving schema where migrations would slow development, MongoDB would make sense as a supplementary store alongside PostgreSQL.`
  },

  hipaa: {
    type: "concept",
    title: "HIPAA Security Requirements",
    question: "What does the HIPAA Security Rule require for a system like MindBridge? How have you implemented these requirements?",
    context: "Most engineers know HIPAA exists but can't explain it technically. This is your chance to stand out.",
    ideal: `<strong>HIPAA Security Rule has three categories of safeguards:</strong><br><br>
<strong>Technical Safeguards (what we build):</strong><br>
‚Ä¢ Encryption at rest: AES-256 for database volumes + application-level field encryption for PHI<br>
‚Ä¢ Encryption in transit: TLS 1.3 for all connections, HTTPS-only<br>
‚Ä¢ Access controls: JWT authentication + RBAC + PostgreSQL Row-Level Security<br>
‚Ä¢ Audit controls: Immutable audit_log table ‚Äî every PHI access recorded with user, timestamp, IP, action<br>
‚Ä¢ Automatic logoff: JWT tokens expire after 8 hours of inactivity<br><br>
<strong>Physical Safeguards (infrastructure):</strong><br>
‚Ä¢ Covered by cloud providers (AWS, Vercel, Railway) via Business Associate Agreements (BAAs)<br>
‚Ä¢ The BAA is the legal contract saying the cloud provider is also HIPAA-responsible<br><br>
<strong>Administrative Safeguards (policies):</strong><br>
‚Ä¢ Access review process: who can access what, reviewed quarterly<br>
‚Ä¢ Workforce training: documented security training for all staff<br>
‚Ä¢ Incident response plan: documented procedure for breach notification (72-hour rule)<br><br>
<strong>The 72-hour rule:</strong> If patient data is breached, you have 72 hours to notify affected patients and HHS. This is why our incident detection and audit logging is real-time, not batch.`
  },

  pooling: {
    type: "concept",
    title: "Connection Pooling Deep Dive",
    question: "You mentioned connection pooling in your resume. Explain what it is, why MindBridge needs it, and what happens when the pool is exhausted.",
    context: "This tests real production database knowledge, not just theory.",
    ideal: `<strong>What connection pooling is:</strong><br>
Connection pooling reuses database connections instead of opening a new one for every request. Think of it like a shared bike system ‚Äî bikes sit ready to use, you don't build a new bike each time.<br><br>
<strong>Why it matters for MindBridge:</strong><br>
Opening a PostgreSQL connection takes 50-100ms. If 100 case managers hit the dashboard simultaneously:<br>
WITHOUT pooling: 100 √ó 100ms = 10 seconds of pure connection overhead. The last user waits 10 seconds just to START their query.<br>
WITH pooling: 10 persistent connections ready. Requests queue and reuse existing connections. Max wait ‚âà query time, not connection time.<br><br>
<strong>MindBridge configuration:</strong><br>
engine = create_async_engine('postgresql://...', pool_size=10, max_overflow=20)<br>
This means: 10 persistent connections, can burst to 30 under heavy load.<br><br>
<strong>What happens when pool exhausted:</strong><br>
Error: 'QueuePool limit of size 10 overflow 20 reached, connection timed out'<br>
Users see: 500 Internal Server Error<br>
Real impact: Dashboard stops working during peak hours (morning when all case managers log in)<br><br>
<strong>How to fix:</strong><br>
Increase pool_size (but don't go crazy ‚Äî PostgreSQL has connection limits too)<br>
Find connection leaks (endpoints not closing DB sessions)<br>
Add connection pooling metrics to monitoring<br><br>
<strong>Interview gold:</strong> "Connection pooling is why MindBridge can handle 50 concurrent users on a single backend instance. Without it, we'd need 10√ó the server capacity or users would experience random timeouts."`
  },

  // === ADVANCED SIMULATIONS (7 NEW) ===
  
  ratelimit: {
    type: "simulation",
    title: "Implement Rate Limiting",
    question: "Case managers are reporting '429 Too Many Requests' errors when running batch screenings. Your rate limit is 100 requests/hour per user. How do you explain this to them and what's the fix?",
    context: "Balance user experience with API protection. Show you understand both technical and communication aspects.",
    ideal: `<strong>Why it's happening:</strong><br>
Rate limiting is a defense mechanism that blocks users making excessive requests. 100 requests/hour means one request every 36 seconds. If a case manager is running batch screenings for 50 patients, they exceed this limit fast. This was designed for normal user behavior, not batch operations.<br><br>
<strong>How to explain to the case manager:</strong><br>
"Your batch screening workflow is hitting a rate limit designed to prevent abuse. We're going to solve this in two ways: (1) immediate workaround for you, (2) permanent fix in the code."<br><br>
<strong>IMMEDIATE WORKAROUND:</strong><br>
Don't screen 50 patients in rapid sequence. Space them out over 2 minutes. Or contact IT and we'll temporarily raise your limit while we implement the permanent fix.<br><br>
<strong>PERMANENT FIX ‚Äî Implement Redis-based rate limiting with tiered limits:</strong><br>
from slowapi import Limiter<br>
limiter = Limiter(key_func=get_remote_address, storage_uri="redis://localhost")<br>
@app.post("/screenings")<br>
@limiter.limit("100/hour; 10/minute")<br>
async def create_screening(): ...<br><br>
This allows 10 requests per minute (covers normal use) but 100/hour overall (prevents abuse). Batch users stay under 10/min by spreading requests over 5 minutes.<br><br>
<strong>BETTER ‚Äî User-tier rate limits:</strong><br>
Regular case managers: 100/hour<br>
Power users (batch processing): 1000/hour (with supervisor approval)<br>
AI/automation: higher limits with API keys<br><br>
Check user role in the database and apply different limits:<br>
limit = "1000/hour" if user.tier == "power_user" else "100/hour"<br><br>
<strong>BEST PRACTICE ‚Äî Alert before limit:</strong><br>
Include rate limit headers in every response:<br>
X-RateLimit-Limit: 100<br>
X-RateLimit-Remaining: 23<br>
X-RateLimit-Reset: 1629234000<br>
Frontend shows a warning when remaining < 10: "You have 23 requests left this hour."<br><br>
<strong>Interview gold:</strong> "Rate limiting protects the API, but it shouldn't be invisible. Show users how close they are to the limit and offer tiered limits for different use cases. A 429 error on a patient's life-or-death screening is a UX failure."`
  },

  circuitbreaker: {
    type: "simulation",
    title: "Circuit Breaker Pattern",
    question: "Claude's API goes down. Your system makes 50 requests/second to it. Each request times out after 30 seconds. What happens to MindBridge?",
    context: "This tests understanding of cascading failures. Show you know defensive programming patterns.",
    ideal: `<strong>The disaster scenario:</strong><br>
Claude API goes down at 2 PM. MindBridge continues sending 50 req/sec to the dead API. Each one waits 30 seconds for a timeout. Within seconds, you have 1500 requests waiting (50 √ó 30), consuming all database connections. The pool is exhausted. Now EVERY API call ‚Äî even unrelated ones like patient lookup ‚Äî fails because there are no connections left. The entire system cascades into failure.<br><br>
<strong>Result:</strong> MindBridge appears completely dead even though YOUR code is fine. Case managers can't access patient data at all.<br><br>
<strong>THE FIX ‚Äî Implement Circuit Breaker Pattern:</strong><br>
The circuit breaker has 3 states:<br>
<strong>CLOSED (normal):</strong> Requests go through. If success rate > 95%, stay closed.<br>
<strong>OPEN (emergency):</strong> Claude is down. Don't send more requests. Immediately fail new requests with error "Risk assessment temporarily unavailable"<br>
<strong>HALF_OPEN (recovery):</strong> Periodically try 1 test request to Claude. If it succeeds, go back to CLOSED. If it fails, stay OPEN.<br><br>
<strong>Implementation using PyBreaker library:</strong><br>
from pybreaker import CircuitBreaker<br>
claude_breaker = CircuitBreaker(fail_max=5, reset_timeout=60)<br>
try:<br>
  response = claude_breaker.call(claude_api.call, patient_data)<br>
except CircuitBreakerListener as e:<br>
  return {risk: "UNKNOWN", message: "AI service temporarily down"}<br><br>
If Claude fails 5 times in a row, the circuit opens. Stop hitting it. Wait 60 seconds before retrying. Zero cascade.<br><br>
<strong>Fallback behavior:</strong><br>
When circuit is OPEN, don't just error. Provide graceful degradation:<br>
"Risk assessment unavailable (Claude API down). Using last known assessment from 15 minutes ago: HIGH RISK. A clinician will review when the service recovers."<br><br>
Better than showing an error, better than returning stale data silently.<br><br>
<strong>Monitoring:</strong><br>
Log every circuit state change. Alert ops when circuit opens: "Claude API circuit breaker tripped. Cascade prevented."<br><br>
<strong>Interview gold:</strong> "Circuit breakers prevent cascading failures. Without one, a downstream service failure can bring down your entire system in seconds. It's a pattern every production engineer should know."`
  },

  caching: {
    type: "simulation",
    title: "Redis Caching Layer",
    question: "Every dashboard load queries 'Get list of all medications' ‚Äî a 5-second query that returns the same 400 medications every time. How would you optimize this?",
    context: "Classic caching problem. Show you understand cache invalidation and TTL strategies.",
    ideal: `<strong>The problem:</strong><br>
Every case manager loads the dashboard. Dashboard queries: SELECT * FROM medications. This 5-second query runs EVERY dashboard load. If 20 case managers use the dashboard, that's 100 seconds of database query time when the data is identical.<br><br>
<strong>STEP 1 ‚Äî Identify the opportunity:</strong><br>
The medication list is reference data. It changes rarely (maybe quarterly when new drugs are approved). Perfect for caching.<br><br>
<strong>STEP 2 ‚Äî Add Redis caching:</strong><br>
from redis import Redis<br>
redis = Redis(host='localhost')<br><br>
async def get_medications():<br>
  # Try cache first<br>
  cached = redis.get('medications:list')<br>
  if cached:<br>
    return json.loads(cached)  # 1ms instead of 5000ms<br><br>
  # Cache miss ‚Äî query database<br>
  meds = await db.query("SELECT * FROM medications")<br><br>
  # Store in cache with 1 hour TTL<br>
  redis.setex('medications:list', 3600, json.dumps(meds))<br>
  return meds<br><br>
<strong>Result:</strong> First dashboard load: 5 seconds. All subsequent loads: 1 millisecond. 5000√ó faster.<br><br>
<strong>STEP 3 ‚Äî Cache invalidation:</strong><br>
Here's the hard part. When should the cache expire?<br>
Option 1: TTL of 1 hour. After 1 hour, cache expires. Database is checked again. Simple, but could serve stale data for up to 1 hour.<br>
Option 2: Event-based invalidation. When an admin adds a new medication via POST /medications, immediately invalidate the cache:<br>
  redis.delete('medications:list')<br>
  Database is queried again on next load. Always fresh.<br><br>
<strong>STEP 4 ‚Äî Cache warming (optional):</strong><br>
On app startup, pre-load the medications into cache. When a case manager first loads the dashboard, it's already cached. Zero wait.<br><br>
@app.on_event("startup")<br>
async def warm_cache():<br>
  meds = await db.query("SELECT * FROM medications")<br>
  redis.setex('medications:list', 3600, json.dumps(meds))<br><br>
<strong>The tradeoff:</strong><br>
Benefit: 5000√ó faster loads, reduced database load<br>
Cost: Redis memory, staleness window, cache invalidation complexity<br>
Worth it? Absolutely. Reference data caching is high-impact, low-risk.<br><br>
<strong>Interview gold:</strong> "Cache invalidation is one of the two hardest problems in computer science. For reference data, TTL + event-based invalidation is the safest approach. Always measure the benefit ‚Äî 5000√ó faster is worth the complexity."`
  },

  deployment: {
    type: "simulation",
    title: "Zero-Downtime Deployment",
    question: "You need to deploy a database schema change (adding a new column to patients table). How do you do it without taking MindBridge offline?",
    context: "Production deployment requires careful planning. Show you understand database migrations and backward compatibility.",
    ideal: `<strong>The naive approach (FAILS):</strong><br>
Stop the backend. ALTER TABLE patients ADD COLUMN risk_assessment_date DATE. Start the backend. Result: 5 minutes of downtime. In healthcare, that's unacceptable.<br><br>
<strong>THE CORRECT APPROACH ‚Äî 3-Phase Deployment:</strong><br><br>
<strong>PHASE 1 ‚Äî Backward compatibility (deploy backend code):</strong><br>
Update the backend code to handle the NEW schema before the schema exists. This seems weird but it's the key to zero downtime.<br>
Add code that checks: if column exists, use it. If not, use default value.<br>
python<br>
if 'risk_assessment_date' in columns:<br>
  created_at = patient.risk_assessment_date<br>
else:<br>
  created_at = datetime.now()  # Fallback<br><br>
Deploy this code. Old schema still exists. No downtime. All requests still work.<br><br>
<strong>PHASE 2 ‚Äî Run the migration (background):</strong><br>
During off-peak hours (2 AM), run the ALTER TABLE without taking the service down. PostgreSQL allows concurrent connections during schema changes (in most cases).<br>
But here's the issue: ALTER TABLE ... ADD COLUMN on a 100M row table takes TIME. Lock the table, and you block case managers from accessing patients. Solution: Use online migration tools.<br><br>
Option A: Postgres 11+ ADD COLUMN with default is relatively fast<br>
Option B: Use pg_gzip or similar tools for truly massive tables<br>
Option C: Create new table, backfill data, swap tables (manual but 100% safe)<br><br>
<strong>PHASE 3 ‚Äî Remove the fallback code (deploy backend code again):</strong><br>
Once migration is complete, deploy clean code that always expects the column to exist.<br>
if 'risk_assessment_date' in columns:  # Never true now, safe to remove<br><br>
<strong>Full example timeline:</strong><br>
3:30 PM: Deploy code with fallback logic. Env: prod. Result: working, old schema.<br>
2:00 AM: ALTER TABLE patients ADD COLUMN risk_assessment_date DATE DEFAULT null. Duration: 2 minutes. Zero downtime.<br>
9:00 AM: Deploy code without fallback. Result: working, new schema.<br><br>
Total downtime: 0 minutes. Case managers never notice.<br><br>
<strong>Rollback plan:</strong><br>
If something goes wrong at Phase 1, redeploy code without the fallback. If Phase 2 fails, rollback and retry. If Phase 3 fails, code is still compatible with old schema.<br><br>
<strong>Interview gold:</strong> "Zero-downtime deployments require thinking backward: code first, schema second. Write code that works with both old and new schema. Then change the schema. Then clean up the code. This is standard practice at every major tech company."`
  },

  monitoring: {
    type: "simulation",
    title: "Production Monitoring & Alerts",
    question: "Your CTO asks: 'How do we know if MindBridge is working?' What metrics do you monitor and what triggers an alert?",
    context: "Production systems need observability. Show you think about proactive monitoring, not just reactive debugging.",
    ideal: `<strong>The wrong answer:</strong> "I check the dashboard if it's running." That's reactive. You measure, you don't wait for users to complain.<br><br>
<strong>CRITICAL METRICS (Real-time monitoring):</strong><br><br>
<strong>1. Application Health:</strong><br>
‚Ä¢ Response time: API endpoints should return in < 500ms. Alert if > 1000ms (something is slow)<br>
‚Ä¢ Error rate: < 1% of requests should fail. Alert if > 5%<br>
‚Ä¢ Availability: Uptime target 99.9%. Alert if any endpoint is unavailable for 5+ minutes<br>
‚Ä¢ Database connection pool: Alert if pool_size usage > 80% (approaching exhaustion)<br><br>
<strong>2. Healthcare-Specific Metrics:</strong><br>
‚Ä¢ AI screening latency: Claude API calls should complete in < 30s. Alert if > 60s<br>
‚Ä¢ Audit log volume: Every patient access should be logged. Alert if audit logging fails<br>
‚Ä¢ Overdue screenings: How many patients haven't been screened in 30 days? (Clinical concern, not technical)<br><br>
<strong>3. Infrastructure Metrics:</strong><br>
‚Ä¢ Database CPU: Alert if > 80%<br>
‚Ä¢ Disk space: Alert if < 20% free<br>
‚Ä¢ Memory usage: Alert if > 85%<br><br>
<strong>ALERT TIERS ‚Äî Not all alerts are equal:</strong><br><br>
<strong>CRITICAL (Page on-call engineer immediately):</strong><br>
‚Ä¢ API is down (no response to health check)<br>
‚Ä¢ Database is unreachable<br>
‚Ä¢ Payment system is down<br>
Silencing a CRITICAL alert: unacceptable<br><br>
<strong>WARNING (Alert but don't page, review next morning):</strong><br>
‚Ä¢ Response time > 2 seconds<br>
‚Ä¢ Error rate > 5%<br>
‚Ä¢ Cache hit rate drops below 50%<br><br>
<strong>INFO (Log, useful for debugging):</strong><br>
‚Ä¢ Database query slow (but < 5s)<br>
‚Ä¢ New user signup<br>
‚Ä¢ Patient screening completed<br><br>
<strong>Implementation example:</strong><br>
from prometheus_client import Counter, Histogram, Gauge<br>
request_duration = Histogram('request_duration_seconds', 'Request latency')<br>
request_errors = Counter('request_errors_total', 'Request errors')<br>
connection_pool = Gauge('db_connection_pool_usage', 'DB pool usage')<br><br>
@app.post("/screenings")<br>
async def create_screening():<br>
  with request_duration.time():<br>
    try:<br>
      result = await claude_api.call(...)<br>
      if result.success:<br>
        return result<br>
    except Exception as e:<br>
      request_errors.inc()<br>
      raise<br><br>
<strong>Dashboard alerts (example PagerDuty/DataDog):</strong><br>
if response_time > 1000ms for 5 consecutive minutes:<br>
  alert_severity = "CRITICAL"<br>
  notify_on_call_engineer()<br><br>
if error_rate > 10% for 10 consecutive minutes:<br>
  alert_severity = "WARNING"<br>
  log_to_slack_monitoring_channel()<br><br>
<strong>Interview gold:</strong> "Production monitoring isn't about vanity metrics. It's about knowing the moment something breaks before users do. Alert on what matters: availability, latency, errors. Ignore the rest."`
  },

  incident: {
    type: "simulation",
    title: "Production Incident Response",
    question: "3 PM on a Tuesday: Case managers report 'all patients showing as LOW risk' regardless of actual data. What do you do in the first 10 minutes?",
    context: "Incident response tests composure under pressure. Show systematic thinking, not panic.",
    ideal: `<strong>MINUTE 0 ‚Äî Assess severity:</strong><br>
Is this a data integrity issue (risk assessments are WRONG) or a display issue (UI showing wrong data)?<br>
How many users are affected? All case managers or just some?<br>
Is patient safety at risk? YES ‚Äî case managers might discharge a HIGH-RISK patient thinking they're low risk.<br>
This is CRITICAL. Escalate immediately.<br><br>
<strong>MINUTE 1 ‚Äî Triage:</strong><br>
Open Slack war room. Ping: Your manager, on-call database engineer, on-call backend engineer.<br>
Message: "INCIDENT: Risk assessment showing as LOW for all patients. Possible data corruption. Investigating."<br>
Avoid: Panic. Keep communication clear and factual.<br><br>
<strong>MINUTE 2 ‚Äî Duplicate issue check:</strong><br>
Is this affecting MindBridge in production only, or dev/staging too?<br>
Query the database directly (not through the API):<br>
SELECT count(*) FROM screenings WHERE risk_level = 'LOW';<br>
SELECT count(*) FROM screenings WHERE risk_level = 'HIGH';<br>
Check: Did the actual data in the database change, or is it a display bug?<br><br>
<strong>MINUTE 3 ‚Äî Check recent deployments:</strong><br>
What deployed in the last 3 hours?<br>
Did the risk calculation logic change?<br>
Was there a database migration?<br>
Check git log: git log --oneline -10<br>
If a recent deployment could have caused this, prepare to rollback.<br><br>
<strong>MINUTE 4 ‚Äî Check the application logs:</strong><br>
tail -f logs/app.log | grep -i risk<br>
tail -f logs/error.log<br>
Check Claude API logs: Did the model behavior change? Did it start returning only LOW risk assessments?<br><br>
<strong>MINUTE 5 ‚Äî Hypothesis:</strong><br>
If database data is correct but API is returning LOW for all: Application bug.<br>
If database data is all LOW: Data corruption or bad migration.<br><br>
Most likely: Recent deployment changed risk calculation threshold.<br>
Prepare rollback command (if your current deploy seems wrong):<br>
git revert <commit><br><br>
<strong>MINUTE 6 ‚Äî Communicate status:</strong><br>
Post to war room: "Investigating. Initial diagnosis: possible risk threshold change in recent deploy. Checking logs."<br>
Update status page: "Investigating risk assessment accuracy. No patient data loss detected."<br><br>
<strong>MINUTE 7 ‚Äî Start fix OR rollback:</strong><br>
If you found a recent deploy that changed risk formula: ROLLBACK<br>
git revert <bad_commit><br>
Deploy immediately. Monitor.<br><br>
If it's a data issue: Don't deploy yet. Keep investigating.<br><br>
<strong>MINUTE 10 ‚Äî Report status:</strong><br>
"Identified issue: Deploy from 1:15 PM changed risk threshold from 3.0 to 5.0. Rolled back. Monitoring now. All screenings should show correct risk levels."<br><br>
<strong>AFTER INCIDENT (tonight, not tomorrow):</strong><br>
1. Postmortem: Why did this deploy happen without catching the bug?<br>
2. Remediation: Add automated test that checks ‚â•1 patient has HIGH risk in test data. Catches this next time.<br>
3. Communication: Clinic leadership gets summary: "Brief incident. Root cause identifies. Preventive measures in place."<br><br>
<strong>Interview gold:</strong> "Incident response is systematic: assess severity, gather info, form hypothesis, fix/rollback, monitor, communicate, postmortem. Never panic. A clear head fixes incidents in minutes. Panic extends them for hours."`
  },

  multitenancy: {
    type: "simulation",
    title: "Multi-Tenant Architecture",
    question: "MindBridge currently serves one clinic. A second clinic signs up. They want their data completely isolated. How do you architect this?",
    context: "Multi-tenancy is a common scaling challenge. Show you understand data isolation and security boundaries.",
    ideal: `<strong>The constraint:</strong><br>
Clinic A wants zero visibility into Clinic B's patient data. Not even metadata (how many patients, how many screenings). This is both a contractual requirement and a privacy requirement.<br><br>
<strong>THREE APPROACHES (with tradeoffs):</strong><br><br>
<strong>APPROACH 1 ‚Äî Shared Database, Shared Schema (simplest, least secure):</strong><br>
One database, one patients table, add clinic_id column.<br>
CREATE TABLE patients (id, name, clinic_id, risk_level, ...);<br><br>
Row-level security at the database level:<br>
CREATE POLICY clinic_isolation ON patients<br>
USING (clinic_id = current_setting('user_clinic_id'));<br><br>
Pros: Simple to implement, easy to manage one database<br>
Cons: One bug in the code and Clinic A can see Clinic B's data. HIPAA nightmare.<br><br>
<strong>APPROACH 2 ‚Äî Shared Database, Separate Schemas (better):</strong><br>
One PostgreSQL database, separate schema per clinic.<br>
CREATE SCHEMA clinic_a;<br>
CREATE SCHEMA clinic_b;<br>
CREATE TABLE clinic_a.patients (...);<br>
CREATE TABLE clinic_b.patients (...);<br><br>
On login, set search_path:<br>
SET search_path TO 'clinic_a';<br>
SELECT * FROM patients; -- Only sees clinic_a patients<br><br>
Pros: Better isolation, single database<br>
Cons: Still one database server, complex migrations (need to run on each schema)<br><br>
<strong>APPROACH 3 ‚Äî Separate Databases (safest, most expensive):</strong><br>
Clinic A gets their own PostgreSQL instance. Clinic B gets their own instance. Completely isolated.<br>
postgres://clinic_a_db.railway.app:5432/mindbridge (Clinic A)<br>
postgres://clinic_b_db.railway.app:5432/mindbridge (Clinic B)<br><br>
FastAPI routes to the correct database based on clinic_id:<br>
if user.clinic_id == 'clinic_a':<br>
  db = get_db(DSN_A)<br>
else:<br>
  db = get_db(DSN_B)<br><br>
Pros: Complete isolation, regulatory-approved (HIPAA loves this)<br>
Cons: Multiple database instances = higher cost, more ops overhead<br><br>
<strong>MY RECOMMENDATION FOR MINDBRIDEGE:</strong><br>
Start with Approach 2 (shared DB, separate schemas). It's the middle ground:<br>
‚Ä¢ Good isolation (Approach 1 bug won't expose data)<br>
‚Ä¢ Reasonable cost (one database server)<br>
‚Ä¢ Scales to ~20 clinics before capacity issues<br><br>
If you grow beyond 20 clinics and need stronger isolation guarantees, move to Approach 3 (separate databases).<br><br>
<strong>Additional considerations:</strong><br>
<strong>User authentication:</strong> Who can log in? Only clinic staff with clinic_id match.<br>
SELECT user FROM users WHERE email=? AND clinic_id = logged_in_user.clinic_id<br><br>
<strong>Audit logging:</strong> Separate audit tables per clinic (or clinic_id column in shared table)<br><br>
<strong>Backups:</strong> If using separate databases, backup each independently. Clinic A will want their own backup/recovery strategy.<br><br>
<strong>Interview gold:</strong> "Multi-tenancy is about isolation guarantees. Row-level security is fragile. Separate schemas are middle-ground. Separate databases are fortress. Choose based on your risk tolerance and budget."`
  },

  // === HEALTHCARE-SPECIFIC (4 NEW) ===

  fhir: {
    type: "concept",
    title: "FHIR Integration",
    question: "A hospital wants MindBridge to integrate with their Epic EHR using FHIR R4. What is FHIR and how would you approach this integration?",
    context: "FHIR is the healthcare data interoperability standard. Show you understand the healthcare ecosystem.",
    ideal: `<strong>What FHIR is:</strong><br>
FHIR (Fast Healthcare Interoperability Resources) is the modern standard for exchanging healthcare data. It's RESTful, JSON-based, and designed to make different healthcare systems talk to each other.<br><br>
Think of it like: Your MindBridge API vs. Epic's API. FHIR is the common language both speak.<br><br>
<strong>FHIR Resources (the building blocks):</strong><br>
Every piece of healthcare data is a "Resource" with a defined structure:<br>
‚Ä¢ Patient resource: demographics, name, DOB, contact info<br>
‚Ä¢ Encounter resource: visits, appointments, ED visits<br>
‚Ä¢ Observation resource: vital signs, test results, clinical measurements<br>
‚Ä¢ Medication resource: medication lists, dispensing info<br>
‚Ä¢ Condition resource: diagnoses<br><br>
Epic and MindBridge both speak these standard structures. No custom mapping needed.<br><br>
<strong>Why FHIR matters for MindBridge:</strong><br>
Instead of asking the hospital "send me a CSV with patient data," you say "I'll read your FHIR API." You get:<br>
‚Ä¢ Real-time data (don't wait for manual exports)<br>
‚Ä¢ Standardized structure (one code handles any hospital)<br>
‚Ä¢ Better data quality (hospital maintains it)<br><br>
<strong>Integration approach (3 phases):</strong><br><br>
<strong>PHASE 1 ‚Äî FHIR API Connection:</strong><br>
Epic exposes FHIR REST API at: https://epic.hospital.com/fhir/R4/<br>
Authenticate using SMART on FHIR (OAuth 2.0 for healthcare):<br>
1. MindBridge requests auth from Epic<br>
2. Hospital admin grants permission<br>
3. MindBridge gets access token<br>
4. MindBridge can now call Epic's API<br><br>
<strong>PHASE 2 ‚Äî Data Sync (Pull):</strong><br>
Scheduled job (nightly or real-time):<br>
GET https://epic.hospital.com/fhir/R4/Patient?_lastUpdated=gt2024-02-20<br>
This returns all patients modified since yesterday, as FHIR JSON.<br><br>
Example FHIR Patient resource in JSON:<br>
{<br>
  "resourceType": "Patient",<br>
  "id": "12345",<br>
  "name": [{family: "Johnson", given: ["Marcus"]}],<br>
  "birthDate": "1985-03-15",<br>
  "contact": [{telecom: [{system: "phone", value: "555-1234"}]}]<br>
}<br><br>
Map this to MindBridge schema:<br>
INSERT INTO patients (id, name, dob, phone) VALUES (12345, 'Marcus Johnson', 1985-03-15, '555-1234');<br><br>
<strong>PHASE 3 ‚Äî Data Enrichment:</strong><br>
GET /Observation?patient=12345 ‚Äî Get vital signs, test results<br>
GET /Medication?patient=12345 ‚Äî Get medication list<br>
GET /Condition?patient=12345 ‚Äî Get diagnoses<br><br>
Process all this to create your risk assessment:<br>
‚Ä¢ Medications => medication_adherence<br>
‚Ä¢ Conditions => comorbidities<br>
‚Ä¢ Observations => clinical factors<br><br>
<strong>Challenges you'll face:</strong><br>
1. Epic and other EHRs implement FHIR slightly differently (profiles). You need to handle variations.<br>
2. Permission scope: You can only read what the hospital grants ("read:Patient" vs. "read:Medication").<br>
3. Real-time updates: FHIR polling is nightly. For live data, use webhooks (hospital pushes updates to you).<br><br>
<strong>Interview gold:</strong> "FHIR is the healthcare interoperability standard. Instead of custom integrations with each EHR, you code to FHIR once and it works with Epic, Cerner, eClinicalWorks, etc. It's the future of healthcare IT."`
  },

  hl7: {
    type: "concept",
    title: "HL7 v2 Message Parsing",
    question: "A clinic sends you patient data as HL7 v2 messages, not JSON. What is HL7 and how would you parse it?",
    context: "HL7 v2 is the legacy healthcare data format. Still extremely common. Show you can bridge old and new systems.",
    ideal: `<strong>What HL7 v2 is (the legacy standard before FHIR):</strong><br>
HL7 v2 is a pipe-delimited text format that's been used by hospitals since the 1980s. It's ugly, but it's everywhere.<br><br>
Example HL7 v2 message:<br>
MSH|^~\\|MindBridge|Hospital|System|System|202402201500||ADT^A04|MSG00001|P|2.4<br>
PID|1||12345^^^MRN||Johnson^Marcus||19850315|M|||123 Main St^Apt 4^Anytown^CA^90210<br>
PV1|1|I|2East^210^1|H||||||||||||||MRN20240220|||||||||||||||||||||201...<br><br>
Looks like gibberish, right? But it's structured.<br><br>
<strong>HL7 Structure (segments separated by ^ ~ \):</strong><br>
‚Ä¢ MSH: Message header metadata<br>
‚Ä¢ PID: Patient demographics<br>
‚Ä¢ PV1: Patient visit/encounter<br>
‚Ä¢ OBX: Observations (vital signs, test results)<br>
‚Ä¢ RXA: Medication administration<br><br>
Example breakdown of the PID segment:<br>
PID|1||12345^^^MRN||Johnson^Marcus||19850315|M|||123 Main St^Apt 4^Anytown^CA^90210<br>
    |patient sequence number<br>
         |field separator (^)<br>
                    |patient ID<br>
                                 |last name^first name<br>
                                                    |birth date<br>
                                                         |gender<br><br>
<strong>How to parse HL7 v2 in Python:</strong><br>
from hl7apy.core import parse_message<br>
msg = parse_message(hl7_raw_text)<br>
<br>
name = msg['PID'][-5][0][0]  # Get PID segment, patient name field<br>
Or use a more readable library:<br>
<br>
import hl7<br>
parsed = hl7.parse(message_string)<br>
patient_name = parsed[0][5]  # PID segment, name field<br>
patient_dob = parsed[0][7]   # PID segment, DOB field<br><br>
<strong>Real-world MindBridge example:</strong><br>
Hospital sends HL7 messages with patient data. MindBridge needs to:<br>
1. Parse the HL7 v2 message<br>
2. Extract patient demographics and medication list<br>
3. Store in PostgreSQL in MindBridge schema<br>
4. Run risk assessment<br><br>
async def ingest_hl7_message(raw_hl7):<br>
  try:<br>
    msg = parse_hl7(raw_hl7)  # Custom parser<br>
    patient = {<br>
      'name': msg.PID.patient_name,<br>
      'dob': msg.PID.birth_date,<br>
      'clinic_id': msg.MSH.sending_facility<br>
    }<br>
    await db.patients.insert(patient)<br>
    # Now run screening on new patient<br>
    screening = await run_screening(patient)<br>
  except HL7ParseError as e:<br>
    log_error(f"Invalid HL7: {e}")<br>
    notify_hospital()  # Send bounce message back to hospital<br><br>
<strong>Challenges:</strong><br>
1. HL7 is flexible ‚Äî different hospitals use it differently. You need custom mappings for each hospital.<br>
2. Error handling: If HL7 is malformed, reject it and send back an error acknowledgement (HA^ACK message).<br>
3. Version mismatch: Hospital sends HL7 v2.3, you expect v2.4. Handle both.<br><br>
<strong>The bridge to FHIR:</strong><br>
Many hospitals are moving TO FHIR FROM HL7. But legacy systems still send HL7. Your job: accept both, convert to your internal format, process uniformly.<br><br>
<strong>Interview gold:</strong> "HL7 v2 is legacy but ubiquitous in healthcare. You'll likely encounter it. The key is systematic parsing and defensive error handling."`
  },

  medication: {
    type: "interview",
    title: "Medication Interaction Checking",
    question: "Design a feature that alerts case managers if a patient is prescribed two medications with dangerous interactions. How would you build this?",
    context: "Healthcare-specific system design. Show you understand clinical safety AND technical architecture.",
    ideal: `<strong>The requirement:</strong><br>
When a patient's medication list is updated (from EHR sync or manual entry), check for drug-drug interactions. If Patient X is on Medication A and Medication B, and A+B can cause a dangerous interaction, alert the case manager immediately.<br><br>
<strong>DESIGN ‚Äî Three components:</strong><br><br>
<strong>COMPONENT 1 ‚Äî Drug Interaction Database:</strong><br>
You need a source of truth for drug interactions. Options:<br>
Option A: Use a commercial API (DrugBank, FDA Interactions, RxNorm)<br>
Option B: Build it from RxNorm (free from NIH)<br>
<br>
I'd use RxNorm API + supplement with clinical knowledge:<br>
<br>
CREATE TABLE drug_interactions (<br>
  drug_a_id INTEGER,<br>
  drug_b_id INTEGER,<br>
  interaction_type VARCHAR (moderate|severe|contraindicated),<br>
  description TEXT,<br>
  management TEXT<br>
);<br><br>
Examples:<br>
(Warfarin, Aspirin) -> SEVERE: "Increased bleeding risk"<br>
(SSRIs, MAOIs) -> CONTRAINDICATED: "Risk of serotonin syndrome"<br>
(Metformin, Alcohol) -> MODERATE: "Lactic acidosis risk"<br><br>
<strong>COMPONENT 2 ‚Äî Interaction Checker (Algorithm):</strong><br>
When patient's medications change, run this:<br>
<br>
async def check_interactions(patient_id):<br>
  meds = await get_patient_medications(patient_id)  # [Warfarin, Aspirin]<br>
  interactions = []<br>
  <br>
  # Check all pairs<br>
  for drug_a, drug_b in combinations(meds, 2):<br>
    interaction = await find_interaction(drug_a, drug_b)<br>
    if interaction and interaction.severity in ['SEVERE', 'CONTRAINDICATED']:<br>
      interactions.append(interaction)<br>
  <br>
  return interactions<br><br>
Result: [{drugs: [Warfarin, Aspirin], type: SEVERE, description: "Bleeding risk"}]<br><br>
<strong>COMPONENT 3 ‚Äî Alert UI/Workflow:</strong><br>
Display the alert to case manager:<br>
<br>
üö® CRITICAL MEDICATION INTERACTION<br>
Patient: Marcus Johnson<br>
Issue: Warfarin + Aspirin = Increased bleeding risk<br>
Action: Contact prescriber immediately to review<br>
Recommended: Consider alternative antiplatelet agent<br>
<br>
Buttons: [Acknowledge] [Contact Prescriber] [Override] [Escalate to MD]<br><br>
<strong>Important design detail:</strong><br>
DON'T auto-resolve the alert. A case manager must see and acknowledge it. Clinical safety requires human oversight.<br><br>
<strong>Implementation in the pipeline:</strong><br>
When EHR sync updates medications:<br>
1. Sync new meds to PostgreSQL<br>
2. Run check_interactions()<br>
3. If alerts found, create ALERT record in database<br>
4. Notify case manager (email, Slack, page)<br>
5. Alert stays open until case manager clicks [Acknowledge]<br>
6. Log the action: "Case manager acknowledged interaction, prescriber contacted"<br><br>
<strong>Tricky edge cases:</strong><br>
1. Over-the-counter drugs: Patient doesn't tell you they take Tylenol at home. Aspirin + Acetaminophen = interaction. Solution: Ask patient to list ALL medications (OTC, supplements, herbal).<br>
2. Duplicate alerts: Don't alert every day if it's the same interaction. Alert once, then periodically (weekly) remind.<br>
3. Severity tiers: SEVERE = immediate alert. MODERATE = info in UI. MINOR = log but don't alert.<br><br>
<strong>Database schema:</strong><br>
CREATE TABLE medication_interactions_alerts (<br>
  id UUID,<br>
  patient_id UUID,<br>
  drug_a_id INTEGER,<br>
  drug_b_id INTEGER,<br>
  interaction_id REF drug_interactions,<br>
  acknowledged_at TIMESTAMP,<br>
  acknowledged_by USER_ID,<br>
  action_taken TEXT,<br>
  created_at TIMESTAMP<br>
);<br><br>
<strong>Interview gold:</strong> "Medication interactions are a patient safety issue. Design it so case managers can't miss the alert, but can't auto-dismiss it. Make humans responsible for clinical decisions. That's how you prevent adverse events."`
  },

  patientmatching: {
    type: "interview",
    title: "Patient Matching Algorithm",
    question: "Two patient records: 'John Smith, DOB 1985-03-15' and 'Jonathan Smith, DOB 03/15/1985'. Same person or not? How do you handle patient matching?",
    context: "Patient identity matching is a hard, unsolved problem in healthcare. Show you understand the nuances.",
    ideal: `<strong>Why patient matching is hard:</strong><br>
‚Ä¢ Data entry errors: "John" vs. "Jonathan" ‚Äî are they the same person?<br>
‚Ä¢ Date format inconsistency: 1985-03-15 vs. 03/15/1985 ‚Äî parsing is tricky<br>
‚Ä¢ Missing data: What if one record has middle initial, one doesn't?<br>
‚Ä¢ Typos: "Smoth" vs. "Smith"<br>
‚Ä¢ Duplicate records in your own system: Same person entered twice<br>
<br>
In healthcare, this is called the "Patient Matching Problem." It's so common that there's a whole field (Master Patient Indexing) dedicated to it.<br><br>
<strong>Naive approach (FAILS):</strong><br>
if record1.name == record2.name and record1.dob == record2.dob:<br>
  # Same person<br>
<br>
Result: "John" != "Jonathan" ... incorrectly says different people. WRONG.<br><br>
<strong>BETTER APPROACH ‚Äî Probabilistic Matching (Fellebi distance):</strong><br>
Instead of exact match, calculate a "confidence score" (0-100) that two records are the same person.<br><br>
Factors to compare:<br>
‚Ä¢ Name similarity: Levenshtein distance (John vs. Jonathan)<br>
  levenshtein("John", "Jonathan") = 4 edits needed<br>
  similarity = 1 - (4 / max_len) = 50% match<br>
<br>
‚Ä¢ First name alias detection: "John" is commonly short for "Jonathan"<br>
  alias_match("John", "Jonathan") = 95% match<br>
<br>
‚Ä¢ DOB match: Exact match vs. month/year only vs. age estimate<br>
  "1985-03-15" vs. "03/15/1985" = 100% match (same date)<br>
<br>
‚Ä¢ gender match: Both male = +5 points<br>
<br>
‚Ä¢ Address match: Same zip code = +10 points<br>
<br>
Calculate confidence = (name_similarity + dob_match + gender_match + address_match) / 100<br><br>
Example matching:<br>
Patient A: John Smith, 1985-03-15, M, 90210<br>
Patient B: Jonathan Smith, 03/15/1985, M, 90210<br>
<br>
name_similarity: 95% (aliasing)<br>
dob_match: 100%<br>
gender_match: 100%<br>
address_match: 100%<br>
<br>
confidence = (95 + 100 + 100 + 100) / 4 = 98.75% SAME PERSON<br><br>
<strong>Decision logic:</strong><br>
confidence > 95% => DEFINITE MATCH (auto-merge)<br>
confidence 80-95% => PROBABLE MATCH (ask case manager to confirm)<br>
confidence < 80% => DIFFERENT PEOPLE (create new record)<br><br>
<strong>MindBridge implementation:</strong><br>
from difflib import SequenceMatcher<br>
import Levenshtein<br><br>
def calculate_match_score(record1, record2):<br>
  score = 0<br>
  <br>
  # Name similarity (weight: 40%)<br>
  name_sim = Levenshtein.jaro_winkler(record1.name, record2.name)<br>
  score += name_sim * 0.40<br>
  <br>
  # DOB match (weight: 40%)<br>
  dob_match = 1.0 if record1.dob == record2.dob else 0.0<br>
  score += dob_match * 0.40<br>
  <br>
  # Gender (weight: 10%)<br>
  gender_match = 1.0 if record1.gender == record2.gender else 0.0<br>
  score += gender_match * 0.10<br>
  <br>
  # Zip code (weight: 10%)<br>
  zip_match = 1.0 if record1.zip == record2.zip else 0.0<br>
  score += zip_match * 0.10<br>
  <br>
  return score<br><br>
<strong>Workflow on patient import:</strong><br>
When a new patient is imported (from EHR or CSV):<br>
1. Calculate match_score against all existing patients<br>
2. If top match > 95%: Alert case manager "Possibly duplicate: This might be [John Smith, DOB 1985-03-15]"<br>
3. Case manager reviews and confirms merge<br>
4. If merged: Copy all screening history from old record to new<br><br>
<strong>Edge cases:</strong><br>
1. Married name change: "Jane Doe" marries and becomes "Jane Smith." How do you handle retroactive name changes?<br>
   Solution: Store both names in the database. Match on old + new names.<br>
<br>
2. Name order culturally different: "Yuki Tanaka" (Japanese: last name first) vs. "Tanaka Yuki" (Western order).<br>
   Solution: Allow flexible name field parsing per patient's cultural background.<br>
<br>
3. Multiple birth certificates: Patient has different records under slightly different names (uncommon but happens).<br>
   Solution: Patient can link multiple records to one identity manually.<br><br>
<strong>The industry standard: MPI (Master Patient Index)</strong><br>
Medical centers use MPI ‚Äî a centralized database of patient identities used as the source of truth. Every patient gets a MPI ID that all systems use. This solves matching once at the center.<br><br>
<strong>Interview gold:</strong> "Patient matching is probabilistic, not deterministic. Never merge records automatically based on name alone. Always ask a human to confirm. In healthcare, wrong matches can be lethal."`
  },

  // === SYSTEM DESIGN (3 NEW) ===

  realtime: {
    type: "interview",
    title: "Real-Time Dashboard Updates",
    question: "Design a feature where case managers see real-time updates when another user screens a patient ‚Äî without refreshing the page. How do you implement this?",
    context: "Real-time features are common interview questions. Show you understand WebSockets vs polling tradeoffs.",
    ideal: `<strong>The requirement:</strong><br>
Case Manager A screens Patient X, sets risk to HIGH. Instantly, Case Manager B's dashboard updates to show Patient X as HIGH risk ‚Äî without Case Manager B refreshing the page.<br><br>
<strong>THREE APPROACHES (with tradeoffs):</strong><br><br>
<strong>APPROACH 1 ‚Äî Regular Polling (Frontend asks every N seconds):</strong><br>
setInterval(async () => {<br>
  const patients = await fetch('/api/patients');<br>
  render_dashboard(patients);<br>
}, 5000);  // Check every 5 seconds<br><br>
Pros:<br>
‚Ä¢ Simple to implement<br>
‚Ä¢ No special infrastructure<br>
‚Ä¢ Works with any backend<br><br>
Cons:<br>
‚Ä¢ Latency: 5 seconds (user sees stale data for 5 seconds)<br>
‚Ä¢ Wasteful: Dashboard checks even if nothing changed<br>
‚Ä¢ Database load: 100 case managers √ó 1 query every 5s = 20 queries/second<br>
‚Ä¢ Bad UX: Lag of 5 seconds feels slow<br><br>
<strong>APPROACH 2 ‚Äî Server-Sent Events (SSE) (Server pushes updates one-direction):</strong><br>
const eventSource = new EventSource('/api/updates');<br>
eventSource.addEventListener('patient_screened', (event) => {<br>
  const update = JSON.parse(event.data);  // {patient_id, risk_level}<br>
  update_dashboard_ui(update);<br>
});<br><br>
Backend maintains a long-lived HTTP connection per client:<br>
@app.get("/api/updates")<br>
async def stream_updates(user_id: str):<br>
  async def event_generator():<br>
    while True:<br>
      update = await listen_for_updates(user_id)  # Long polling<br>
      yield f"data: {json.dumps(update)}\\n\\n"<br>
      await asyncio.sleep(0.1)<br>
  return StreamingResponse(event_generator(), media_type="text/event-stream")<br><br>
When screening is created, broadcast to all connected clients:<br>
async def create_screening(patient_id, risk_level):<br>
  # Save to database<br>
  await db.screenings.insert(...):<br>
  # Notify all connected dashboard users<br>
  broadcast({type: 'patient_screened', patient_id, risk_level})<br><br>
Pros:<br>
‚Ä¢ Low latency: Updates arrive within 100ms<br>
‚Ä¢ Efficient: Only sent when data changes<br>
‚Ä¢ Built on HTTP (no new protocols)<br><br>
Cons:<br>
‚Ä¢ Server connection per client (100 users = 100 open connections)<br>
‚Ä¢ Requires async backend (FastAPI supports it)<br><br>
<strong>APPROACH 3 ‚Äî WebSockets (Two-way, true real-time):</strong><br>
Frontend establishes persistent WebSocket connection:<br>
ws = new WebSocket("ws://localhost:8000/ws/updates");<br>
ws.onmessage = (event) => {<br>
  const update = JSON.parse(event.data);<br>
  update_dashboard_ui(update);<br>
};<br><br>
Backend:<br>
from fastapi import WebSocket<br>
@app.websocket("/ws/updates/{user_id}")<br>
async def websocket_endpoint(websocket: WebSocket, user_id: str):<br>
  await websocket.accept()<br>
  try:<br>
    while True:<br>
      # Listen for updates<br>
      update = await listen_for_updates(user_id)<br>
      await websocket.send_json(update)<br>
  except WebSocketDisconnect:<br>
    # Client disconnected, clean up<br>
    pass<br><br>
Pros:<br>
‚Ä¢ True real-time (updates within 50ms)<br>
‚Ä¢ Bidirectional (frontend can also send data without separate request)<br>
‚Ä¢ Efficient: Only sends deltas<br><br>
Cons:<br>
‚Ä¢ More complex infrastructure (WebSocket servers, load balancing)<br>
‚Ä¢ Requires WebSocket support on infrastructure (Railway, Render support it)<br><br>
<strong>MY RECOMMENDATION FOR MINDBRIGDE:</strong><br>
Start with SSE (Approach 2). Here's why:<br>
‚Ä¢ Simple to implement<br>
‚Ä¢ Real enough latency (100ms is imperceptibly fast)<br>
‚Ä¢ Less infrastructure than WebSockets<br>
‚Ä¢ Good enough for healthcare (not a live multiplayer game)<br><br>
Later, if you need <50ms latency (e.g., real-time collaboration on patient notes), move to WebSockets.<br><br>
<strong>Implementation detail ‚Äî broadcast mechanism:</strong><br>
You need a way to notify all connected clients. Use Redis pub/sub:<br><br>
import aioredis<br>
redis = await aioredis.create_redis_pool('redis://localhost')<br><br>
# When screening is created, publish event<br>
async def create_screening(patient_id, risk_level):<br>
  await db.screenings.insert(...)<br>
  await redis.publish('updates', json.dumps({<br>
    'type': 'patient_screened',<br>
    'patient_id': patient_id,<br>
    'risk_level': risk_level<br>
  }))<br><br>
# All connected SSE clients subscribe to this channel<br>
# When event published, all get notified<br><br>
<strong>Interview gold:</strong> "Real-time updates have tradeoffs: polling is simple, SSE is balanced, WebSockets are powerful. Choose based on latency requirements. For healthcare dashboards, SSE is usually the right choice."`
  },

  scaling: {
    type: "interview",
    title: "Scale to 100K Patients",
    question: "MindBridge currently serves 1 clinic with 500 patients. A large hospital network with 100,000 patients wants to onboard. What breaks and how do you fix it?",
    context: "Scaling challenges test systems thinking. Show you can identify bottlenecks before they become incidents.",
    ideal: `<strong>WHAT BREAKS AT 100K PATIENTS (200√ó growth):</strong><br><br>
<strong>1. DATABASE QUERIES SLOW DOWN</strong><br>
Current: SELECT * FROM patients takes 10ms<br>
At 100K: Same query takes 2 seconds (20√ó slower)<br>
Why: No indexes. By default, PostgreSQL scans the entire table.<br>
Fix:<br>
CREATE INDEX idx_patients_clinic ON patients(clinic_id);<br>
CREATE INDEX idx_patients_risk ON patients(risk_level);<br>
CREATE INDEX idx_Screenings_patient ON screenings(patient_id);<br><br>
Query now: 10ms again. Indexes let PostgreSQL skip to the right rows.<br><br>
<strong>2. CONNECTION POOL EXHAUSTED</strong><br>
Pool size: 10 (default)<br>
Current traffic: 10 requests/second. No problems.<br>
At 100K patients: Peak traffic hits 100 requests/second (101 case managers logging in at 9 AM).<br>
Result: 9 of 10 connections in use. Request 11 waits in queue. Then timeouts.<br><br>
Fix:<br>
Increase pool_size=50, max_overflow=50<br>
Now can handle 100 concurrent requests.<br>
Monitor connection usage to avoid surprises.<br><br>
<strong>3. SCREENING LATENCY EXPLODES</strong><br>
Current: Run 1 screening, Claude API takes 5 seconds ‚Üí User sees result in 5 seconds<br>
At 100K: Hospital wants to screen 10,000 NEW patients on Monday morning. 10,000 √ó 5 sec = 50,000 seconds = 14 hours. But they're all submitted at once (queue depth = 10K).<br><br>
Fix:<br>
Make screening async + queue:<br>
POST /api/screenings returns 202 Accepted immediately with task_id<br>
Background Celery worker processes queue of 10K jobs<br>
Case manager polls GET /screenings/task_id for status<br>
When ready: "Your screening is complete, risk level: HIGH"<br><br>
Now 10,000 patients are processed in background over 2 hours (5 concurrent workers), and the API returns instantly.<br><br>
<strong>4. STORAGE EXPLODES</strong><br>
Current: 500 patients √ó average 100KB per patient = 50MB<br>
At 100K: 10GB of data<br>
If you're using Railway or similar: May hit plan limits. Need larger database tier.<br><br>
Hospital records retention: Healthcare often requires 7 years of data retention.<br>
100K patients √ó 100KB √ó 7 years = 70GB<br><br>
Fix:<br>
Upgrade to production-grade database (not personal tier)<br>
Implement data archiving: Move old screenings to archive storage after 1 year (keep quick access for recent data)<br>
Consider separate analytics database for historical reporting<br><br>
<strong>5. AUDIT LOGGING BECOMES A BOTTLENECK</strong><br>
Every patient access = 1 audit log entry (HIPAA requirement)<br>
Current: 500 patients √ó 5 views/day = 2,500 logs/day (negligible)<br>
At 100K: 100K patients √ó 5 views/day = 500K logs/day<br>
500K inserts/day = ~6 inserts/second, not a problem YET<br><br>
At 1M patients: 5M logs/day = 58 inserts/second, OK but growing<br><br>
Fix (preemptive):<br>
Archive audit logs to separate table:<br>
CREATE TABLE audit_log_archive_2024_q1 PARTITION...<br>
Move completed months to archive (read-only)<br>
Keep current month in fast table<br>
Queries on audit_log_2024_q1 still work but don't scan massive log<br><br>
<strong>6. FRONTEND PERFORMANCE</strong><br>
Loading patient list: paginate<br>
Dashboard: Don't load all 100K rows. Load 50 at a time with infinite scroll.<br><br>
<strong>ARCHITECTURE CHANGES (Beyond just scaling):</strong><br><br>
<strong>A. Sharding (if you grow to 1M+ patients):</strong><br>
Instead of 1 database with 1M patients, have 100 databases with 10K each<br>
Route based on clinic_id or patient_id hash<br><br>
<strong>B. Read replicas:</strong><br>
Main database: Writes only<br>
2 read replicas: Dashboard queries (read-only) hit replicas<br>
Eliminates bottleneck of all queries hitting one database<br><br>
<strong>C. Microservices (if you grow to 10M+ patients):</strong><br>
Instead of 1 monolith (API + screening + audit + payment):<br>
- Screening service (isolated, scales independently)<br>
- Patient service (CRUD operations)<br>
- Audit service (logs, immutable)<br>
- each has its own database<br><br>
<strong>PERFORMANCE TARGETS AT SCALE:</strong><br>
Goal: API response < 500ms, even at peak<br>
1K concurrent users<br>
P99 latency < 2 seconds<br><br>
Achieved with:<br>
‚úì Database indexes<br>
‚úì Connection pooling<br>
‚úì Async screening pipeline<br>
‚úì Caching (Redis for reference data)<br>
‚úì CDN for static assets<br>
‚úì Rate limiting (prevent abuse)<br><br>
<strong>Interview gold:</strong> "Scaling isn't one change. It's a series of changes: indexes first, then async/queuing, then sharding. Measure constantly. Fix the actual bottleneck, not imaginary ones. Most startups over-engineer before they have scale problems."`
  },

  failover: {
    type: "interview",
    title: "Database Failover Strategy",
    question: "Your Railway PostgreSQL database crashes at 2 PM. Case managers can't access patient data. What's your disaster recovery plan?",
    context: "High availability is critical for healthcare. Show you've thought about failure modes and recovery procedures.",
    ideal: `<strong>THE DISASTER:</strong><br>
Railway's PostgreSQL server has a hardware failure at 2 PM on Tuesday. Your backend can't connect:<br>
OperationalError: could not translate host name "mindbridge-db.railway.app" to address<br><br>
Result: MindBridge is completely down. Case managers can't log in, can't access patients. If a HIGH-RISK patient tries to get help, the system is offline.<br><br>
This is unacceptable for healthcare. You need a failover strategy.<br><br>
<strong>STRATEGY 1 ‚Äî Automated Database Replication + Failover:</strong><br><br>
<strong>Setup:</strong><br>
Primary: mindbridge-db.railway.app (US-East)<br>
Standby: mindbridge-db-backup.railway.app (US-West)<br><br>
PostgreSQL replication: Primary streams all writes to Standby in real-time.<br>
Standby is read-only but fully synced. Every INSERT/UPDATE on primary appears on standby within milliseconds.<br><br>
<strong>When primary fails:</strong><br>
1. Health check: Backend tries to connect to primary. Fails 3 times.<br>
2. Automatic failover: Standby is promoted to primary (now accepts writes)<br>
3. Application switches: Update application config: DATABASEUR = "mindbridge-db-backup.railway.app"<br>
4. Resume operations: Case managers reconnect (maybe 10-second interruption)<br><br>
Tools that automate this:<br>
‚Ä¢ Patroni (manages failover automatically)<br>
‚Ä¢ PgBouncer (connection pooling with failover built-in)<br>
‚Ä¢ Cloud provider's managed failover (Railway, Render, Digital Ocean provide this)<br><br>
<strong>STRATEGY 2 ‚Äî Active-Active (No downtime, more complex):</strong><br><br>
Two PostgreSQL clusters, both accepting writes. Bidirectional replication.<br>
If primary fails: DOMIcan already writing to secondary. Zero downtime.<br><br>
Challenges: handling write conflicts (if both clusters receive the same INSERT simultaneously). Complex.<br><br>
<strong>STRATEGY 3 ‚Äî Backup & Restore (slower recovery):</strong><br><br>
Take hourly backups of PostgreSQL to cloud storage (S3, Google Cloud Storage):<br>
11 AM: Full backup (complete database snapshot)<br>
2 PM: Database fails<br>
2:05 PM: Database is restored from 11 AM snapshot<br>
2:15 PM: Service restored (15-minute downtime)<br><br>
Application data loss: 1 hour (1 PM-2 PM screzenings lost)<br><br>
Better than nothing, but worse than replication.<br><br>
<strong>MY RECOMMENDATION ‚Äî Failover with Patroni (Middle ground):</strong><br><br>
Using Patroni + PostgreSQL managed service on Railway/Render:<br><br>
<strong>Backup strategy (RPO = Recovery Point Objective):</strong><br>
- RPO: How much data can you afford to lose? Healthcare: <5 minutes<br>
- Replication stream (synchronous): Primary waits for standby to confirm write before ACKing to app<br>
- Result: Zero data loss from primary failure<br><br>
<strong>Recovery time (RTO = Recovery Time Objective):</strong><br>
- RTO: How long can you afford to be down? Healthcare: <10 minutes<br>
- Automatic failover: Standby promoted within 1 minute<br>
- Application reconnection: Connections reset, app reconnects within 2 minutes<br>
- Result: ~3 minutes downtime<br><br>
<strong>Implementation:</strong><br>
PostgreSQL Primary (sync replication) ‚Üí PostgreSQL Standby<br>
<br>
Connection string with automatic failover:<br>
postgresql://user:pass@primary,backup/mindbridge?sslmode=require&target_session_attrs=read-write<br><br>
This connection string tries primary first. If it fails, automatically connects to backup.<br><br>
<strong>Verification & drills:</strong><br>
Every quarter, simulate: Kill the primary database server. Confirm:<br>
1. Standby was promoted (monitoring shows "now primary")<br>
2. Application reconnected automatically<br>
3. Case managers could access their data<br>
4. No data loss since last transaction<br><br>
Document exact steps taken + time to recovery. If it took 15 minutes manually, work on automation.<br><br>
<strong>Bonus ‚Äî Async Standby Replication for Different Regions:</strong><br><br>
If you want geographic redundancy (survive full region outage):<br><br>
Primary: US-East (Railway)<br>
Standby Sync: US-East (same region, fast failover)<br>
Standby Async: EU-West (different region, slower)<br><br>
US-East fails: Standby Sync takes over (fast)<br>
US-East + EU both fail: Business is over anyway (unlikely)<br><br>
You generally don't use EU-West for normal failover (latency), but it's there as insurance.<br><br>
<strong>Monitoring & Alerting:</strong><br>
Continuous health check:<br>
SELECT 1;  # Simple connectivity test, every 10 seconds<br><br>
If 3 failed attempts ‚Üí Alert ops immediately<br>
If 10 failed attempts ‚Üí Trigger automatic failover<br><br>
Alert channels: Email + Slack + Page on-call engineer<br><br>
<strong>Interview gold:</strong> "Healthcare systems can't be down. Plan for failure before it happens. Replication + automatic failover means case managers never notice a database failure. RPO < 5 min, RTO < 10 min. Drill it quarterly so you're confident it actually works."`
  },

  frontend_arch: {
    type: "interview",
    title: "Walk Through MindBridge Frontend Architecture",
    question: "Walk me through the MindBridge frontend architecture. How is it structured, what decisions did you make, and why?",
    context: "This is your home turf. You built it. Nobody knows it better than you. Use the STAR framework: Structure ‚Üí Approach ‚Üí Result.",
    ideal: `<strong>STRUCTURE:</strong> "MindBridge uses Next.js 14 with the App Router for the frontend, deployed on Vercel. Three pages: Login (app/page.tsx), Dashboard (app/dashboard/page.tsx), and Patient Detail (app/patients/[id]/page.tsx)."<br><br>
<strong>ARCHITECTURE DECISIONS:</strong><br>
"I used dynamic routing with bracket notation for the patient detail view ‚Äî [id] matches any patient UUID from the database. This is Next.js App Router file-based routing: every folder inside /app becomes a URL segment, every page.tsx becomes a page."<br><br>
"The login page is a Client Component using 'use client' and useRouter for post-submit redirect. The dashboard and patient detail are Server Components since they just display data ‚Äî keeping them server-side means faster loads and better SEO."<br><br>
"Styling is Tailwind CSS throughout ‚Äî utility classes gave me a consistent design system without a dedicated designer. The constraint of predefined values (slate-900, blue-600) actually produces more consistent results than freeform CSS."<br><br>
<strong>HIPAA DESIGN CHOICE:</strong><br>
"I added a demo environment banner to make clear all patient data is fictional. In production, I'd add NextAuth.js middleware that blocks /dashboard and /patients/* without a valid session ‚Äî unauthenticated users redirect to login automatically."<br><br>
<strong>RESULT:</strong><br>
"The frontend is live at mind-bridge-health-ai.vercel.app. Every git push to main auto-deploys via Vercel's CI/CD pipeline in under 60 seconds. Employers can click the live demo link right now."<br><br>
<strong>WHY THIS ANSWER WORKS:</strong> Shows architecture thinking, explains tradeoffs, mentions HIPAA awareness, ends with live evidence.`
  },

  nextjs_vs_react: {
    type: "interview",
    title: "Why Next.js Over Plain React?",
    question: "Why did you choose Next.js for MindBridge instead of plain React with Vite or Create React App?",
    context: "Show you understand the tradeoffs. This isn't about memorizing features ‚Äî it's about making deliberate decisions.",
    ideal: `<strong>Three reasons Next.js was the right choice for MindBridge:</strong><br><br>
<strong>1. Server-Side Rendering for Healthcare:</strong><br>
Patient dashboards need to load fast. Server Components render on the server and send HTML to the browser ‚Äî no waiting for JavaScript to load before seeing data. For a clinician checking a patient before an appointment, every second matters. Plain React would send an empty HTML shell, then load JS, then fetch data, then render ‚Äî three round trips. Next.js does it in one.<br><br>
<strong>2. File-Based Routing (Zero Config):</strong><br>
With plain React + React Router, I'd write routing configuration manually. With Next.js, creating app/patients/[id]/page.tsx automatically creates the /patients/:id route. For a solo developer moving fast, that's hours saved per week.<br><br>
<strong>3. Vercel Integration:</strong><br>
Next.js is made by the same team as Vercel. Zero-config deployment, automatic CI/CD, edge network ‚Äî push to GitHub, live in 60 seconds. With plain React on a custom server, that's a week of DevOps work.<br><br>
<strong>When plain React would be better:</strong><br>
If MindBridge were a highly interactive app (think Google Docs, real-time collaboration), where SEO doesn't matter and all rendering is client-side anyway, plain React + Vite would be faster to build and lighter to run.<br><br>
<strong>Interview gold:</strong> "I chose Next.js not because it's popular, but because the specific requirements ‚Äî fast loads for clinical workflows, quick deployment, file-based routing for a small team ‚Äî made it the right tool."`
  },

  add_auth: {
    type: "interview",
    title: "Add Authentication to Protect the Dashboard",
    question: "The MindBridge dashboard is currently publicly accessible. How would you add proper authentication to protect patient data?",
    context: "This tests both technical implementation knowledge AND HIPAA awareness. Show you think about security as architecture, not afterthought.",
    ideal: `<strong>CURRENT STATE:</strong> Any URL like /dashboard is accessible without logging in. Fine for portfolio demo with fake data, unacceptable for production with real PHI.<br><br>
<strong>IMPLEMENTATION PLAN ‚Äî NextAuth.js:</strong><br><br>
<strong>Step 1 ‚Äî Install:</strong> npm install next-auth<br><br>
<strong>Step 2 ‚Äî Create auth handler:</strong><br>
File: app/api/auth/[...nextauth]/route.ts<br>
This single file handles all auth routes automatically: /api/auth/signin, /api/auth/callback, /api/auth/session.<br><br>
Configure CredentialsProvider to validate against FastAPI backend:<br>
CredentialsProvider({ async authorize(credentials) {<br>
  const res = await fetch('https://api.mindbridge.railway.app/auth/verify', { method: 'POST', body: JSON.stringify(credentials) });<br>
  if (res.ok) return await res.json();<br>
  return null;<br>
}})<br><br>
<strong>Step 3 ‚Äî Add middleware (the key piece):</strong><br>
File: middleware.ts at project root<br>
export { default } from 'next-auth/middleware';<br>
export const config = { matcher: ['/dashboard/:path*', '/patients/:path*'] };<br><br>
This runs before EVERY request to /dashboard or /patients. Unauthenticated users are redirected to /login automatically. No code changes needed in the page components.<br><br>
<strong>Step 4 ‚Äî Access session in components:</strong><br>
const session = await getServerSession(); // Server-side, no API call<br>
if (!session) redirect('/'); // Belt and suspenders<br><br>
<strong>HIPAA-SPECIFIC ADDITIONS:</strong><br>
- JWT tokens expire after 8 hours (one clinical shift)<br>
- Failed login attempts logged to audit_log<br>
- Session invalidated on logout (can't reuse old tokens)<br>
- MFA required for admin roles<br><br>
<strong>Interview gold:</strong> "Authentication in healthcare isn't just username/password. It's session expiry aligned with shift lengths, MFA for privileged roles, and audit logging of every login and logout. That's what distinguishes a HIPAA-compliant system from a generic web app."`
  },

  vercel_build_fail: {
    type: "simulation",
    title: "Vercel Build Fails on Deploy",
    question: "You push to GitHub and Vercel's deployment fails with: 'Error: Build failed. Exit code 1'. The site reverts to the previous version. How do you debug it?",
    context: "This is a real scenario you'll face. Show systematic debugging, not panic.",
    ideal: `<strong>STEP 1 ‚Äî Read the build logs (always start here):</strong><br>
Go to Vercel Dashboard ‚Üí Deployments ‚Üí click the failed deployment ‚Üí View Build Logs.<br>
Scroll to the RED error. It will tell you exactly what failed.<br>
Don't guess ‚Äî read the error.<br><br>
<strong>COMMON NEXT.JS BUILD FAILURES:</strong><br><br>
<strong>TypeScript error:</strong><br>
"Type 'string' is not assignable to type 'number'"<br>
Fix: Your type definition doesn't match what you're passing. Find the line number in the error, fix the type.<br><br>
<strong>Missing module:</strong><br>
"Cannot find module 'some-package'"<br>
Fix: Package installed locally but not in package.json. Run: npm install some-package, commit package.json and package-lock.json.<br><br>
<strong>Next.js 15 async params (you've already seen this one):</strong><br>
"Error: params.id is undefined"<br>
Fix: Add async + await params as Promise. The exact bug you fixed today.<br><br>
<strong>Environment variable missing:</strong><br>
"process.env.NEXT_PUBLIC_API_URL is undefined"<br>
Fix: Variable exists in .env.local but wasn't added to Vercel's environment variables dashboard.<br>
Go to: Vercel ‚Üí Project ‚Üí Settings ‚Üí Environment Variables ‚Üí Add it.<br><br>
<strong>STEP 2 ‚Äî Reproduce locally:</strong><br>
npm run build<br>
If it fails locally, you can fix it faster. If it passes locally but fails on Vercel, it's an environment variable or dependency issue.<br><br>
<strong>STEP 3 ‚Äî Fix and push:</strong><br>
Once fixed locally, push to GitHub. Vercel auto-triggers a new build. Previous version stays live until new build succeeds.<br><br>
<strong>The safety net:</strong><br>
Vercel NEVER takes down your live site for a failed build. Previous deployment stays live. Case managers continue working while you fix the error. That's why CI/CD is safe for production.`
  },

  nextjs_404: {
    type: "simulation",
    title: "Dynamic Route Returns 404",
    question: "You create app/patients/id/page.tsx and navigate to /patients/1 ‚Äî you get a 404. What's wrong and how do you fix it?",
    context: "This is the exact bug you hit today. Own it ‚Äî you know the answer cold.",
    ideal: `<strong>THE CAUSE:</strong><br>
The folder is named 'id' (no brackets) instead of '[id]' (with brackets).<br><br>
In Next.js App Router, square brackets are REQUIRED for dynamic segments:<br>
app/patients/id/page.tsx ‚Üí matches ONLY the literal URL /patients/id (not useful)<br>
app/patients/[id]/page.tsx ‚Üí matches /patients/1, /patients/2, /patients/any-uuid<br><br>
<strong>THE FIX:</strong><br>
Rename the folder from 'id' to '[id]' ‚Äî brackets included.<br>
On Windows: Right-click ‚Üí Rename ‚Üí type [id]<br>
Or in terminal: mv app/patients/id app/patients/[id]<br><br>
<strong>SECOND ISSUE ‚Äî Next.js 15 async params:</strong><br>
Even with the correct folder name, Next.js 15 requires params to be awaited:<br><br>
WRONG (Next.js 14 style):<br>
export default function Page({ params }: { params: { id: string } }) {<br>
  const patient = data[params.id]; // params.id is undefined in Next.js 15<br>
}<br><br>
CORRECT (Next.js 15 style):<br>
export default async function Page({ params }: { params: Promise<{ id: string }> }) {<br>
  const { id } = await params; // Must await the Promise<br>
  const patient = data[id];<br>
}<br><br>
<strong>How to remember:</strong><br>
Next.js 15 made params async to support streaming and server components better. If you see 404 on dynamic routes, check: (1) brackets in folder name, (2) async/await on params.<br><br>
<strong>Interview gold:</strong> "I hit this exact bug in production on Day 1 of my frontend build. Fixed it in 2 minutes once I understood the pattern. Now I always check folder names and Next.js version when dynamic routes return 404."`,
  },

  server_client: {
    type: "concept",
    title: "Server vs Client Components in Next.js",
    question: "Explain the difference between Server Components and Client Components in Next.js. When does MindBridge use each?",
    context: "This is one of the most common Next.js interview questions. Show you understand the WHY, not just the syntax.",
    ideal: `<strong>SERVER COMPONENTS (default in Next.js App Router):</strong><br>
Render on the server. HTML is sent to the browser. JavaScript is NOT sent to the browser for server components.<br><br>
Characteristics:<br>
- Can access databases, file system, secrets directly<br>
- Cannot use useState, useEffect, onClick, onChange<br>
- Cannot use browser APIs (window, document, localStorage)<br>
- Faster: Less JavaScript shipped to browser<br>
- Better SEO: Content is in the HTML, search engines can read it<br><br>
<strong>CLIENT COMPONENTS ('use client' at top of file):</strong><br>
Render in the browser. Full React interactivity available.<br><br>
Characteristics:<br>
- CAN use useState, useEffect, onClick, useRouter<br>
- CAN use browser APIs<br>
- Cannot access server-only resources directly (database, secrets)<br>
- More JavaScript shipped to browser<br><br>
<strong>MindBridge examples:</strong><br><br>
Login page = CLIENT COMPONENT because:<br>
'use client'<br>
import { useRouter } from 'next/navigation';<br>
// Needs useRouter for redirect after form submit<br>
// Needs onClick for the Sign In button<br><br>
Dashboard = SERVER COMPONENT because:<br>
// Just displays data ‚Äî no interactivity needed<br>
// Could fetch from database directly (skipping API layer)<br>
// Faster, no JS overhead<br><br>
Patient Detail = SERVER COMPONENT because:<br>
// Just renders patient data<br>
// async function with await params<br>
// No user interactions needed<br><br>
<strong>Rule of thumb:</strong><br>
Start with Server Component (default). Add 'use client' only when you need: onClick, onChange, useState, useEffect, useRouter, or any browser API.<br><br>
<strong>Interview gold:</strong> "I default to Server Components for performance. Each Client Component adds JavaScript to the browser bundle. In a healthcare app where clinicians may be on older hospital computers, minimizing JavaScript = better performance = faster patient care."`
  },

  cicd_concept: {
    type: "concept",
    title: "CI/CD Pipeline in MindBridge",
    question: "Explain CI/CD and walk me through exactly how MindBridge's pipeline works from git push to live deployment.",
    context: "CI/CD is a must-know for any engineering role. Show you've lived it, not just read about it.",
    ideal: `<strong>What CI/CD means:</strong><br>
CI (Continuous Integration): Every code push automatically builds and tests the code.<br>
CD (Continuous Deployment): If the build passes, automatically deploy to production.<br><br>
The goal: Remove manual steps from deployment. No more "can you deploy this for me?" ‚Äî push to main, it's live.<br><br>
<strong>MindBridge's exact CI/CD pipeline:</strong><br><br>
<strong>STEP 1 ‚Äî Developer pushes code:</strong><br>
git add . && git commit -m "Add demo banner" && git push origin main<br>
Git push takes ~2 seconds.<br><br>
<strong>STEP 2 ‚Äî GitHub receives the push:</strong><br>
GitHub stores the new commit. Triggers a webhook notification to Vercel: "New code pushed to fidelis-emmanuel/MindBridge-Health-AI main branch."<br><br>
<strong>STEP 3 ‚Äî Vercel starts build:</strong><br>
Vercel clones the repository. Navigates to Root Directory: frontend/patient-portal. Runs: npm install (installs dependencies). Runs: npm run build (compiles Next.js for production). Checks for TypeScript errors, missing modules, any build failures.<br><br>
<strong>STEP 4a ‚Äî Build succeeds:</strong><br>
Vercel deploys compiled files to its global edge network (100+ locations worldwide). Updates the production URL (mind-bridge-health-ai.vercel.app) to serve new version. Total time: ~60 seconds from git push to live.<br><br>
<strong>STEP 4b ‚Äî Build fails:</strong><br>
Vercel keeps the PREVIOUS version live. No downtime. Developer receives email: "Build failed." Developer reads logs, fixes the error, pushes again.<br><br>
<strong>Why this matters for healthcare:</strong><br>
"Deploying broken code to a healthcare system could prevent case managers from accessing patient data or show incorrect risk levels. CI/CD means broken code NEVER reaches production ‚Äî the pipeline is the safety net."<br><br>
<strong>What we'd add in production:</strong><br>
Automated tests run in CI before deployment: npm test. If tests fail, build fails, code doesn't deploy. This catches regressions before real users see them.<br><br>
<strong>Interview gold:</strong> "CI/CD isn't just convenience ‚Äî it's patient safety. If a deployment breaks MindBridge's risk assessment display, case managers might miss a HIGH-risk patient. The pipeline prevents that."`
  },

  mindbridge_e2e: {
    type: "concept",
    title: "MindBridge End-to-End System Walkthrough",
    question: "Walk me through the complete MindBridge Health AI system ‚Äî from the moment a case manager opens the browser to the moment they see a patient's risk score. Every layer.",
    context: "This is your home turf question. You built every layer of this. An interviewer asking this is giving you 5 minutes of free talking time. Use it.",
    ideal: `<strong>THE FULL STACK JOURNEY:</strong><br><br>
<strong>LAYER 1 ‚Äî Browser (Next.js Frontend on Vercel):</strong><br>
Case manager navigates to mind-bridge-health-ai.vercel.app. Vercel's edge network (100+ locations globally) serves the Next.js app from the nearest server. Login page renders ‚Äî Server Component sends HTML directly, no JS loading needed.<br><br>
<strong>LAYER 2 ‚Äî Authentication:</strong><br>
Case manager enters credentials. 'use client' login component triggers useRouter. POST /api/auth/verify sent to FastAPI backend. FastAPI checks email against PostgreSQL users table, bcrypt.verify() checks password hash (plain passwords never stored). JWT token issued, stored in httpOnly cookie (XSS-proof). Case manager is now authenticated.<br><br>
<strong>LAYER 3 ‚Äî Dashboard Load:</strong><br>
Dashboard page (Server Component) loads. GET /api/patients sent to FastAPI with Bearer JWT token. FastAPI middleware validates JWT, extracts clinic_id. PostgreSQL Row-Level Security + WHERE clinic_id = user.clinic_id ‚Äî case manager sees ONLY their clinic's patients. Response: 10 patients with risk levels, diagnoses, last assessment dates.<br><br>
<strong>LAYER 4 ‚Äî Risk Screening:</strong><br>
Case manager clicks "Screen Patient" for Marcus Thompson. POST /api/screenings sent to FastAPI. FastAPI validates JWT (authenticated) and role (has 'analyst' permission). Patient data fetched from PostgreSQL. Structured prompt sent to Claude API: medication_adherence, appointments_missed, crisis_calls_30days, diagnosis. Claude returns: risk_level=HIGH, primary_factor="Medication non-adherence", action="Immediate outreach". ACID transaction writes: screening result + patient risk update + audit log entry ‚Äî all three succeed or none do.<br><br>
<strong>LAYER 5 ‚Äî HIPAA Compliance (runs on every request):</strong><br>
Every API call logs to immutable audit_log: user_id, patient_id, action, timestamp, IP. Encryption at rest (AES-256 PostgreSQL volumes) and in transit (TLS 1.3). JWT expires after 8 hours ‚Äî aligns with clinical shift length.<br><br>
<strong>LAYER 6 ‚Äî Report Generation:</strong><br>
Case manager clicks "Generate Report." Python-docx creates Word document. openpyxl creates Excel spreadsheet. ReportLab creates PDF. All three formats generated from same data. Reports saved to /reports folder (excluded from git by .gitignore ‚Äî HIPAA compliance).<br><br>
<strong>THE TECH STACK SUMMARY:</strong><br>
Frontend: Next.js 14 (Vercel) ‚Üí FastAPI backend (Railway) ‚Üí PostgreSQL 17 (Railway) ‚Üí Claude AI (Anthropic) ‚Üí Multi-format reports<br><br>
<strong>Interview gold:</strong> "I built every layer of this system, from database schema to frontend components. The domain expertise from 10 years in behavioral health shaped every architectural decision ‚Äî the alert thresholds, the HIPAA audit patterns, the report formats. That's not something you get from a computer science degree."`
  },

  econnrefused: {
    type: "simulation",
    title: "Debug ECONNREFUSED Error",
    question: "Your Next.js API route returns: 'AggregateError: ECONNREFUSED'. The database credentials look correct. Walk me through your debugging process step by step.",
    context: "This is a real error you encountered today. Own it ‚Äî you know exactly what caused it and how to fix it.",
    ideal: `<strong>ECONNREFUSED means:</strong><br>
The connection was actively refused by the target server. Your code reached the right address but nothing answered. Not a credentials problem ‚Äî a networking problem.<br><br>
<strong>STEP 1 ‚Äî Check the URL format:</strong><br>
Print the first 30 characters of the database URL:<br>
console.log("DB URL prefix:", process.env.DATABASE_URL?.substring(0, 30));<br><br>
This reveals if the URL is even being read, and what host it's pointing to.<br><br>
<strong>STEP 2 ‚Äî Identify internal vs public URL:</strong><br>
Two types of Railway database URLs:<br>
- Internal: postgres.railway.internal:5432 ‚Äî ONLY works inside Railway's network<br>
- Public: switchback.proxy.rlwy.net:56330 ‚Äî works from anywhere<br><br>
If you're running locally or on Vercel, you MUST use the public URL. The internal URL is for Railway service-to-service communication only.<br><br>
<strong>STEP 3 ‚Äî Check .env.local location:</strong><br>
Next.js only reads .env.local from the project root ‚Äî the same folder as package.json.<br>
If .env.local is in the wrong directory (e.g., the repo root instead of frontend/patient-portal), Next.js never reads it. The environment variable is undefined. The connection fails.<br><br>
<strong>STEP 4 ‚Äî Restart the dev server:</strong><br>
Next.js reads .env.local ONLY on startup. If you change the file while the server is running, the old value is still in memory.<br>
Fix: Ctrl+C ‚Üí npm run dev ‚Äî always restart after changing .env.local.<br><br>
<strong>STEP 5 ‚Äî Verify SSL config:</strong><br>
Railway requires SSL. Add to Pool config:<br>
ssl: { rejectUnauthorized: false }<br><br>
Without this, Railway rejects the connection even with correct credentials.<br><br>
<strong>Root causes in order of likelihood:</strong><br>
1. Wrong URL (internal vs public) ‚Äî most common<br>
2. .env.local in wrong directory<br>
3. Dev server not restarted after .env.local change<br>
4. Missing SSL config<br><br>
<strong>Interview gold:</strong> "ECONNREFUSED is a network error, not a credentials error. The first question is always: can this machine reach that host? Internal Railway URLs are invisible from outside Railway's network ‚Äî that's by design for security."`
  },

  gitguardian: {
    type: "simulation",
    title: "GitGuardian: Exposed Credentials Alert",
    question: "You receive an email from GitGuardian: 'PostgreSQL URI exposed in your GitHub repository fidelis-emmanuel/MindBridge-Health-AI'. The repo was made public yesterday. What do you do in the next 30 minutes?",
    context: "This happened to you today. You handled it correctly. Now explain it as if teaching a junior developer.",
    ideal: `<strong>STEP 1 ‚Äî Assess severity immediately (2 minutes):</strong><br>
How long was the repo public? The shorter the window, the lower the risk.<br>
What was exposed? PostgreSQL connection string = full database access including all patient data.<br>
Is the database in production with real patient data? If yes, treat as critical breach.<br><br>
<strong>STEP 2 ‚Äî Rotate the credential immediately (5 minutes):</strong><br>
Go to Railway ‚Üí Postgres ‚Üí Database tab ‚Üí Config ‚Üí Regenerate Password.<br>
This invalidates the exposed password instantly ‚Äî even if someone already copied it, it no longer works.<br>
Do this BEFORE anything else. Rotation is the fastest way to close the security window.<br><br>
<strong>STEP 3 ‚Äî Remove from code (10 minutes):</strong><br>
Find every file with the hardcoded URL:<br>
git grep -r "postgresql://" ec9c774<br><br>
Replace hardcoded URL with environment variable:<br>
# REMOVE:<br>
DATABASE_PUBLIC_URL = "postgresql://postgres:PASSWORD@host:port/railway"<br>
# REPLACE WITH:<br>
import os<br>
DATABASE_PUBLIC_URL = os.environ.get("DATABASE_PUBLIC_URL")<br><br>
Commit and push immediately:<br>
git commit -m "Security: Remove hardcoded database credentials"<br>
git push<br><br>
<strong>STEP 4 ‚Äî Clean git history (15 minutes):</strong><br>
The credential is now gone from current code but still visible in old commits. Anyone can run git log and find it.<br>
pip install git-filter-repo<br>
git filter-repo --path scripts/generate_railway_report.py --invert-paths<br>
git push origin main --force<br><br>
Force push rewrites history. The old commits with credentials are permanently removed from GitHub.<br><br>
<strong>STEP 5 ‚Äî Verify (5 minutes):</strong><br>
Try connecting with the OLD password. Should fail with authentication error.<br>
Check GitHub ‚Äî search the repo for the old password string. Should return zero results.<br><br>
<strong>HIPAA implications:</strong><br>
If this were a production database with real patient PHI:<br>
- Document the incident: what was exposed, when, for how long<br>
- Assess if PHI was accessed (check database access logs)<br>
- If PHI was accessed by unauthorized party: 72-hour breach notification rule applies<br>
- Notify patients and HHS within 72 hours<br><br>
<strong>Prevention going forward:</strong><br>
- Never hardcode credentials ‚Äî always os.environ.get()<br>
- Add .env* to .gitignore before first commit<br>
- Use git-secrets or similar pre-commit hooks to block credential commits<br>
- Review .gitignore before making any repo public<br><br>
<strong>Interview gold:</strong> "I handled a real credential exposure during my MindBridge project. Detected by GitGuardian, rotated within 5 minutes, removed from code, cleaned git history with git-filter-repo. Total resolution: under 30 minutes. The key is rotating first ‚Äî that closes the security window while you fix the code."`
  },

  fullstack_connect: {
    type: "interview",
    title: "Walk Through Connecting Frontend to Database",
    question: "Walk me through how you connected the MindBridge Next.js frontend to the Railway PostgreSQL database. What decisions did you make and why?",
    context: "This is a Day 12 achievement. You built the full connection today. Own every architectural decision.",
    ideal: `<strong>THE ARCHITECTURE DECISION:</strong><br>
Two options to connect Next.js to PostgreSQL:<br>
Option A: Next.js ‚Üí FastAPI backend ‚Üí PostgreSQL (traditional full-stack)<br>
Option B: Next.js Server Component ‚Üí PostgreSQL directly (simpler for portfolio)<br><br>
I chose Option B because FastAPI wasn't deployed on Railway yet ‚Äî only the database was. Server Components can securely query PostgreSQL directly because they run on the server, never in the browser. No credentials are exposed to the client.<br><br>
<strong>STEP 1 ‚Äî Install PostgreSQL client:</strong><br>
npm install pg && npm install --save-dev @types/pg<br>
The pg package gives Next.js the ability to speak PostgreSQL protocol directly.<br><br>
<strong>STEP 2 ‚Äî Create the API route:</strong><br>
app/api/patients/route.ts ‚Äî a Next.js API route that queries Railway and returns JSON.<br>
Used Pool with ssl: { rejectUnauthorized: false } for Railway's SSL requirement.<br><br>
<strong>STEP 3 ‚Äî Environment variables (the HIPAA lesson):</strong><br>
Created .env.local in the patient-portal directory (not the repo root ‚Äî that was the first bug).<br>
Added DATABASE_URL with the Railway PUBLIC URL (not the internal URL ‚Äî that was the second bug).<br>
Restarted the dev server after changing .env.local ‚Äî Next.js only reads it on startup.<br><br>
<strong>STEP 4 ‚Äî Move to Server Component:</strong><br>
The API route used localhost:3000 which doesn't exist on Vercel. Fixed by querying PostgreSQL directly in the Server Component ‚Äî no fetch call needed. Server Components run on the server, so they connect directly to the database.<br><br>
<strong>STEP 5 ‚Äî Deploy to Vercel:</strong><br>
Added DATABASE_URL to Vercel's Environment Variables dashboard. Redeployed. Live dashboard now shows real Railway patients.<br><br>
<strong>Result:</strong><br>
mind-bridge-health-ai.vercel.app/dashboard pulls live patient data from Railway PostgreSQL. The full stack is connected: Browser ‚Üí Vercel ‚Üí Next.js Server Component ‚Üí Railway PostgreSQL.<br><br>
<strong>Interview gold:</strong> "The decision to query PostgreSQL directly in Server Components is only safe because Server Components never run in the browser. The DATABASE_URL secret never leaves the server. That's the security model ‚Äî and it's why defaulting to Server Components is the right architectural choice."`
  },

  env_vars: {
    type: "concept",
    title: "Environment Variables ‚Äî Local vs Production",
    question: "Explain the difference between .env.local, environment variables in Vercel, and hardcoded credentials. Why does each exist and when do you use each?",
    context: "You learned this the hard way today. Security and deployment concepts combined.",
    ideal: `<strong>THE SPECTRUM (least to most secure):</strong><br><br>
<strong>WORST ‚Äî Hardcoded in source code:</strong><br>
DATABASE_URL = "postgresql://postgres:PASSWORD@host/db"<br><br>
Problem: Committed to git. If repo is ever public (accidentally or intentionally), credentials are exposed. GitGuardian detected this in MindBridge within 24 hours of the repo going public.<br>
Never do this for any real credentials.<br><br>
<strong>GOOD ‚Äî .env.local (local development only):</strong><br>
File named .env.local in your project directory.<br>
Add .env* to .gitignore ‚Äî file is never committed to git.<br>
Next.js reads it automatically on startup (not hot-reloaded ‚Äî must restart server).<br>
Access in code: process.env.DATABASE_URL<br><br>
Rules:<br>
- Must be in the same directory as package.json<br>
- Never commit it<br>
- Only works locally ‚Äî Vercel cannot read your local files<br>
- Restart dev server after every change<br><br>
<strong>PRODUCTION ‚Äî Environment variables in Vercel dashboard:</strong><br>
Go to Vercel ‚Üí Project ‚Üí Settings ‚Üí Environment Variables.<br>
Add DATABASE_URL with the real value.<br>
Vercel bakes this into the build at deploy time.<br>
Access in code: same ‚Äî process.env.DATABASE_URL<br><br>
Key insight: The code is identical whether running locally or on Vercel. The ENVIRONMENT provides the right value in each context. That's the entire point of environment variables.<br><br>
<strong>NEXT_PUBLIC_ prefix (special case):</strong><br>
Variables without NEXT_PUBLIC_ are server-only ‚Äî never sent to the browser.<br>
Variables WITH NEXT_PUBLIC_ are included in the browser bundle ‚Äî visible to anyone.<br>
DATABASE_URL = server only (correct ‚Äî never expose database credentials to browser)<br>
NEXT_PUBLIC_API_URL = browser-safe (public API URLs are fine)<br><br>
<strong>The .env.local location bug (Day 12 lesson):</strong><br>
Repo root: E:\\MindBridge Health Care\\.env.local ‚Üê Next.js CANNOT see this<br>
Project root: E:\\MindBridge Health Care\\frontend\\patient-portal\\.env.local ‚Üê Next.js reads this<br><br>
Next.js looks for .env.local relative to the directory where package.json lives. Always put it there.<br><br>
<strong>Interview gold:</strong> "Environment variables solve two problems: security (credentials not in code) and flexibility (different values in dev vs production without changing code). The pattern is always the same: os.environ.get() in Python, process.env.VARIABLE in Next.js. The deployment platform provides the actual values."`
  }
};


let sessionCompleted = 0;
let sessionRatings = [];
let currentScenarioKey = null;
const scenarioOrder = Object.keys(scenarios);

function loadScenario(key) {
  currentScenarioKey = key;
  const s = scenarios[key];
  if (!s) return;

  // Hide welcome, show content
  document.getElementById('welcome').style.display = 'none';
  const content = document.getElementById('scenario-content');
  content.style.display = 'flex';

  // Update active button
  document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById('btn-' + key);
  if (btn) btn.classList.add('active');

  // Set type badge
  const badge = document.getElementById('scenario-type-badge');
  const typeMap = {
    simulation: ['type-sim', 'üé≠ Simulation'],
    interview: ['type-int', 'üé§ Interview'],
    concept: ['type-con', 'üí° Concept']
  };
  const [cls, label] = typeMap[s.type] || ['type-con', 'üí° Concept'];
  badge.className = 'scenario-type ' + cls;
  badge.textContent = label;

  // Set question
  document.getElementById('scenario-question').textContent = s.question;

  // Set context
  const ctx = document.getElementById('scenario-context');
  if (s.context) {
    ctx.textContent = s.context;
    ctx.style.display = 'block';
  } else {
    ctx.style.display = 'none';
  }

  // Reset answer area
  document.getElementById('user-answer').value = '';
  document.getElementById('ideal-answer').classList.remove('show');
  document.getElementById('rating-section').classList.remove('show');
  document.getElementById('feedback-panel').classList.remove('show');
  document.getElementById('reveal-btn').style.display = 'inline-block';
  document.getElementById('loading-indicator').classList.remove('show');

  // Scroll to top
  document.getElementById('stage').scrollTop = 0;
}

function revealAnswer() {
  const s = scenarios[currentScenarioKey];
  if (!s) return;

  document.getElementById('reveal-btn').style.display = 'none';
  document.getElementById('ideal-text').innerHTML = s.ideal;
  document.getElementById('ideal-answer').classList.add('show');
  document.getElementById('rating-section').classList.add('show');

  // Scroll to ideal answer
  setTimeout(() => {
    document.getElementById('ideal-answer').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function rateAnswer(rating) {
  const s = scenarios[currentScenarioKey];
  if (!s) return;

  sessionRatings.push(rating);
  sessionCompleted++;
  updateStats();

  const feedback = document.getElementById('feedback-panel');
  const title = document.getElementById('feedback-title');
  const text = document.getElementById('feedback-text');
  const tags = document.getElementById('feedback-tags');

  const messages = {
    1: {
      icon: '‚ùå', color: '#ef4444',
      title: 'No worries ‚Äî this is how you learn!',
      text: 'The ideal answer is now in your memory. Run through this scenario again tomorrow. Repetition is how expertise is built. Most candidates never practice like this.',
      tagStyle: 'background:#ef444420; color:#ef4444; border:1px solid #ef444440;',
      tags: ['Review Tomorrow', 'Keep Going', 'Part of the Process']
    },
    2: {
      icon: 'üòì', color: '#f59e0b',
      title: 'Good attempt ‚Äî you have the foundation!',
      text: 'You knew parts of it. Focus on the specific points you missed. In interviews, a partial answer is far better than silence. Build on what you know.',
      tagStyle: 'background:#f59e0b20; color:#f59e0b; border:1px solid #f59e0b40;',
      tags: ['Building Knowledge', 'Getting There', 'Review Key Points']
    },
    3: {
      icon: '‚úì', color: '#22c55e',
      title: 'Solid! You understand this topic.',
      text: "You've got the core concepts. Keep practicing to sharpen the precise language ‚Äî interviewers are impressed by specificity. You're interview-ready on this topic.",
      tagStyle: 'background:#22c55e20; color:#22c55e; border:1px solid #22c55e40;',
      tags: ['Interview Ready', 'Strong Foundation', 'Sharpen Details']
    },
    4: {
      icon: '‚≠ê', color: '#4f8ef7',
      title: 'Excellent! This answer is yours.',
      text: "You nailed it. When this comes up in an interview, you'll answer with confidence. Your 10 years of clinical experience + this technical depth is a powerful combination.",
      tagStyle: 'background:#4f8ef720; color:#4f8ef7; border:1px solid #4f8ef740;',
      tags: ['Mastered', 'üíº Interview Ready', 'üöÄ Keep Going']
    }
  };

  const m = messages[rating];
  title.innerHTML = `<span style="color:${m.color}">${m.icon}</span> ${m.title}`;
  text.textContent = m.text;
  tags.innerHTML = m.tags.map(t =>
    `<span class="feedback-tag" style="${m.tagStyle}">${t}</span>`
  ).join('');

  feedback.classList.add('show');

  setTimeout(() => {
    feedback.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function nextScenario() {
  const keys = Object.keys(scenarios);
  const idx = keys.indexOf(currentScenarioKey);
  const nextKey = keys[(idx + 1) % keys.length];
  loadScenario(nextKey);
}

function updateStats() {
  document.getElementById('stat-completed').textContent = sessionCompleted;
  if (sessionRatings.length > 0) {
    const avg = (sessionRatings.reduce((a, b) => a + b, 0) / sessionRatings.length).toFixed(1);
    document.getElementById('stat-score').textContent = avg + '/4';
  }
}
</script>
</body>
</html>