<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MindBridge Mentor ‚Äî Simulation Lab</title>
<style>
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --card: #22263a;
    --border: #2e3350;
    --accent: #4f8ef7;
    --green: #22c55e;
    --yellow: #f59e0b;
    --red: #ef4444;
    --purple: #a855f7;
    --text: #e2e8f0;
    --muted: #64748b;
    --sim-color: #f59e0b;
    --int-color: #a855f7;
    --con-color: #4f8ef7;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Segoe UI', system-ui, sans-serif;
    min-height: 100vh;
  }

  /* Header */
  .header {
    background: linear-gradient(135deg, #1a1d27 0%, #0f1117 100%);
    border-bottom: 1px solid var(--border);
    padding: 20px 32px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .header-left h1 { font-size: 20px; font-weight: 700; color: var(--text); }
  .header-left p { font-size: 13px; color: var(--muted); margin-top: 2px; }
  .target-badge {
    background: linear-gradient(135deg, #22c55e20, #22c55e10);
    border: 1px solid #22c55e40;
    border-radius: 20px;
    padding: 6px 16px;
    font-size: 13px;
    color: var(--green);
    font-weight: 600;
  }

  /* Layout */
  .container { display: flex; height: calc(100vh - 73px); }

  /* Sidebar */
  .sidebar {
    width: 280px;
    background: var(--surface);
    border-right: 1px solid var(--border);
    overflow-y: auto;
    flex-shrink: 0;
  }
  .sidebar-section { padding: 16px; border-bottom: 1px solid var(--border); }
  .sidebar-title {
    font-size: 11px;
    font-weight: 700;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 12px;
  }
  .scenario-btn {
    width: 100%;
    text-align: left;
    background: none;
    border: 1px solid transparent;
    border-radius: 8px;
    padding: 10px 12px;
    color: var(--text);
    cursor: pointer;
    margin-bottom: 4px;
    transition: all 0.15s;
    display: flex;
    align-items: flex-start;
    gap: 10px;
  }
  .scenario-btn:hover { background: var(--card); border-color: var(--border); }
  .scenario-btn.active { background: var(--card); border-color: var(--accent); }
  .scenario-btn .icon { font-size: 18px; flex-shrink: 0; margin-top: 1px; }
  .scenario-btn .info { flex: 1; }
  .scenario-btn .name { font-size: 13px; font-weight: 600; line-height: 1.3; }
  .scenario-btn .tag {
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    margin-top: 3px;
    letter-spacing: 0.06em;
  }
  .tag-sim { color: var(--sim-color); }
  .tag-int { color: var(--int-color); }
  .tag-con { color: var(--con-color); }

  /* Main area */
  .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

  /* Simulation stage */
  .stage {
    flex: 1;
    padding: 32px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  /* Scenario card */
  .scenario-header {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 24px;
  }
  .scenario-type {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    padding: 4px 10px;
    border-radius: 20px;
    margin-bottom: 14px;
  }
  .type-sim { background: #f59e0b20; color: var(--sim-color); border: 1px solid #f59e0b40; }
  .type-int { background: #a855f720; color: var(--int-color); border: 1px solid #a855f740; }
  .type-con { background: #4f8ef720; color: var(--con-color); border: 1px solid #4f8ef740; }
  .scenario-question {
    font-size: 17px;
    font-weight: 600;
    line-height: 1.5;
    color: var(--text);
  }
  .scenario-context {
    margin-top: 12px;
    font-size: 13px;
    color: var(--muted);
    line-height: 1.6;
    padding: 12px;
    background: #ffffff08;
    border-radius: 8px;
    border-left: 3px solid var(--accent);
  }

  /* Answer area */
  .answer-section { display: flex; flex-direction: column; gap: 12px; }
  .answer-label {
    font-size: 12px;
    font-weight: 700;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.06em;
  }
  .answer-textarea {
    width: 100%;
    min-height: 140px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px;
    color: var(--text);
    font-size: 14px;
    font-family: inherit;
    line-height: 1.6;
    resize: vertical;
    transition: border-color 0.15s;
    outline: none;
  }
  .answer-textarea:focus { border-color: var(--accent); }
  .answer-textarea::placeholder { color: var(--muted); }

  /* Buttons */
  .btn-row { display: flex; gap: 10px; align-items: center; }
  .btn {
    padding: 10px 20px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    border: none;
    transition: all 0.15s;
  }
  .btn-primary { background: var(--accent); color: white; }
  .btn-primary:hover { background: #3b7ce8; }
  .btn-secondary {
    background: var(--card);
    color: var(--text);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover { border-color: var(--accent); }
  .btn-disabled { opacity: 0.5; cursor: not-allowed; }

  /* Ideal answer reveal */
  .ideal-answer {
    background: var(--card);
    border: 1px solid #22c55e40;
    border-radius: 12px;
    padding: 20px;
    display: none;
  }
  .ideal-answer.show { display: block; }
  .ideal-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--green);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .ideal-text {
    font-size: 14px;
    line-height: 1.7;
    color: var(--text);
  }
  .ideal-text strong { color: var(--accent); }

  /* Rating */
  .rating-section {
    display: none;
    flex-direction: column;
    gap: 12px;
  }
  .rating-section.show { display: flex; }
  .rating-label {
    font-size: 13px;
    color: var(--muted);
    font-weight: 600;
  }
  .rating-buttons { display: flex; gap: 8px; flex-wrap: wrap; }
  .rating-btn {
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    border: 1px solid var(--border);
    background: var(--card);
    color: var(--text);
    transition: all 0.15s;
  }
  .rating-btn:hover { transform: translateY(-1px); }
  .rating-btn[data-r="1"]:hover { background: #ef444420; border-color: var(--red); color: var(--red); }
  .rating-btn[data-r="2"]:hover { background: #f59e0b20; border-color: var(--yellow); color: var(--yellow); }
  .rating-btn[data-r="3"]:hover { background: #22c55e20; border-color: var(--green); color: var(--green); }
  .rating-btn[data-r="4"]:hover { background: #4f8ef720; border-color: var(--accent); color: var(--accent); }

  /* Feedback panel */
  .feedback-panel {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    display: none;
  }
  .feedback-panel.show { display: block; }
  .feedback-title {
    font-size: 14px;
    font-weight: 700;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .feedback-text { font-size: 13px; line-height: 1.7; color: var(--text); }
  .feedback-tags { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 12px; }
  .feedback-tag {
    font-size: 11px;
    font-weight: 700;
    padding: 3px 8px;
    border-radius: 12px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  /* Stats bar */
  .stats-bar {
    background: var(--surface);
    border-top: 1px solid var(--border);
    padding: 12px 32px;
    display: flex;
    gap: 32px;
    align-items: center;
  }
  .stat { display: flex; align-items: center; gap: 8px; }
  .stat-value { font-size: 18px; font-weight: 700; color: var(--text); }
  .stat-label { font-size: 12px; color: var(--muted); }
  .stat-divider { width: 1px; height: 28px; background: var(--border); }

  /* Welcome screen */
  .welcome {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 40px;
    gap: 16px;
  }
  .welcome h2 { font-size: 24px; font-weight: 700; }
  .welcome p { font-size: 15px; color: var(--muted); max-width: 420px; line-height: 1.6; }
  .welcome-cards { display: flex; gap: 16px; margin-top: 8px; }
  .welcome-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    width: 160px;
    text-align: center;
  }
  .welcome-card .icon { font-size: 28px; margin-bottom: 8px; }
  .welcome-card .title { font-size: 13px; font-weight: 700; margin-bottom: 4px; }
  .welcome-card .desc { font-size: 11px; color: var(--muted); line-height: 1.5; }

  /* Loading */
  .loading {
    display: none;
    align-items: center;
    gap: 8px;
    color: var(--muted);
    font-size: 13px;
  }
  .loading.show { display: flex; }
  .spinner {
    width: 16px; height: 16px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
</style>
</head>
<body>

<div class="header">
  <div class="header-left">
    <h1>üè• MindBridge Mentor ‚Äî Simulation Lab</h1>
    <p>Interactive scenario practice for Healthcare AI Engineer interviews</p>
  </div>
  <div class="target-badge">üéØ Target: $200K‚Äì$300K</div>
</div>

<div class="container">

  <!-- Sidebar -->
  <div class="sidebar">
    <div class="sidebar-section">
      <div class="sidebar-title">üé≠ Simulations (21)</div>
      <button class="scenario-btn" onclick="loadScenario('login')" id="btn-login">
        <span class="icon">üîê</span>
        <span class="info">
          <div class="name">Patient Login Flow</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('screening')" id="btn-screening">
        <span class="icon">‚öïÔ∏è</span>
        <span class="info">
          <div class="name">Risk Screening Pipeline</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('apikey')" id="btn-apikey">
        <span class="icon">üîë</span>
        <span class="info">
          <div class="name">Junior Dev: API Keys</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('debug500')" id="btn-debug500">
        <span class="icon">üêõ</span>
        <span class="info">
          <div class="name">Debug 500 Error</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('slowapi')" id="btn-slowapi">
        <span class="icon">üêå</span>
        <span class="info">
          <div class="name">API Performance Issue</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('corserror')" id="btn-corserror">
        <span class="icon">üö´</span>
        <span class="info">
          <div class="name">CORS Error</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('ratelimit')" id="btn-ratelimit">
        <span class="icon">‚è±Ô∏è</span>
        <span class="info">
          <div class="name">Rate Limiting</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('circuitbreaker')" id="btn-circuitbreaker">
        <span class="icon">‚ö°</span>
        <span class="info">
          <div class="name">Circuit Breaker Pattern</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('caching')" id="btn-caching">
        <span class="icon">üíæ</span>
        <span class="info">
          <div class="name">Redis Caching</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('deployment')" id="btn-deployment">
        <span class="icon">üöÄ</span>
        <span class="info">
          <div class="name">Zero-Downtime Deploy</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('monitoring')" id="btn-monitoring">
        <span class="icon">üìä</span>
        <span class="info">
          <div class="name">Production Monitoring</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('incident')" id="btn-incident">
        <span class="icon">üö®</span>
        <span class="info">
          <div class="name">Incident Response</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('multitenancy')" id="btn-multitenancy">
        <span class="icon">üè¢</span>
        <span class="info">
          <div class="name">Multi-Tenant Architecture</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('vercel_build_fail')" id="btn-vercel_build_fail">
        <span class="icon">üî®</span>
        <span class="info">
          <div class="name">Vercel Build Fails</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('nextjs_404')" id="btn-nextjs_404">
        <span class="icon">üóÇÔ∏è</span>
        <span class="info">
          <div class="name">Dynamic Route 404</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('econnrefused')" id="btn-econnrefused">
        <span class="icon">üîå</span>
        <span class="info">
          <div class="name">ECONNREFUSED Debug</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('gitguardian')" id="btn-gitguardian">
        <span class="icon">üö®</span>
        <span class="info">
          <div class="name">Exposed Credentials Alert</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('session_expired')" id="btn-session_expired">
        <span class="icon">‚è∞</span>
        <span class="info">
          <div class="name">Session Expired Mid-Shift</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('railway_deploy_fail')" id="btn-railway_deploy_fail">
        <span class="icon">üöÇ</span>
        <span class="info">
          <div class="name">Railway Deployment Fails</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('db_unavailable')" id="btn-db_unavailable">
        <span class="icon">üíæ</span>
        <span class="info">
          <div class="name">Database Unavailable on Startup</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('cors_blocked')" id="btn-cors_blocked">
        <span class="icon">üö´</span>
        <span class="info">
          <div class="name">CORS Blocking API Calls</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('stale_clinical_data')" id="btn-stale_clinical_data">
        <span class="icon">‚è±Ô∏è</span>
        <span class="info">
          <div class="name">Stale Clinical Data Incident</div>
          <div class="tag tag-sim">Simulation</div>
        </span>
      </button>
    </div>

    <div class="sidebar-section">
      <div class="sidebar-title">üé§ Interview Practice (22)</div>
      <button class="scenario-btn" onclick="loadScenario('whyhire')" id="btn-whyhire">
        <span class="icon">üíº</span>
        <span class="info">
          <div class="name">Why Hire You?</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('project')" id="btn-project">
        <span class="icon">üöÄ</span>
        <span class="info">
          <div class="name">Tell Me About a Project</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('apidesign')" id="btn-apidesign">
        <span class="icon">üèóÔ∏è</span>
        <span class="info">
          <div class="name">API Design Process</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('sensitive')" id="btn-sensitive">
        <span class="icon">üîí</span>
        <span class="info">
          <div class="name">Handling Sensitive Data</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('testing')" id="btn-testing">
        <span class="icon">üß™</span>
        <span class="info">
          <div class="name">Testing Strategy</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('bulkimport')" id="btn-bulkimport">
        <span class="icon">üì§</span>
        <span class="info">
          <div class="name">Bulk CSV Import Design</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('medication')" id="btn-medication">
        <span class="icon">üíä</span>
        <span class="info">
          <div class="name">Medication Interactions</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('patientmatching')" id="btn-patientmatching">
        <span class="icon">üîç</span>
        <span class="info">
          <div class="name">Patient Matching</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('realtime')" id="btn-realtime">
        <span class="icon">‚ö°</span>
        <span class="info">
          <div class="name">Real-Time Updates</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('scaling')" id="btn-scaling">
        <span class="icon">üìà</span>
        <span class="info">
          <div class="name">Scale to 100K Patients</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('failover')" id="btn-failover">
        <span class="icon">üîß</span>
        <span class="info">
          <div class="name">Database Failover</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('frontend_arch')" id="btn-frontend_arch">
        <span class="icon">üèóÔ∏è</span>
        <span class="info">
          <div class="name">MindBridge Frontend Architecture</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('nextjs_vs_react')" id="btn-nextjs_vs_react">
        <span class="icon">‚öõÔ∏è</span>
        <span class="info">
          <div class="name">Why Next.js Over React?</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('add_auth')" id="btn-add_auth">
        <span class="icon">üîê</span>
        <span class="info">
          <div class="name">Add Auth to Dashboard</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('fullstack_connect')" id="btn-fullstack_connect">
        <span class="icon">üîó</span>
        <span class="info">
          <div class="name">Connect Frontend to Database</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('auth_interview')" id="btn-auth_interview">
        <span class="icon">üîë</span>
        <span class="info">
          <div class="name">How Did You Implement Auth?</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('hipaa_auth_design')" id="btn-hipaa_auth_design">
        <span class="icon">üè•</span>
        <span class="info">
          <div class="name">Design HIPAA-Compliant Auth</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('fastapi_deploy_interview')" id="btn-fastapi_deploy_interview">
        <span class="icon">üöÄ</span>
        <span class="info">
          <div class="name">Walk Me Through Your Deployment</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('async_vs_sync')" id="btn-async_vs_sync">
        <span class="icon">‚ö°</span>
        <span class="info">
          <div class="name">Async vs Sync Database Calls</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('full_stack_architecture')" id="btn-full_stack_architecture">
        <span class="icon">üèóÔ∏è</span>
        <span class="info">
          <div class="name">Walk Me Through Your Architecture</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('week3_technical_review')" id="btn-week3_technical_review">
        <span class="icon">üéØ</span>
        <span class="info">
          <div class="name">Week 3 Technical Review</div>
          <div class="tag tag-int">Interview</div>
        </span>
      </button>
    </div>

    <div class="sidebar-section">
      <!-- DEMO SCRIPT SECTION -->
      <div class="section-header">üé¨ DEMO SCRIPT (4)</div>
      <button class="scenario-btn" onclick="loadScenario('demo_login')" id="btn-demo_login">
        <span class="icon">üîê</span>
        <span class="info">
          <div class="name">Login Page Demo</div>
          <div class="tag tag-int">Demo</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('demo_dashboard')" id="btn-demo_dashboard">
        <span class="icon">üìä</span>
        <span class="info">
          <div class="name">Dashboard Demo</div>
          <div class="tag tag-int">Demo</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('demo_api')" id="btn-demo_api">
        <span class="icon">‚ö°</span>
        <span class="info">
          <div class="name">FastAPI Backend Demo</div>
          <div class="tag tag-int">Demo</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('demo_architecture')" id="btn-demo_architecture">
        <span class="icon">üèóÔ∏è</span>
        <span class="info">
          <div class="name">Full Architecture Demo</div>
          <div class="tag tag-int">Demo</div>
        </span>
      </button>
    </div>

    <div class="sidebar-section">
      <div class="sidebar-title">üí° Concept Check (18)</div>
      <button class="scenario-btn" onclick="loadScenario('docker')" id="btn-docker">
        <span class="icon">üê≥</span>
        <span class="info">
          <div class="name">Docker & Containers</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('postgres')" id="btn-postgres">
        <span class="icon">üóÑÔ∏è</span>
        <span class="info">
          <div class="name">PostgreSQL vs MongoDB</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('hipaa')" id="btn-hipaa">
        <span class="icon">üè•</span>
        <span class="info">
          <div class="name">HIPAA Requirements</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('pooling')" id="btn-pooling">
        <span class="icon">üîÑ</span>
        <span class="info">
          <div class="name">Connection Pooling</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('fhir')" id="btn-fhir">
        <span class="icon">üîó</span>
        <span class="info">
          <div class="name">FHIR Integration</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('hl7')" id="btn-hl7">
        <span class="icon">üìã</span>
        <span class="info">
          <div class="name">HL7 v2 Parsing</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('server_client')" id="btn-server_client">
        <span class="icon">‚ö°</span>
        <span class="info">
          <div class="name">Server vs Client Components</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('cicd_concept')" id="btn-cicd_concept">
        <span class="icon">üîÑ</span>
        <span class="info">
          <div class="name">CI/CD Pipeline</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('mindbridge_e2e')" id="btn-mindbridge_e2e">
        <span class="icon">üó∫Ô∏è</span>
        <span class="info">
          <div class="name">MindBridge End-to-End</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('env_vars')" id="btn-env_vars">
        <span class="icon">üîê</span>
        <span class="info">
          <div class="name">Environment Variables</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('nextauth_concept')" id="btn-nextauth_concept">
        <span class="icon">üîê</span>
        <span class="info">
          <div class="name">NextAuth.js Deep Dive</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('middleware_concept')" id="btn-middleware_concept">
        <span class="icon">üõ°Ô∏è</span>
        <span class="info">
          <div class="name">Next.js Middleware</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('jwt_hipaa')" id="btn-jwt_hipaa">
        <span class="icon">üè•</span>
        <span class="info">
          <div class="name">JWT & HIPAA Session Rules</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('connection_pooling_deep')" id="btn-connection_pooling_deep">
        <span class="icon">üîå</span>
        <span class="info">
          <div class="name">Connection Pooling Deep Dive</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('railway_env_vars')" id="btn-railway_env_vars">
        <span class="icon">üîë</span>
        <span class="info">
          <div class="name">Railway Environment Variables</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('server_vs_client')" id="btn-server_vs_client">
        <span class="icon">‚ö°</span>
        <span class="info">
          <div class="name">Server vs Client Components</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
      <button class="scenario-btn" onclick="loadScenario('next_public_vars')" id="btn-next_public_vars">
        <span class="icon">üîë</span>
        <span class="info">
          <div class="name">NEXT_PUBLIC_ Variables</div>
          <div class="tag tag-con">Concept</div>
        </span>
      </button>
    </div>
  </div>

  <!-- Main Stage -->
  <div class="main">
    <div class="stage" id="stage">

      <!-- Welcome screen shown by default -->
      <div class="welcome" id="welcome">
        <div style="font-size:48px">üè•</div>
        <h2>Welcome to Simulation Lab</h2>
        <p>Practice real scenarios you'll face in Healthcare AI Engineer interviews. 65 scenarios covering simulations, interviews, and technical concepts.</p>
        <div class="welcome-cards">
          <div class="welcome-card">
            <div class="icon">üé≠</div>
            <div class="title">Simulations</div>
            <div class="desc">21 real-world system scenarios including deployment and incident response</div>
          </div>
          <div class="welcome-card">
            <div class="icon">üé§</div>
            <div class="title">Interview</div>
            <div class="desc">22 interview scenarios including healthcare-specific design challenges</div>
          </div>
          <div class="welcome-card">
            <div class="icon">üí°</div>
            <div class="title">Concepts</div>
            <div class="desc">18 deep-dive technical concepts: Docker, PostgreSQL, HIPAA, FHIR, HL7, Pooling</div>
          </div>
          <div class="welcome-card">
            <div class="icon">üé¨</div>
            <div class="title">Demo Scripts</div>
            <div class="desc">4 hiring manager demo scripts covering login, dashboard, API, and full architecture</div>
          </div>
        </div>
      </div>

      <!-- Scenario content (hidden until selected) -->
      <div id="scenario-content" style="display:none;">

        <div class="scenario-header">
          <div class="scenario-type" id="scenario-type-badge"></div>
          <div class="scenario-question" id="scenario-question"></div>
          <div class="scenario-context" id="scenario-context" style="display:none"></div>
        </div>

        <div class="answer-section">
          <div class="answer-label">Your Answer</div>
          <textarea
            class="answer-textarea"
            id="user-answer"
            placeholder="Type your answer here... Try to recall everything before revealing the ideal answer."
          ></textarea>
          <div class="btn-row">
            <button class="btn btn-primary" id="reveal-btn" onclick="revealAnswer()">
              Reveal Ideal Answer
            </button>
            <div class="loading" id="loading-indicator">
              <div class="spinner"></div>
              <span>Analyzing your answer...</span>
            </div>
          </div>
        </div>

        <div class="ideal-answer" id="ideal-answer">
          <div class="ideal-title">‚úÖ Ideal Answer</div>
          <div class="ideal-text" id="ideal-text"></div>
        </div>

        <div class="rating-section" id="rating-section">
          <div class="rating-label">How well did you know this?</div>
          <div class="rating-buttons">
            <button class="rating-btn" data-r="1" onclick="rateAnswer(1)">‚ùå No idea</button>
            <button class="rating-btn" data-r="2" onclick="rateAnswer(2)">üòì Partial</button>
            <button class="rating-btn" data-r="3" onclick="rateAnswer(3)">‚úì Good</button>
            <button class="rating-btn" data-r="4" onclick="rateAnswer(4)">‚≠ê Perfect</button>
          </div>
        </div>

        <div class="feedback-panel" id="feedback-panel">
          <div class="feedback-title" id="feedback-title"></div>
          <div class="feedback-text" id="feedback-text"></div>
          <div class="feedback-tags" id="feedback-tags"></div>
          <div style="margin-top:16px">
            <button class="btn btn-secondary" onclick="nextScenario()">Next Scenario ‚Üí</button>
          </div>
        </div>

      </div>
    </div>

    <!-- Stats bar -->
    <div class="stats-bar">
      <div class="stat">
        <div class="stat-value" id="stat-completed">0</div>
        <div class="stat-label">Completed Today</div>
      </div>
      <div class="stat-divider"></div>
      <div class="stat">
        <div class="stat-value" id="stat-score">‚Äî</div>
        <div class="stat-label">Avg Rating</div>
      </div>
      <div class="stat-divider"></div>
      <div class="stat">
        <div class="stat-value" style="color:var(--green)">Week 2</div>
        <div class="stat-label">Curriculum Phase</div>
      </div>
      <div class="stat-divider"></div>
      <div class="stat">
        <div class="stat-value" style="color:var(--accent)">65</div>
        <div class="stat-label">Total Scenarios</div>
      </div>
      <div class="stat-divider"></div>
      <div class="stat">
        <div class="stat-value" style="color:var(--green)">$200K+</div>
        <div class="stat-label">Target Role</div>
      </div>
    </div>
  </div>
</div>

<script>
const scenarios = {
  login: {
    type: "simulation",
    title: "Patient Login Flow Simulation",
    question: "You're a case manager at Oakwood Behavioral Health. Walk me through exactly what happens ‚Äî technically ‚Äî when you log into MindBridge. What systems are involved at each step?",
    context: "Scenario context: You're explaining this to a new developer joining the team. Be specific about each system, security measure, and what data flows where.",
    ideal: `<strong>Step 1 ‚Äî Browser to Frontend:</strong> You enter your email + password on the Next.js login page. The form submits to NextAuth.js, which handles the session layer.<br><br>
<strong>Step 2 ‚Äî Frontend to Backend:</strong> NextAuth sends credentials to FastAPI POST /api/auth/verify with email and password hash.<br><br>
<strong>Step 3 ‚Äî Database Validation:</strong> FastAPI queries PostgreSQL ‚Äî SELECT user WHERE email matches, then bcrypt.verify() checks the password hash. Plain passwords are NEVER stored.<br><br>
<strong>Step 4 ‚Äî MFA Check:</strong> If the user has MFA enabled (required for admin roles), FastAPI prompts for TOTP code before proceeding.<br><br>
<strong>Step 5 ‚Äî JWT Issued:</strong> FastAPI generates a signed JWT token containing user_id, role, clinic_id, and expiry. Signed with RS256 ‚Äî can't be forged.<br><br>
<strong>Step 6 ‚Äî Secure Cookie:</strong> NextAuth stores the session in an httpOnly, Secure cookie. JavaScript cannot read this cookie ‚Äî XSS-proof.<br><br>
<strong>Step 7 ‚Äî Scoped Dashboard:</strong> Dashboard loads ‚Äî every API call includes the Bearer token. FastAPI validates it and queries ONLY patients WHERE case_manager_id = your user_id.<br><br>
<strong>Step 8 ‚Äî HIPAA Audit:</strong> Every login is logged to audit_log table: user_id, timestamp, IP address, action='LOGIN'. This is required by HIPAA.`
  },

  screening: {
    type: "simulation",
    title: "Risk Screening Pipeline",
    question: "A case manager clicks 'Screen Patient' for Marcus Johnson (patient_id: uuid-123). Walk through the complete technical pipeline from button click to risk badge appearing on the dashboard.",
    context: "This is a common system design question. Show you understand async flows, AI integration, error handling, and HIPAA compliance.",
    ideal: `<strong>1. Frontend Request:</strong> Next.js sends POST /api/analysis { patient_id: 'uuid-123' } with Bearer JWT token in headers.<br><br>
<strong>2. Middleware Layer:</strong> FastAPI validates JWT (user authenticated), checks RBAC (has 'analyst' role), applies rate limiting (prevents abuse).<br><br>
<strong>3. Patient Fetch:</strong> Analysis Service queries PostgreSQL: SELECT * FROM patients WHERE id='uuid-123' AND deleted_at IS NULL. Confirms patient belongs to this case manager's clinic.<br><br>
<strong>4. Claude API Call:</strong> Structured prompt sent to Claude with patient data: appointments_missed, medication_adherence, crisis_calls_30days, diagnosis. Async ‚Äî doesn't block other requests.<br><br>
<strong>5. AI Response Parsed:</strong> Claude returns Risk Level, Primary Factor, Recommended Action. Pydantic validates the response structure.<br><br>
<strong>6. Database Write:</strong> ACID transaction: (a) INSERT screening result, (b) UPDATE patient risk_level, (c) INSERT audit_log. All three succeed or NONE do ‚Äî no partial writes.<br><br>
<strong>7. High Risk Alert:</strong> If risk_level = 'HIGH', Notification Service sends email to case manager's supervisor immediately. This is a patient safety feature.<br><br>
<strong>8. Response to Frontend:</strong> FastAPI returns { screening_id, risk_level, primary_factor, action, timestamp }. Next.js updates the dashboard with color-coded risk badge (Red/Orange/Green).`
  },

  apikey: {
    type: "simulation",
    title: "Junior Developer: API Key Security",
    question: "A new junior developer on your team just committed their Anthropic API key directly in the Python code and pushed to GitHub. They say 'it's fine, our repo is private.' How do you respond?",
    context: "This is both a technical and professional situation. Show you understand security, HIPAA implications, and how to mentor without being dismissive.",
    ideal: `<strong>First, act immediately:</strong> "Let's fix this right now before anything else. Private repos get made public, get transferred, get forked. Go to Anthropic's dashboard and revoke that key immediately. Generate a new one."<br><br>
<strong>Then explain why 'private' isn't safe:</strong> "Three reasons this is serious: (1) Git history is permanent ‚Äî even after you delete the file, the key exists in every commit forever. git log shows everything. (2) Private repos get breached ‚Äî GitHub has had security incidents. (3) For a healthcare app, an exposed key means an exposed Claude API ‚Äî that could mean patient data in prompts is accessible."<br><br>
<strong>Show the right way:</strong> "Use os.environ.get('ANTHROPIC_API_KEY'). In development, put it in a .env file that's in .gitignore. In production, use AWS Secrets Manager or environment variables in your deployment platform."<br><br>
<strong>HIPAA angle:</strong> "If this were a production system and patient data was in those API prompts, this could be a HIPAA breach notification situation ‚Äî not just a bug to fix."<br><br>
<strong>Make it a learning moment:</strong> "I'll send you our security checklist. This happens to everyone once ‚Äî the goal is it only happens once."`
  },

  debug500: {
    type: "simulation",
    title: "Debug 500 Error in Production",
    question: "Your FastAPI endpoint suddenly returns 500 Internal Server Error. Users are calling support. Walk me through debugging it step by step.",
    context: "This tests real-world debugging under pressure. Show methodical thinking, not panic.",
    ideal: `<strong>STEP 1 ‚Äî Check the logs immediately:</strong><br>
tail -f logs/app.log or check CloudWatch/Railway logs. The 500 error will have a stack trace showing exactly where it failed.<br><br>
<strong>STEP 2 ‚Äî Identify the error type:</strong><br>
DatabaseError = connection pool exhausted or DB down. Check: docker compose ps or Railway dashboard.<br>
ClientError (Anthropic) = API key invalid or rate limit hit. Check: Anthropic dashboard.<br>
ValidationError = data schema mismatch. Check: Pydantic model definitions.<br>
AttributeError = code trying to access None. Check: null checks before field access.<br><br>
<strong>STEP 3 ‚Äî Common MindBridge 500 causes and fixes:</strong><br>
'Connection pool exhausted' ‚Üí Increase pool_size in SQLAlchemy (default 5 is too low for production).<br>
'anthropic.APIError: Invalid API key' ‚Üí Environment variable not set correctly in production.<br>
'NoneType has no attribute' ‚Üí Database returned null, code didn't check. Fix: Add if patient is not None check.<br><br>
<strong>STEP 4 ‚Äî Reproduce locally:</strong><br>
Copy the exact request from logs, replay in Postman/curl. Fix the bug and deploy.<br><br>
<strong>STEP 5 ‚Äî Add monitoring:</strong><br>
After fixing, add logging around the failure point so next time you catch it earlier.<br><br>
<strong>Interview gold:</strong> "Read the logs first. The stack trace tells you exactly what failed. Most 500 errors are fixed in under 10 minutes if you read the error message carefully instead of guessing."`
  },

  slowapi: {
    type: "simulation",
    title: "API Performance - It's Too Slow",
    question: "A case manager reports the API is 'slow'. The dashboard takes 10 seconds to load. How do you diagnose and fix it?",
    context: "Performance debugging is a core skill. Show you know how to measure before optimizing.",
    ideal: `<strong>STEP 1 ‚Äî Define 'slow':</strong><br>
Get specifics: Which endpoint? How slow (2 seconds? 30 seconds?)? Happens always or intermittently?<br><br>
<strong>STEP 2 ‚Äî Check the obvious:</strong><br>
Is Claude API down? (Check status.anthropic.com)<br>
Is database connection pool exhausted? (Check logs for 'Timeout waiting for connection')<br>
Is the network slow? (Check CloudWatch/Railway metrics)<br><br>
<strong>STEP 3 ‚Äî Add timing logs:</strong><br>
import time; start = time.time(); result = await db.query(...); print(f'Query took {time.time()-start}s')<br>
This shows which part is slow: database? Claude API? Data processing?<br><br>
<strong>STEP 4 ‚Äî Common MindBridge performance issues:</strong><br>
<strong>N+1 queries</strong> ‚Äî Loading 50 patients then fetching each patient's screenings individually. Fix: Use JOIN or eager loading.<br>
<strong>Missing database index</strong> ‚Äî Querying WHERE clinic_id without an index scans entire table. Fix: CREATE INDEX idx_patients_clinic ON patients(clinic_id).<br>
<strong>Large response payloads</strong> ‚Äî Returning 10MB of data when frontend only needs 50KB. Fix: Use Pydantic response model to include only necessary fields.<br>
<strong>Synchronous blocking</strong> ‚Äî Claude API call blocks all other requests. Already fixed with async.<br><br>
<strong>STEP 5 ‚Äî Verify the fix:</strong><br>
Before: Dashboard loads in 10 seconds.<br>
After: Dashboard loads in 0.5 seconds.<br>
Log the improvement. Update monitoring.<br><br>
<strong>Interview gold:</strong> "Performance issues are usually database queries. Add timing, find the slow query, add an index. 90% of the time that's the fix. The other 10% is usually oversized API responses."`
  },

  corserror: {
    type: "simulation",
    title: "CORS Error - Frontend Can't Reach Backend",
    question: "Your Next.js frontend suddenly can't reach the FastAPI backend. Browser console shows: 'CORS policy: No Access-Control-Allow-Origin header'. What do you do?",
    context: "CORS errors confuse many developers. Show you understand web security fundamentals.",
    ideal: `<strong>What CORS is:</strong><br>
CORS (Cross-Origin Resource Sharing) is a browser security feature that blocks requests between different domains by default.<br><br>
<strong>Why it's failing:</strong><br>
Frontend runs on app.mindbridge.com (or localhost:3000 in dev).<br>
Backend runs on api.mindbridge.com (or localhost:8000 in dev).<br>
Browser blocks the request because origins don't match.<br><br>
<strong>THE FIX ‚Äî Add CORS middleware to FastAPI:</strong><br>
from fastapi.middleware.cors import CORSMiddleware<br>
app.add_middleware(CORSMiddleware, allow_origins=["https://app.mindbridge.com"], allow_credentials=True, allow_methods=["GET","POST","PUT","DELETE"], allow_headers=["Authorization","Content-Type"])<br><br>
<strong>Development config:</strong><br>
allow_origins=["http://localhost:3000"] ‚Äî for local Next.js dev server<br><br>
<strong>CRITICAL ‚Äî What NOT to do:</strong><br>
NEVER use allow_origins=["*"] in production for a healthcare app. That means ANY website can call your patient data API. For a HIPAA-compliant system, you must whitelist specific origins.<br><br>
<strong>How to test:</strong><br>
Open browser DevTools ‚Üí Network tab ‚Üí Try the API call ‚Üí Response headers should show Access-Control-Allow-Origin: https://app.mindbridge.com<br><br>
<strong>Interview gold:</strong> "CORS is a browser security feature, not a server problem. The fix is always on the backend ‚Äî add the CORS middleware with explicit origin whitelisting. Never use wildcards in healthcare applications."`
  },

  whyhire: {
    type: "interview",
    title: "Why Should We Hire You?",
    question: "We have several candidates with Computer Science degrees from top universities applying for this Healthcare AI Engineer role. Why should we hire you instead?",
    context: "This is your moment. Use your 10 years of clinical experience as the unfair advantage it is. Don't be defensive ‚Äî be confident.",
    ideal: `"Computer Science degrees teach algorithms, data structures, and systems ‚Äî all valuable. But they don't teach you what happens when a risk assessment algorithm flags the wrong patient, or why a case manager will ignore an alert that fires too often, or what a behavioral health crisis actually looks like at 2 AM.<br><br>
In my 10 years as a Mental Health Technician and CNA, I've lived those scenarios. I've watched high-risk patients fall through the cracks because the documentation system was too slow. I've seen staff ignore automated alerts because the false positive rate was too high. I know exactly the problems that MindBridge Health AI is designed to solve ‚Äî not from reading about them, but from experiencing them.<br><br>
That domain expertise changes how I build systems. When I designed the risk screening algorithm, I didn't just optimize for accuracy ‚Äî I designed the alert thresholds to minimize alert fatigue based on clinical workflows I've actually worked in. I built the audit logging not just for compliance, but because I know auditors show up after incidents, not before.<br><br>
You can teach a CS grad to use FastAPI in 6 months. You cannot teach 10 years of behavioral health experience. I bring both, and that's rare."`
  },

  project: {
    type: "interview",
    title: "Tell Me About a Recent Project",
    question: "Tell me about a technical project you've built recently. Walk me through the problem, your approach, and the outcome.",
    context: "Use the 3-part framework: Clinical Context ‚Üí Technical Solution ‚Üí Business Impact. Always anchor in your healthcare experience.",
    ideal: `<strong>CLINICAL CONTEXT:</strong> "In my 10 years as a Mental Health Technician, I watched case managers spend 6+ hours every day manually reviewing patient charts to assess risk ‚Äî checking medication adherence, counting missed appointments, reviewing crisis call logs. With 30-40 patients per case manager, high-risk patients sometimes fell through the cracks between reviews."<br><br>
<strong>TECHNICAL SOLUTION:</strong> "I built MindBridge Health AI ‚Äî a full-stack, HIPAA-compliant behavioral health risk screening platform. The backend is FastAPI with PostgreSQL, integrated with Claude AI for risk assessment. I built an automated pipeline that ingests patient data from CSV or direct entry, sends each patient through a structured Claude prompt with clinical guardrails, and generates professional reports in Word, Excel, and PDF. The system uses role-based access control and comprehensive audit logging for HIPAA compliance."<br><br>
<strong>BUSINESS IMPACT:</strong> "What used to take a case manager 6+ hours now takes under 2 minutes. The AI correctly identifies high-risk patients with high sensitivity, and the clinical guardrails I built ensure the AI can never automatically downgrade a patient who's been manually escalated ‚Äî a human is always in the loop for that decision. It's the kind of system I wish existed when I was doing direct patient care."`
  },

  apidesign: {
    type: "interview",
    title: "API Design Process",
    question: "Walk me through your API design process. How do you decide what endpoints to create, how to structure them, and what to prioritize?",
    context: "Show that you think about users first, then technical implementation. Demonstrate understanding of REST principles and healthcare-specific considerations.",
    ideal: `"My API design starts with the clinical workflow, not the technical spec.<br><br>
<strong>Step 1 ‚Äî Map the User Journey:</strong> I start by mapping what the end users ‚Äî case managers, clinicians, administrators ‚Äî actually do each day. Each workflow task becomes a candidate endpoint: 'view my patients', 'run a screening', 'download a report'.<br><br>
<strong>Step 2 ‚Äî Apply REST Principles:</strong> Resources are nouns (patients, screenings, reports), actions are HTTP methods. GET /patients for listing, POST /screenings for creating, GET /reports/{id}/download for retrieving. I avoid verbs in URLs ‚Äî /run-screening is wrong, POST /screenings is right.<br><br>
<strong>Step 3 ‚Äî Design Data Contracts First:</strong> Before writing any route code, I write Pydantic schemas. This forces me to think about what data flows in and out. Medication adherence must be 0.0-1.0, never null. This catches design flaws before they become production bugs.<br><br>
<strong>Step 4 ‚Äî Add Security Layers:</strong> Every endpoint gets RBAC defined before it's built. Who can call this? Case managers see only their patients. Admins see all. This is especially important in healthcare ‚Äî a case manager accidentally seeing another clinic's patients is a HIPAA incident.<br><br>
<strong>Step 5 ‚Äî Plan for Audit:</strong> Every data access endpoint gets HIPAA audit logging built in from day one, not added later. Later never comes."`
  },

  sensitive: {
    type: "interview",
    title: "Handling Sensitive Patient Data",
    question: "How do you handle sensitive patient data in your systems? Walk me through your approach to data security and HIPAA compliance in MindBridge.",
    context: "This question tests both technical knowledge and healthcare domain understanding. Show that HIPAA is baked into the architecture, not bolted on.",
    ideal: `"I treat HIPAA compliance as architecture, not an afterthought. There are four layers in MindBridge:<br><br>
<strong>1. Data at Rest:</strong> The PostgreSQL database volume is encrypted with AES-256. PHI fields ‚Äî patient names, dates of birth ‚Äî are additionally encrypted at the application layer using Fernet symmetric encryption. Two independent encryption layers means a database dump is useless without both keys.<br><br>
<strong>2. Data in Transit:</strong> TLS 1.3 for all API connections. We enforce HTTPS-only ‚Äî any HTTP request redirects to HTTPS. JWT tokens are signed with RS256 and expire after 8 hours.<br><br>
<strong>3. Access Control:</strong> Role-based access control at the API layer, plus Row-Level Security in PostgreSQL. A case manager's query literally cannot return another case manager's patients ‚Äî it's enforced at the database level, not just the application level. Defense in depth.<br><br>
<strong>4. Audit Logging:</strong> Every access to PHI ‚Äî every patient view, every screening, every report download ‚Äî is logged to an immutable audit table with user_id, timestamp, IP address, and action. This is what HIPAA auditors look for after an incident. We also never hard-delete records ‚Äî soft deletes with deleted_at timestamps, because HIPAA requires retention.<br><br>
<strong>5. Version Control Hygiene:</strong> .gitignore excludes all generated reports and patient data. Environment variables for all credentials ‚Äî never in code. The .gitignore itself is a HIPAA compliance document in our repository."`
  },

  testing: {
    type: "interview",
    title: "Your Testing Strategy",
    question: "Walk me through your testing strategy for MindBridge. How do you ensure the AI doesn't give dangerous medical advice?",
    context: "Healthcare AI requires rigorous testing. Show you understand both technical testing AND clinical safety.",
    ideal: `<strong>Three-layer testing strategy:</strong><br><br>
<strong>LAYER 1 ‚Äî Unit Tests (Technical Safety):</strong><br>
Test each function in isolation using pytest.<br>
Example: test_patient_risk_calculation() verifies that medication_adherence=0.3 + appointments_missed=4 correctly flags as HIGH risk.<br>
Example: test_pydantic_validation() ensures medication_adherence=5.0 is rejected (must be 0.0-1.0).<br>
Coverage target: 90% of backend code.<br><br>
<strong>LAYER 2 ‚Äî Integration Tests (System Safety):</strong><br>
Test complete workflows end-to-end.<br>
Example: POST /api/analysis with real patient data ‚Üí verify Claude API is called ‚Üí verify response saved to database ‚Üí verify audit log entry created.<br>
Example: Test authentication ‚Äî 401 if no token, 403 if wrong role.<br><br>
<strong>LAYER 3 ‚Äî Clinical Guardrails (Patient Safety):</strong><br>
This is where my 10 years of clinical experience matters.<br>
<strong>Guardrail 1:</strong> AI can never automatically downgrade a patient from HIGH to MEDIUM risk. Only a licensed clinician can do that.<br>
<strong>Guardrail 2:</strong> If patient has crisis_calls_30days > 0, risk level is minimum MEDIUM regardless of other factors.<br>
<strong>Guardrail 3:</strong> AI suggestions are always labeled "AI-Generated - Requires Clinical Review" in the UI.<br>
<strong>Guardrail 4:</strong> All AI assessments log the exact prompt and response to audit_log for post-incident review.<br><br>
<strong>Real-world testing:</strong><br>
I'd also pilot with 5 case managers for 2 weeks before full rollout. Track: How often do they override the AI? What patterns emerge? Are false positives causing alert fatigue?<br><br>
<strong>Interview gold:</strong> "In healthcare AI, testing isn't just about code correctness. It's about clinical safety. The AI is a tool to help clinicians, not replace their judgment. That's why the guardrails prevent automated decisions on critical actions."`
  },

  bulkimport: {
    type: "interview",
    title: "Design Challenge - Bulk CSV Import",
    question: "A clinic wants to import 500 existing patients from a CSV file. How would you design this feature from scratch?",
    context: "This tests system design thinking, not just coding. Show you think about users, errors, performance, and safety.",
    ideal: `<strong>USER WORKFLOW FIRST:</strong><br>
Case manager uploads CSV with 500 patients ‚Üí System validates ‚Üí Imports ‚Üí Returns summary: "450 imported, 50 errors with reasons"<br><br>
<strong>TECHNICAL DESIGN:</strong><br><br>
<strong>STEP 1 ‚Äî Endpoint Design:</strong><br>
POST /patients/import accepts file upload (multipart/form-data)<br>
Returns 202 Accepted immediately with task_id (don't block ‚Äî 500 patients is too slow for sync request)<br><br>
<strong>STEP 2 ‚Äî Validation (Fail Fast):</strong><br>
Check: Is it a valid CSV? Required columns present (name, DOB, medication_adherence)?<br>
Return 400 Bad Request immediately if malformed ‚Äî don't waste time processing garbage.<br><br>
<strong>STEP 3 ‚Äî Background Processing (Celery Worker):</strong><br>
500 patients √ó 2 seconds each = 1000 seconds (16 minutes). Can't block a web request that long.<br>
Use Celery to process async. Frontend polls GET /imports/{task_id} for status.<br><br>
<strong>STEP 4 ‚Äî Row-Level Validation:</strong><br>
For each row: Pydantic validates data types. Check for duplicates (same name + DOB already in DB). Log invalid rows separately ‚Äî don't fail entire import for one bad row.<br><br>
<strong>STEP 5 ‚Äî Database Transaction:</strong><br>
Wrap ALL inserts in a single transaction. If DB fails mid-import, rollback everything ‚Äî no partial imports (150 patients in, 350 missing = data corruption).<br><br>
<strong>STEP 6 ‚Äî HIPAA Audit:</strong><br>
Log: Who uploaded (user_id). When (timestamp). Which file (filename, hash). How many patients (count). Store the original CSV temporarily for post-incident review if needed.<br><br>
<strong>STEP 7 ‚Äî Result Endpoint:</strong><br>
GET /imports/{task_id} returns:<br>
{status: "processing|completed|failed", imported: 450, errors: [{row: 23, reason: "Invalid medication_adherence: must be 0.0-1.0"}]}<br><br>
<strong>SECURITY CONSIDERATIONS:</strong><br>
File size limit (10MB max ‚Äî prevent DOS)<br>
Virus scan the CSV<br>
RBAC ‚Äî only admins can bulk import<br>
Rate limit ‚Äî 1 import per hour per user<br><br>
<strong>Interview gold:</strong> "I'd prototype with synchronous processing for 50 patients first, then add Celery when we hit scale. Always validate MVP assumptions with real usage before building complex async systems. Over-engineering early kills velocity."`
  },

  docker: {
    type: "concept",
    title: "Docker & Containerization",
    question: "Explain Docker and why MindBridge uses it. What problem does it solve, and what would happen without it?",
    context: "Go beyond the textbook definition. Tie it to healthcare reliability and the specific MindBridge use case.",
    ideal: `<strong>What Docker is:</strong> Docker packages an application and ALL its dependencies ‚Äî Python version, libraries, OS configurations ‚Äî into a portable container that runs identically everywhere.<br><br>
<strong>The problem it solves:</strong> Without Docker, "it works on my machine" is a patient safety issue. If the development environment uses Python 3.11 and production uses Python 3.9, subtle behavioral differences could cause risk assessments to produce different results. In healthcare, that's not a bug ‚Äî it's a clinical liability.<br><br>
<strong>MindBridge's docker-compose.yml has three services:</strong><br>
‚Ä¢ backend ‚Äî FastAPI on port 8000 with hot-reload for development<br>
‚Ä¢ db ‚Äî PostgreSQL 16 on port 5432 with health checks<br>
‚Ä¢ redis ‚Äî Redis 7 on port 6379 for caching and sessions<br><br>
<strong>The health check matters:</strong> depends_on with service_healthy ensures FastAPI won't start until PostgreSQL is confirmed ready. Without this, the app crashes on startup and a case manager can't log in.<br><br>
<strong>For a new developer:</strong> git clone + docker compose up = complete local environment in 60 seconds. Same database version, same Python version, same Redis. No "it works on my machine."`
  },

  postgres: {
    type: "concept",
    title: "PostgreSQL vs MongoDB",
    question: "Why did you choose PostgreSQL over MongoDB for MindBridge? When would MongoDB be the right choice?",
    context: "Show you understand the tradeoffs, not just that 'relational is better'. Healthcare-specific reasoning is key.",
    ideal: `<strong>Three reasons PostgreSQL for MindBridge:</strong><br><br>
<strong>1. ACID Transactions:</strong> When we run a risk screening, three things happen: INSERT screening result, UPDATE patient risk_level, INSERT audit_log entry. ALL three must succeed or NONE do ‚Äî no partial writes. In healthcare, a partial write could show a patient as 'low risk' while the actual screening says 'high risk'. MongoDB's document model can handle transactions, but they're more complex and less reliable under failure conditions.<br><br>
<strong>2. Row-Level Security:</strong> We enforce at the DATABASE level that case managers can only query their own patients ‚Äî not just the application level. If there's ever a bug in our FastAPI code, the database itself won't return unauthorized patient records. This defense-in-depth is what HIPAA auditors look for.<br><br>
<strong>3. JSONB for flexibility:</strong> We don't lose MongoDB's flexibility ‚Äî PostgreSQL's JSONB columns store the semi-structured AI analysis output alongside structured patient data. Best of both worlds.<br><br>
<strong>When MongoDB would be right:</strong> If we were storing unstructured clinical notes, medical images metadata, or building a feature with rapidly evolving schema where migrations would slow development, MongoDB would make sense as a supplementary store alongside PostgreSQL.`
  },

  hipaa: {
    type: "concept",
    title: "HIPAA Security Requirements",
    question: "What does the HIPAA Security Rule require for a system like MindBridge? How have you implemented these requirements?",
    context: "Most engineers know HIPAA exists but can't explain it technically. This is your chance to stand out.",
    ideal: `<strong>HIPAA Security Rule has three categories of safeguards:</strong><br><br>
<strong>Technical Safeguards (what we build):</strong><br>
‚Ä¢ Encryption at rest: AES-256 for database volumes + application-level field encryption for PHI<br>
‚Ä¢ Encryption in transit: TLS 1.3 for all connections, HTTPS-only<br>
‚Ä¢ Access controls: JWT authentication + RBAC + PostgreSQL Row-Level Security<br>
‚Ä¢ Audit controls: Immutable audit_log table ‚Äî every PHI access recorded with user, timestamp, IP, action<br>
‚Ä¢ Automatic logoff: JWT tokens expire after 8 hours of inactivity<br><br>
<strong>Physical Safeguards (infrastructure):</strong><br>
‚Ä¢ Covered by cloud providers (AWS, Vercel, Railway) via Business Associate Agreements (BAAs)<br>
‚Ä¢ The BAA is the legal contract saying the cloud provider is also HIPAA-responsible<br><br>
<strong>Administrative Safeguards (policies):</strong><br>
‚Ä¢ Access review process: who can access what, reviewed quarterly<br>
‚Ä¢ Workforce training: documented security training for all staff<br>
‚Ä¢ Incident response plan: documented procedure for breach notification (72-hour rule)<br><br>
<strong>The 72-hour rule:</strong> If patient data is breached, you have 72 hours to notify affected patients and HHS. This is why our incident detection and audit logging is real-time, not batch.`
  },

  pooling: {
    type: "concept",
    title: "Connection Pooling Deep Dive",
    question: "You mentioned connection pooling in your resume. Explain what it is, why MindBridge needs it, and what happens when the pool is exhausted.",
    context: "This tests real production database knowledge, not just theory.",
    ideal: `<strong>What connection pooling is:</strong><br>
Connection pooling reuses database connections instead of opening a new one for every request. Think of it like a shared bike system ‚Äî bikes sit ready to use, you don't build a new bike each time.<br><br>
<strong>Why it matters for MindBridge:</strong><br>
Opening a PostgreSQL connection takes 50-100ms. If 100 case managers hit the dashboard simultaneously:<br>
WITHOUT pooling: 100 √ó 100ms = 10 seconds of pure connection overhead. The last user waits 10 seconds just to START their query.<br>
WITH pooling: 10 persistent connections ready. Requests queue and reuse existing connections. Max wait ‚âà query time, not connection time.<br><br>
<strong>MindBridge configuration:</strong><br>
engine = create_async_engine('postgresql://...', pool_size=10, max_overflow=20)<br>
This means: 10 persistent connections, can burst to 30 under heavy load.<br><br>
<strong>What happens when pool exhausted:</strong><br>
Error: 'QueuePool limit of size 10 overflow 20 reached, connection timed out'<br>
Users see: 500 Internal Server Error<br>
Real impact: Dashboard stops working during peak hours (morning when all case managers log in)<br><br>
<strong>How to fix:</strong><br>
Increase pool_size (but don't go crazy ‚Äî PostgreSQL has connection limits too)<br>
Find connection leaks (endpoints not closing DB sessions)<br>
Add connection pooling metrics to monitoring<br><br>
<strong>Interview gold:</strong> "Connection pooling is why MindBridge can handle 50 concurrent users on a single backend instance. Without it, we'd need 10√ó the server capacity or users would experience random timeouts."`
  },

  // === ADVANCED SIMULATIONS (7 NEW) ===
  
  ratelimit: {
    type: "simulation",
    title: "Implement Rate Limiting",
    question: "Case managers are reporting '429 Too Many Requests' errors when running batch screenings. Your rate limit is 100 requests/hour per user. How do you explain this to them and what's the fix?",
    context: "Balance user experience with API protection. Show you understand both technical and communication aspects.",
    ideal: `<strong>Why it's happening:</strong><br>
Rate limiting is a defense mechanism that blocks users making excessive requests. 100 requests/hour means one request every 36 seconds. If a case manager is running batch screenings for 50 patients, they exceed this limit fast. This was designed for normal user behavior, not batch operations.<br><br>
<strong>How to explain to the case manager:</strong><br>
"Your batch screening workflow is hitting a rate limit designed to prevent abuse. We're going to solve this in two ways: (1) immediate workaround for you, (2) permanent fix in the code."<br><br>
<strong>IMMEDIATE WORKAROUND:</strong><br>
Don't screen 50 patients in rapid sequence. Space them out over 2 minutes. Or contact IT and we'll temporarily raise your limit while we implement the permanent fix.<br><br>
<strong>PERMANENT FIX ‚Äî Implement Redis-based rate limiting with tiered limits:</strong><br>
from slowapi import Limiter<br>
limiter = Limiter(key_func=get_remote_address, storage_uri="redis://localhost")<br>
@app.post("/screenings")<br>
@limiter.limit("100/hour; 10/minute")<br>
async def create_screening(): ...<br><br>
This allows 10 requests per minute (covers normal use) but 100/hour overall (prevents abuse). Batch users stay under 10/min by spreading requests over 5 minutes.<br><br>
<strong>BETTER ‚Äî User-tier rate limits:</strong><br>
Regular case managers: 100/hour<br>
Power users (batch processing): 1000/hour (with supervisor approval)<br>
AI/automation: higher limits with API keys<br><br>
Check user role in the database and apply different limits:<br>
limit = "1000/hour" if user.tier == "power_user" else "100/hour"<br><br>
<strong>BEST PRACTICE ‚Äî Alert before limit:</strong><br>
Include rate limit headers in every response:<br>
X-RateLimit-Limit: 100<br>
X-RateLimit-Remaining: 23<br>
X-RateLimit-Reset: 1629234000<br>
Frontend shows a warning when remaining < 10: "You have 23 requests left this hour."<br><br>
<strong>Interview gold:</strong> "Rate limiting protects the API, but it shouldn't be invisible. Show users how close they are to the limit and offer tiered limits for different use cases. A 429 error on a patient's life-or-death screening is a UX failure."`
  },

  circuitbreaker: {
    type: "simulation",
    title: "Circuit Breaker Pattern",
    question: "Claude's API goes down. Your system makes 50 requests/second to it. Each request times out after 30 seconds. What happens to MindBridge?",
    context: "This tests understanding of cascading failures. Show you know defensive programming patterns.",
    ideal: `<strong>The disaster scenario:</strong><br>
Claude API goes down at 2 PM. MindBridge continues sending 50 req/sec to the dead API. Each one waits 30 seconds for a timeout. Within seconds, you have 1500 requests waiting (50 √ó 30), consuming all database connections. The pool is exhausted. Now EVERY API call ‚Äî even unrelated ones like patient lookup ‚Äî fails because there are no connections left. The entire system cascades into failure.<br><br>
<strong>Result:</strong> MindBridge appears completely dead even though YOUR code is fine. Case managers can't access patient data at all.<br><br>
<strong>THE FIX ‚Äî Implement Circuit Breaker Pattern:</strong><br>
The circuit breaker has 3 states:<br>
<strong>CLOSED (normal):</strong> Requests go through. If success rate > 95%, stay closed.<br>
<strong>OPEN (emergency):</strong> Claude is down. Don't send more requests. Immediately fail new requests with error "Risk assessment temporarily unavailable"<br>
<strong>HALF_OPEN (recovery):</strong> Periodically try 1 test request to Claude. If it succeeds, go back to CLOSED. If it fails, stay OPEN.<br><br>
<strong>Implementation using PyBreaker library:</strong><br>
from pybreaker import CircuitBreaker<br>
claude_breaker = CircuitBreaker(fail_max=5, reset_timeout=60)<br>
try:<br>
  response = claude_breaker.call(claude_api.call, patient_data)<br>
except CircuitBreakerListener as e:<br>
  return {risk: "UNKNOWN", message: "AI service temporarily down"}<br><br>
If Claude fails 5 times in a row, the circuit opens. Stop hitting it. Wait 60 seconds before retrying. Zero cascade.<br><br>
<strong>Fallback behavior:</strong><br>
When circuit is OPEN, don't just error. Provide graceful degradation:<br>
"Risk assessment unavailable (Claude API down). Using last known assessment from 15 minutes ago: HIGH RISK. A clinician will review when the service recovers."<br><br>
Better than showing an error, better than returning stale data silently.<br><br>
<strong>Monitoring:</strong><br>
Log every circuit state change. Alert ops when circuit opens: "Claude API circuit breaker tripped. Cascade prevented."<br><br>
<strong>Interview gold:</strong> "Circuit breakers prevent cascading failures. Without one, a downstream service failure can bring down your entire system in seconds. It's a pattern every production engineer should know."`
  },

  caching: {
    type: "simulation",
    title: "Redis Caching Layer",
    question: "Every dashboard load queries 'Get list of all medications' ‚Äî a 5-second query that returns the same 400 medications every time. How would you optimize this?",
    context: "Classic caching problem. Show you understand cache invalidation and TTL strategies.",
    ideal: `<strong>The problem:</strong><br>
Every case manager loads the dashboard. Dashboard queries: SELECT * FROM medications. This 5-second query runs EVERY dashboard load. If 20 case managers use the dashboard, that's 100 seconds of database query time when the data is identical.<br><br>
<strong>STEP 1 ‚Äî Identify the opportunity:</strong><br>
The medication list is reference data. It changes rarely (maybe quarterly when new drugs are approved). Perfect for caching.<br><br>
<strong>STEP 2 ‚Äî Add Redis caching:</strong><br>
from redis import Redis<br>
redis = Redis(host='localhost')<br><br>
async def get_medications():<br>
  # Try cache first<br>
  cached = redis.get('medications:list')<br>
  if cached:<br>
    return json.loads(cached)  # 1ms instead of 5000ms<br><br>
  # Cache miss ‚Äî query database<br>
  meds = await db.query("SELECT * FROM medications")<br><br>
  # Store in cache with 1 hour TTL<br>
  redis.setex('medications:list', 3600, json.dumps(meds))<br>
  return meds<br><br>
<strong>Result:</strong> First dashboard load: 5 seconds. All subsequent loads: 1 millisecond. 5000√ó faster.<br><br>
<strong>STEP 3 ‚Äî Cache invalidation:</strong><br>
Here's the hard part. When should the cache expire?<br>
Option 1: TTL of 1 hour. After 1 hour, cache expires. Database is checked again. Simple, but could serve stale data for up to 1 hour.<br>
Option 2: Event-based invalidation. When an admin adds a new medication via POST /medications, immediately invalidate the cache:<br>
  redis.delete('medications:list')<br>
  Database is queried again on next load. Always fresh.<br><br>
<strong>STEP 4 ‚Äî Cache warming (optional):</strong><br>
On app startup, pre-load the medications into cache. When a case manager first loads the dashboard, it's already cached. Zero wait.<br><br>
@app.on_event("startup")<br>
async def warm_cache():<br>
  meds = await db.query("SELECT * FROM medications")<br>
  redis.setex('medications:list', 3600, json.dumps(meds))<br><br>
<strong>The tradeoff:</strong><br>
Benefit: 5000√ó faster loads, reduced database load<br>
Cost: Redis memory, staleness window, cache invalidation complexity<br>
Worth it? Absolutely. Reference data caching is high-impact, low-risk.<br><br>
<strong>Interview gold:</strong> "Cache invalidation is one of the two hardest problems in computer science. For reference data, TTL + event-based invalidation is the safest approach. Always measure the benefit ‚Äî 5000√ó faster is worth the complexity."`
  },

  deployment: {
    type: "simulation",
    title: "Zero-Downtime Deployment",
    question: "You need to deploy a database schema change (adding a new column to patients table). How do you do it without taking MindBridge offline?",
    context: "Production deployment requires careful planning. Show you understand database migrations and backward compatibility.",
    ideal: `<strong>The naive approach (FAILS):</strong><br>
Stop the backend. ALTER TABLE patients ADD COLUMN risk_assessment_date DATE. Start the backend. Result: 5 minutes of downtime. In healthcare, that's unacceptable.<br><br>
<strong>THE CORRECT APPROACH ‚Äî 3-Phase Deployment:</strong><br><br>
<strong>PHASE 1 ‚Äî Backward compatibility (deploy backend code):</strong><br>
Update the backend code to handle the NEW schema before the schema exists. This seems weird but it's the key to zero downtime.<br>
Add code that checks: if column exists, use it. If not, use default value.<br>
python<br>
if 'risk_assessment_date' in columns:<br>
  created_at = patient.risk_assessment_date<br>
else:<br>
  created_at = datetime.now()  # Fallback<br><br>
Deploy this code. Old schema still exists. No downtime. All requests still work.<br><br>
<strong>PHASE 2 ‚Äî Run the migration (background):</strong><br>
During off-peak hours (2 AM), run the ALTER TABLE without taking the service down. PostgreSQL allows concurrent connections during schema changes (in most cases).<br>
But here's the issue: ALTER TABLE ... ADD COLUMN on a 100M row table takes TIME. Lock the table, and you block case managers from accessing patients. Solution: Use online migration tools.<br><br>
Option A: Postgres 11+ ADD COLUMN with default is relatively fast<br>
Option B: Use pg_gzip or similar tools for truly massive tables<br>
Option C: Create new table, backfill data, swap tables (manual but 100% safe)<br><br>
<strong>PHASE 3 ‚Äî Remove the fallback code (deploy backend code again):</strong><br>
Once migration is complete, deploy clean code that always expects the column to exist.<br>
if 'risk_assessment_date' in columns:  # Never true now, safe to remove<br><br>
<strong>Full example timeline:</strong><br>
3:30 PM: Deploy code with fallback logic. Env: prod. Result: working, old schema.<br>
2:00 AM: ALTER TABLE patients ADD COLUMN risk_assessment_date DATE DEFAULT null. Duration: 2 minutes. Zero downtime.<br>
9:00 AM: Deploy code without fallback. Result: working, new schema.<br><br>
Total downtime: 0 minutes. Case managers never notice.<br><br>
<strong>Rollback plan:</strong><br>
If something goes wrong at Phase 1, redeploy code without the fallback. If Phase 2 fails, rollback and retry. If Phase 3 fails, code is still compatible with old schema.<br><br>
<strong>Interview gold:</strong> "Zero-downtime deployments require thinking backward: code first, schema second. Write code that works with both old and new schema. Then change the schema. Then clean up the code. This is standard practice at every major tech company."`
  },

  monitoring: {
    type: "simulation",
    title: "Production Monitoring & Alerts",
    question: "Your CTO asks: 'How do we know if MindBridge is working?' What metrics do you monitor and what triggers an alert?",
    context: "Production systems need observability. Show you think about proactive monitoring, not just reactive debugging.",
    ideal: `<strong>The wrong answer:</strong> "I check the dashboard if it's running." That's reactive. You measure, you don't wait for users to complain.<br><br>
<strong>CRITICAL METRICS (Real-time monitoring):</strong><br><br>
<strong>1. Application Health:</strong><br>
‚Ä¢ Response time: API endpoints should return in < 500ms. Alert if > 1000ms (something is slow)<br>
‚Ä¢ Error rate: < 1% of requests should fail. Alert if > 5%<br>
‚Ä¢ Availability: Uptime target 99.9%. Alert if any endpoint is unavailable for 5+ minutes<br>
‚Ä¢ Database connection pool: Alert if pool_size usage > 80% (approaching exhaustion)<br><br>
<strong>2. Healthcare-Specific Metrics:</strong><br>
‚Ä¢ AI screening latency: Claude API calls should complete in < 30s. Alert if > 60s<br>
‚Ä¢ Audit log volume: Every patient access should be logged. Alert if audit logging fails<br>
‚Ä¢ Overdue screenings: How many patients haven't been screened in 30 days? (Clinical concern, not technical)<br><br>
<strong>3. Infrastructure Metrics:</strong><br>
‚Ä¢ Database CPU: Alert if > 80%<br>
‚Ä¢ Disk space: Alert if < 20% free<br>
‚Ä¢ Memory usage: Alert if > 85%<br><br>
<strong>ALERT TIERS ‚Äî Not all alerts are equal:</strong><br><br>
<strong>CRITICAL (Page on-call engineer immediately):</strong><br>
‚Ä¢ API is down (no response to health check)<br>
‚Ä¢ Database is unreachable<br>
‚Ä¢ Payment system is down<br>
Silencing a CRITICAL alert: unacceptable<br><br>
<strong>WARNING (Alert but don't page, review next morning):</strong><br>
‚Ä¢ Response time > 2 seconds<br>
‚Ä¢ Error rate > 5%<br>
‚Ä¢ Cache hit rate drops below 50%<br><br>
<strong>INFO (Log, useful for debugging):</strong><br>
‚Ä¢ Database query slow (but < 5s)<br>
‚Ä¢ New user signup<br>
‚Ä¢ Patient screening completed<br><br>
<strong>Implementation example:</strong><br>
from prometheus_client import Counter, Histogram, Gauge<br>
request_duration = Histogram('request_duration_seconds', 'Request latency')<br>
request_errors = Counter('request_errors_total', 'Request errors')<br>
connection_pool = Gauge('db_connection_pool_usage', 'DB pool usage')<br><br>
@app.post("/screenings")<br>
async def create_screening():<br>
  with request_duration.time():<br>
    try:<br>
      result = await claude_api.call(...)<br>
      if result.success:<br>
        return result<br>
    except Exception as e:<br>
      request_errors.inc()<br>
      raise<br><br>
<strong>Dashboard alerts (example PagerDuty/DataDog):</strong><br>
if response_time > 1000ms for 5 consecutive minutes:<br>
  alert_severity = "CRITICAL"<br>
  notify_on_call_engineer()<br><br>
if error_rate > 10% for 10 consecutive minutes:<br>
  alert_severity = "WARNING"<br>
  log_to_slack_monitoring_channel()<br><br>
<strong>Interview gold:</strong> "Production monitoring isn't about vanity metrics. It's about knowing the moment something breaks before users do. Alert on what matters: availability, latency, errors. Ignore the rest."`
  },

  incident: {
    type: "simulation",
    title: "Production Incident Response",
    question: "3 PM on a Tuesday: Case managers report 'all patients showing as LOW risk' regardless of actual data. What do you do in the first 10 minutes?",
    context: "Incident response tests composure under pressure. Show systematic thinking, not panic.",
    ideal: `<strong>MINUTE 0 ‚Äî Assess severity:</strong><br>
Is this a data integrity issue (risk assessments are WRONG) or a display issue (UI showing wrong data)?<br>
How many users are affected? All case managers or just some?<br>
Is patient safety at risk? YES ‚Äî case managers might discharge a HIGH-RISK patient thinking they're low risk.<br>
This is CRITICAL. Escalate immediately.<br><br>
<strong>MINUTE 1 ‚Äî Triage:</strong><br>
Open Slack war room. Ping: Your manager, on-call database engineer, on-call backend engineer.<br>
Message: "INCIDENT: Risk assessment showing as LOW for all patients. Possible data corruption. Investigating."<br>
Avoid: Panic. Keep communication clear and factual.<br><br>
<strong>MINUTE 2 ‚Äî Duplicate issue check:</strong><br>
Is this affecting MindBridge in production only, or dev/staging too?<br>
Query the database directly (not through the API):<br>
SELECT count(*) FROM screenings WHERE risk_level = 'LOW';<br>
SELECT count(*) FROM screenings WHERE risk_level = 'HIGH';<br>
Check: Did the actual data in the database change, or is it a display bug?<br><br>
<strong>MINUTE 3 ‚Äî Check recent deployments:</strong><br>
What deployed in the last 3 hours?<br>
Did the risk calculation logic change?<br>
Was there a database migration?<br>
Check git log: git log --oneline -10<br>
If a recent deployment could have caused this, prepare to rollback.<br><br>
<strong>MINUTE 4 ‚Äî Check the application logs:</strong><br>
tail -f logs/app.log | grep -i risk<br>
tail -f logs/error.log<br>
Check Claude API logs: Did the model behavior change? Did it start returning only LOW risk assessments?<br><br>
<strong>MINUTE 5 ‚Äî Hypothesis:</strong><br>
If database data is correct but API is returning LOW for all: Application bug.<br>
If database data is all LOW: Data corruption or bad migration.<br><br>
Most likely: Recent deployment changed risk calculation threshold.<br>
Prepare rollback command (if your current deploy seems wrong):<br>
git revert <commit><br><br>
<strong>MINUTE 6 ‚Äî Communicate status:</strong><br>
Post to war room: "Investigating. Initial diagnosis: possible risk threshold change in recent deploy. Checking logs."<br>
Update status page: "Investigating risk assessment accuracy. No patient data loss detected."<br><br>
<strong>MINUTE 7 ‚Äî Start fix OR rollback:</strong><br>
If you found a recent deploy that changed risk formula: ROLLBACK<br>
git revert <bad_commit><br>
Deploy immediately. Monitor.<br><br>
If it's a data issue: Don't deploy yet. Keep investigating.<br><br>
<strong>MINUTE 10 ‚Äî Report status:</strong><br>
"Identified issue: Deploy from 1:15 PM changed risk threshold from 3.0 to 5.0. Rolled back. Monitoring now. All screenings should show correct risk levels."<br><br>
<strong>AFTER INCIDENT (tonight, not tomorrow):</strong><br>
1. Postmortem: Why did this deploy happen without catching the bug?<br>
2. Remediation: Add automated test that checks ‚â•1 patient has HIGH risk in test data. Catches this next time.<br>
3. Communication: Clinic leadership gets summary: "Brief incident. Root cause identifies. Preventive measures in place."<br><br>
<strong>Interview gold:</strong> "Incident response is systematic: assess severity, gather info, form hypothesis, fix/rollback, monitor, communicate, postmortem. Never panic. A clear head fixes incidents in minutes. Panic extends them for hours."`
  },

  multitenancy: {
    type: "simulation",
    title: "Multi-Tenant Architecture",
    question: "MindBridge currently serves one clinic. A second clinic signs up. They want their data completely isolated. How do you architect this?",
    context: "Multi-tenancy is a common scaling challenge. Show you understand data isolation and security boundaries.",
    ideal: `<strong>The constraint:</strong><br>
Clinic A wants zero visibility into Clinic B's patient data. Not even metadata (how many patients, how many screenings). This is both a contractual requirement and a privacy requirement.<br><br>
<strong>THREE APPROACHES (with tradeoffs):</strong><br><br>
<strong>APPROACH 1 ‚Äî Shared Database, Shared Schema (simplest, least secure):</strong><br>
One database, one patients table, add clinic_id column.<br>
CREATE TABLE patients (id, name, clinic_id, risk_level, ...);<br><br>
Row-level security at the database level:<br>
CREATE POLICY clinic_isolation ON patients<br>
USING (clinic_id = current_setting('user_clinic_id'));<br><br>
Pros: Simple to implement, easy to manage one database<br>
Cons: One bug in the code and Clinic A can see Clinic B's data. HIPAA nightmare.<br><br>
<strong>APPROACH 2 ‚Äî Shared Database, Separate Schemas (better):</strong><br>
One PostgreSQL database, separate schema per clinic.<br>
CREATE SCHEMA clinic_a;<br>
CREATE SCHEMA clinic_b;<br>
CREATE TABLE clinic_a.patients (...);<br>
CREATE TABLE clinic_b.patients (...);<br><br>
On login, set search_path:<br>
SET search_path TO 'clinic_a';<br>
SELECT * FROM patients; -- Only sees clinic_a patients<br><br>
Pros: Better isolation, single database<br>
Cons: Still one database server, complex migrations (need to run on each schema)<br><br>
<strong>APPROACH 3 ‚Äî Separate Databases (safest, most expensive):</strong><br>
Clinic A gets their own PostgreSQL instance. Clinic B gets their own instance. Completely isolated.<br>
postgres://clinic_a_db.railway.app:5432/mindbridge (Clinic A)<br>
postgres://clinic_b_db.railway.app:5432/mindbridge (Clinic B)<br><br>
FastAPI routes to the correct database based on clinic_id:<br>
if user.clinic_id == 'clinic_a':<br>
  db = get_db(DSN_A)<br>
else:<br>
  db = get_db(DSN_B)<br><br>
Pros: Complete isolation, regulatory-approved (HIPAA loves this)<br>
Cons: Multiple database instances = higher cost, more ops overhead<br><br>
<strong>MY RECOMMENDATION FOR MINDBRIDEGE:</strong><br>
Start with Approach 2 (shared DB, separate schemas). It's the middle ground:<br>
‚Ä¢ Good isolation (Approach 1 bug won't expose data)<br>
‚Ä¢ Reasonable cost (one database server)<br>
‚Ä¢ Scales to ~20 clinics before capacity issues<br><br>
If you grow beyond 20 clinics and need stronger isolation guarantees, move to Approach 3 (separate databases).<br><br>
<strong>Additional considerations:</strong><br>
<strong>User authentication:</strong> Who can log in? Only clinic staff with clinic_id match.<br>
SELECT user FROM users WHERE email=? AND clinic_id = logged_in_user.clinic_id<br><br>
<strong>Audit logging:</strong> Separate audit tables per clinic (or clinic_id column in shared table)<br><br>
<strong>Backups:</strong> If using separate databases, backup each independently. Clinic A will want their own backup/recovery strategy.<br><br>
<strong>Interview gold:</strong> "Multi-tenancy is about isolation guarantees. Row-level security is fragile. Separate schemas are middle-ground. Separate databases are fortress. Choose based on your risk tolerance and budget."`
  },

  // === HEALTHCARE-SPECIFIC (4 NEW) ===

  fhir: {
    type: "concept",
    title: "FHIR Integration",
    question: "A hospital wants MindBridge to integrate with their Epic EHR using FHIR R4. What is FHIR and how would you approach this integration?",
    context: "FHIR is the healthcare data interoperability standard. Show you understand the healthcare ecosystem.",
    ideal: `<strong>What FHIR is:</strong><br>
FHIR (Fast Healthcare Interoperability Resources) is the modern standard for exchanging healthcare data. It's RESTful, JSON-based, and designed to make different healthcare systems talk to each other.<br><br>
Think of it like: Your MindBridge API vs. Epic's API. FHIR is the common language both speak.<br><br>
<strong>FHIR Resources (the building blocks):</strong><br>
Every piece of healthcare data is a "Resource" with a defined structure:<br>
‚Ä¢ Patient resource: demographics, name, DOB, contact info<br>
‚Ä¢ Encounter resource: visits, appointments, ED visits<br>
‚Ä¢ Observation resource: vital signs, test results, clinical measurements<br>
‚Ä¢ Medication resource: medication lists, dispensing info<br>
‚Ä¢ Condition resource: diagnoses<br><br>
Epic and MindBridge both speak these standard structures. No custom mapping needed.<br><br>
<strong>Why FHIR matters for MindBridge:</strong><br>
Instead of asking the hospital "send me a CSV with patient data," you say "I'll read your FHIR API." You get:<br>
‚Ä¢ Real-time data (don't wait for manual exports)<br>
‚Ä¢ Standardized structure (one code handles any hospital)<br>
‚Ä¢ Better data quality (hospital maintains it)<br><br>
<strong>Integration approach (3 phases):</strong><br><br>
<strong>PHASE 1 ‚Äî FHIR API Connection:</strong><br>
Epic exposes FHIR REST API at: https://epic.hospital.com/fhir/R4/<br>
Authenticate using SMART on FHIR (OAuth 2.0 for healthcare):<br>
1. MindBridge requests auth from Epic<br>
2. Hospital admin grants permission<br>
3. MindBridge gets access token<br>
4. MindBridge can now call Epic's API<br><br>
<strong>PHASE 2 ‚Äî Data Sync (Pull):</strong><br>
Scheduled job (nightly or real-time):<br>
GET https://epic.hospital.com/fhir/R4/Patient?_lastUpdated=gt2024-02-20<br>
This returns all patients modified since yesterday, as FHIR JSON.<br><br>
Example FHIR Patient resource in JSON:<br>
{<br>
  "resourceType": "Patient",<br>
  "id": "12345",<br>
  "name": [{family: "Johnson", given: ["Marcus"]}],<br>
  "birthDate": "1985-03-15",<br>
  "contact": [{telecom: [{system: "phone", value: "555-1234"}]}]<br>
}<br><br>
Map this to MindBridge schema:<br>
INSERT INTO patients (id, name, dob, phone) VALUES (12345, 'Marcus Johnson', 1985-03-15, '555-1234');<br><br>
<strong>PHASE 3 ‚Äî Data Enrichment:</strong><br>
GET /Observation?patient=12345 ‚Äî Get vital signs, test results<br>
GET /Medication?patient=12345 ‚Äî Get medication list<br>
GET /Condition?patient=12345 ‚Äî Get diagnoses<br><br>
Process all this to create your risk assessment:<br>
‚Ä¢ Medications => medication_adherence<br>
‚Ä¢ Conditions => comorbidities<br>
‚Ä¢ Observations => clinical factors<br><br>
<strong>Challenges you'll face:</strong><br>
1. Epic and other EHRs implement FHIR slightly differently (profiles). You need to handle variations.<br>
2. Permission scope: You can only read what the hospital grants ("read:Patient" vs. "read:Medication").<br>
3. Real-time updates: FHIR polling is nightly. For live data, use webhooks (hospital pushes updates to you).<br><br>
<strong>Interview gold:</strong> "FHIR is the healthcare interoperability standard. Instead of custom integrations with each EHR, you code to FHIR once and it works with Epic, Cerner, eClinicalWorks, etc. It's the future of healthcare IT."`
  },

  hl7: {
    type: "concept",
    title: "HL7 v2 Message Parsing",
    question: "A clinic sends you patient data as HL7 v2 messages, not JSON. What is HL7 and how would you parse it?",
    context: "HL7 v2 is the legacy healthcare data format. Still extremely common. Show you can bridge old and new systems.",
    ideal: `<strong>What HL7 v2 is (the legacy standard before FHIR):</strong><br>
HL7 v2 is a pipe-delimited text format that's been used by hospitals since the 1980s. It's ugly, but it's everywhere.<br><br>
Example HL7 v2 message:<br>
MSH|^~\\|MindBridge|Hospital|System|System|202402201500||ADT^A04|MSG00001|P|2.4<br>
PID|1||12345^^^MRN||Johnson^Marcus||19850315|M|||123 Main St^Apt 4^Anytown^CA^90210<br>
PV1|1|I|2East^210^1|H||||||||||||||MRN20240220|||||||||||||||||||||201...<br><br>
Looks like gibberish, right? But it's structured.<br><br>
<strong>HL7 Structure (segments separated by ^ ~ \):</strong><br>
‚Ä¢ MSH: Message header metadata<br>
‚Ä¢ PID: Patient demographics<br>
‚Ä¢ PV1: Patient visit/encounter<br>
‚Ä¢ OBX: Observations (vital signs, test results)<br>
‚Ä¢ RXA: Medication administration<br><br>
Example breakdown of the PID segment:<br>
PID|1||12345^^^MRN||Johnson^Marcus||19850315|M|||123 Main St^Apt 4^Anytown^CA^90210<br>
    |patient sequence number<br>
         |field separator (^)<br>
                    |patient ID<br>
                                 |last name^first name<br>
                                                    |birth date<br>
                                                         |gender<br><br>
<strong>How to parse HL7 v2 in Python:</strong><br>
from hl7apy.core import parse_message<br>
msg = parse_message(hl7_raw_text)<br>
<br>
name = msg['PID'][-5][0][0]  # Get PID segment, patient name field<br>
Or use a more readable library:<br>
<br>
import hl7<br>
parsed = hl7.parse(message_string)<br>
patient_name = parsed[0][5]  # PID segment, name field<br>
patient_dob = parsed[0][7]   # PID segment, DOB field<br><br>
<strong>Real-world MindBridge example:</strong><br>
Hospital sends HL7 messages with patient data. MindBridge needs to:<br>
1. Parse the HL7 v2 message<br>
2. Extract patient demographics and medication list<br>
3. Store in PostgreSQL in MindBridge schema<br>
4. Run risk assessment<br><br>
async def ingest_hl7_message(raw_hl7):<br>
  try:<br>
    msg = parse_hl7(raw_hl7)  # Custom parser<br>
    patient = {<br>
      'name': msg.PID.patient_name,<br>
      'dob': msg.PID.birth_date,<br>
      'clinic_id': msg.MSH.sending_facility<br>
    }<br>
    await db.patients.insert(patient)<br>
    # Now run screening on new patient<br>
    screening = await run_screening(patient)<br>
  except HL7ParseError as e:<br>
    log_error(f"Invalid HL7: {e}")<br>
    notify_hospital()  # Send bounce message back to hospital<br><br>
<strong>Challenges:</strong><br>
1. HL7 is flexible ‚Äî different hospitals use it differently. You need custom mappings for each hospital.<br>
2. Error handling: If HL7 is malformed, reject it and send back an error acknowledgement (HA^ACK message).<br>
3. Version mismatch: Hospital sends HL7 v2.3, you expect v2.4. Handle both.<br><br>
<strong>The bridge to FHIR:</strong><br>
Many hospitals are moving TO FHIR FROM HL7. But legacy systems still send HL7. Your job: accept both, convert to your internal format, process uniformly.<br><br>
<strong>Interview gold:</strong> "HL7 v2 is legacy but ubiquitous in healthcare. You'll likely encounter it. The key is systematic parsing and defensive error handling."`
  },

  medication: {
    type: "interview",
    title: "Medication Interaction Checking",
    question: "Design a feature that alerts case managers if a patient is prescribed two medications with dangerous interactions. How would you build this?",
    context: "Healthcare-specific system design. Show you understand clinical safety AND technical architecture.",
    ideal: `<strong>The requirement:</strong><br>
When a patient's medication list is updated (from EHR sync or manual entry), check for drug-drug interactions. If Patient X is on Medication A and Medication B, and A+B can cause a dangerous interaction, alert the case manager immediately.<br><br>
<strong>DESIGN ‚Äî Three components:</strong><br><br>
<strong>COMPONENT 1 ‚Äî Drug Interaction Database:</strong><br>
You need a source of truth for drug interactions. Options:<br>
Option A: Use a commercial API (DrugBank, FDA Interactions, RxNorm)<br>
Option B: Build it from RxNorm (free from NIH)<br>
<br>
I'd use RxNorm API + supplement with clinical knowledge:<br>
<br>
CREATE TABLE drug_interactions (<br>
  drug_a_id INTEGER,<br>
  drug_b_id INTEGER,<br>
  interaction_type VARCHAR (moderate|severe|contraindicated),<br>
  description TEXT,<br>
  management TEXT<br>
);<br><br>
Examples:<br>
(Warfarin, Aspirin) -> SEVERE: "Increased bleeding risk"<br>
(SSRIs, MAOIs) -> CONTRAINDICATED: "Risk of serotonin syndrome"<br>
(Metformin, Alcohol) -> MODERATE: "Lactic acidosis risk"<br><br>
<strong>COMPONENT 2 ‚Äî Interaction Checker (Algorithm):</strong><br>
When patient's medications change, run this:<br>
<br>
async def check_interactions(patient_id):<br>
  meds = await get_patient_medications(patient_id)  # [Warfarin, Aspirin]<br>
  interactions = []<br>
  <br>
  # Check all pairs<br>
  for drug_a, drug_b in combinations(meds, 2):<br>
    interaction = await find_interaction(drug_a, drug_b)<br>
    if interaction and interaction.severity in ['SEVERE', 'CONTRAINDICATED']:<br>
      interactions.append(interaction)<br>
  <br>
  return interactions<br><br>
Result: [{drugs: [Warfarin, Aspirin], type: SEVERE, description: "Bleeding risk"}]<br><br>
<strong>COMPONENT 3 ‚Äî Alert UI/Workflow:</strong><br>
Display the alert to case manager:<br>
<br>
üö® CRITICAL MEDICATION INTERACTION<br>
Patient: Marcus Johnson<br>
Issue: Warfarin + Aspirin = Increased bleeding risk<br>
Action: Contact prescriber immediately to review<br>
Recommended: Consider alternative antiplatelet agent<br>
<br>
Buttons: [Acknowledge] [Contact Prescriber] [Override] [Escalate to MD]<br><br>
<strong>Important design detail:</strong><br>
DON'T auto-resolve the alert. A case manager must see and acknowledge it. Clinical safety requires human oversight.<br><br>
<strong>Implementation in the pipeline:</strong><br>
When EHR sync updates medications:<br>
1. Sync new meds to PostgreSQL<br>
2. Run check_interactions()<br>
3. If alerts found, create ALERT record in database<br>
4. Notify case manager (email, Slack, page)<br>
5. Alert stays open until case manager clicks [Acknowledge]<br>
6. Log the action: "Case manager acknowledged interaction, prescriber contacted"<br><br>
<strong>Tricky edge cases:</strong><br>
1. Over-the-counter drugs: Patient doesn't tell you they take Tylenol at home. Aspirin + Acetaminophen = interaction. Solution: Ask patient to list ALL medications (OTC, supplements, herbal).<br>
2. Duplicate alerts: Don't alert every day if it's the same interaction. Alert once, then periodically (weekly) remind.<br>
3. Severity tiers: SEVERE = immediate alert. MODERATE = info in UI. MINOR = log but don't alert.<br><br>
<strong>Database schema:</strong><br>
CREATE TABLE medication_interactions_alerts (<br>
  id UUID,<br>
  patient_id UUID,<br>
  drug_a_id INTEGER,<br>
  drug_b_id INTEGER,<br>
  interaction_id REF drug_interactions,<br>
  acknowledged_at TIMESTAMP,<br>
  acknowledged_by USER_ID,<br>
  action_taken TEXT,<br>
  created_at TIMESTAMP<br>
);<br><br>
<strong>Interview gold:</strong> "Medication interactions are a patient safety issue. Design it so case managers can't miss the alert, but can't auto-dismiss it. Make humans responsible for clinical decisions. That's how you prevent adverse events."`
  },

  patientmatching: {
    type: "interview",
    title: "Patient Matching Algorithm",
    question: "Two patient records: 'John Smith, DOB 1985-03-15' and 'Jonathan Smith, DOB 03/15/1985'. Same person or not? How do you handle patient matching?",
    context: "Patient identity matching is a hard, unsolved problem in healthcare. Show you understand the nuances.",
    ideal: `<strong>Why patient matching is hard:</strong><br>
‚Ä¢ Data entry errors: "John" vs. "Jonathan" ‚Äî are they the same person?<br>
‚Ä¢ Date format inconsistency: 1985-03-15 vs. 03/15/1985 ‚Äî parsing is tricky<br>
‚Ä¢ Missing data: What if one record has middle initial, one doesn't?<br>
‚Ä¢ Typos: "Smoth" vs. "Smith"<br>
‚Ä¢ Duplicate records in your own system: Same person entered twice<br>
<br>
In healthcare, this is called the "Patient Matching Problem." It's so common that there's a whole field (Master Patient Indexing) dedicated to it.<br><br>
<strong>Naive approach (FAILS):</strong><br>
if record1.name == record2.name and record1.dob == record2.dob:<br>
  # Same person<br>
<br>
Result: "John" != "Jonathan" ... incorrectly says different people. WRONG.<br><br>
<strong>BETTER APPROACH ‚Äî Probabilistic Matching (Fellebi distance):</strong><br>
Instead of exact match, calculate a "confidence score" (0-100) that two records are the same person.<br><br>
Factors to compare:<br>
‚Ä¢ Name similarity: Levenshtein distance (John vs. Jonathan)<br>
  levenshtein("John", "Jonathan") = 4 edits needed<br>
  similarity = 1 - (4 / max_len) = 50% match<br>
<br>
‚Ä¢ First name alias detection: "John" is commonly short for "Jonathan"<br>
  alias_match("John", "Jonathan") = 95% match<br>
<br>
‚Ä¢ DOB match: Exact match vs. month/year only vs. age estimate<br>
  "1985-03-15" vs. "03/15/1985" = 100% match (same date)<br>
<br>
‚Ä¢ gender match: Both male = +5 points<br>
<br>
‚Ä¢ Address match: Same zip code = +10 points<br>
<br>
Calculate confidence = (name_similarity + dob_match + gender_match + address_match) / 100<br><br>
Example matching:<br>
Patient A: John Smith, 1985-03-15, M, 90210<br>
Patient B: Jonathan Smith, 03/15/1985, M, 90210<br>
<br>
name_similarity: 95% (aliasing)<br>
dob_match: 100%<br>
gender_match: 100%<br>
address_match: 100%<br>
<br>
confidence = (95 + 100 + 100 + 100) / 4 = 98.75% SAME PERSON<br><br>
<strong>Decision logic:</strong><br>
confidence > 95% => DEFINITE MATCH (auto-merge)<br>
confidence 80-95% => PROBABLE MATCH (ask case manager to confirm)<br>
confidence < 80% => DIFFERENT PEOPLE (create new record)<br><br>
<strong>MindBridge implementation:</strong><br>
from difflib import SequenceMatcher<br>
import Levenshtein<br><br>
def calculate_match_score(record1, record2):<br>
  score = 0<br>
  <br>
  # Name similarity (weight: 40%)<br>
  name_sim = Levenshtein.jaro_winkler(record1.name, record2.name)<br>
  score += name_sim * 0.40<br>
  <br>
  # DOB match (weight: 40%)<br>
  dob_match = 1.0 if record1.dob == record2.dob else 0.0<br>
  score += dob_match * 0.40<br>
  <br>
  # Gender (weight: 10%)<br>
  gender_match = 1.0 if record1.gender == record2.gender else 0.0<br>
  score += gender_match * 0.10<br>
  <br>
  # Zip code (weight: 10%)<br>
  zip_match = 1.0 if record1.zip == record2.zip else 0.0<br>
  score += zip_match * 0.10<br>
  <br>
  return score<br><br>
<strong>Workflow on patient import:</strong><br>
When a new patient is imported (from EHR or CSV):<br>
1. Calculate match_score against all existing patients<br>
2. If top match > 95%: Alert case manager "Possibly duplicate: This might be [John Smith, DOB 1985-03-15]"<br>
3. Case manager reviews and confirms merge<br>
4. If merged: Copy all screening history from old record to new<br><br>
<strong>Edge cases:</strong><br>
1. Married name change: "Jane Doe" marries and becomes "Jane Smith." How do you handle retroactive name changes?<br>
   Solution: Store both names in the database. Match on old + new names.<br>
<br>
2. Name order culturally different: "Yuki Tanaka" (Japanese: last name first) vs. "Tanaka Yuki" (Western order).<br>
   Solution: Allow flexible name field parsing per patient's cultural background.<br>
<br>
3. Multiple birth certificates: Patient has different records under slightly different names (uncommon but happens).<br>
   Solution: Patient can link multiple records to one identity manually.<br><br>
<strong>The industry standard: MPI (Master Patient Index)</strong><br>
Medical centers use MPI ‚Äî a centralized database of patient identities used as the source of truth. Every patient gets a MPI ID that all systems use. This solves matching once at the center.<br><br>
<strong>Interview gold:</strong> "Patient matching is probabilistic, not deterministic. Never merge records automatically based on name alone. Always ask a human to confirm. In healthcare, wrong matches can be lethal."`
  },

  // === SYSTEM DESIGN (3 NEW) ===

  realtime: {
    type: "interview",
    title: "Real-Time Dashboard Updates",
    question: "Design a feature where case managers see real-time updates when another user screens a patient ‚Äî without refreshing the page. How do you implement this?",
    context: "Real-time features are common interview questions. Show you understand WebSockets vs polling tradeoffs.",
    ideal: `<strong>The requirement:</strong><br>
Case Manager A screens Patient X, sets risk to HIGH. Instantly, Case Manager B's dashboard updates to show Patient X as HIGH risk ‚Äî without Case Manager B refreshing the page.<br><br>
<strong>THREE APPROACHES (with tradeoffs):</strong><br><br>
<strong>APPROACH 1 ‚Äî Regular Polling (Frontend asks every N seconds):</strong><br>
setInterval(async () => {<br>
  const patients = await fetch('/api/patients');<br>
  render_dashboard(patients);<br>
}, 5000);  // Check every 5 seconds<br><br>
Pros:<br>
‚Ä¢ Simple to implement<br>
‚Ä¢ No special infrastructure<br>
‚Ä¢ Works with any backend<br><br>
Cons:<br>
‚Ä¢ Latency: 5 seconds (user sees stale data for 5 seconds)<br>
‚Ä¢ Wasteful: Dashboard checks even if nothing changed<br>
‚Ä¢ Database load: 100 case managers √ó 1 query every 5s = 20 queries/second<br>
‚Ä¢ Bad UX: Lag of 5 seconds feels slow<br><br>
<strong>APPROACH 2 ‚Äî Server-Sent Events (SSE) (Server pushes updates one-direction):</strong><br>
const eventSource = new EventSource('/api/updates');<br>
eventSource.addEventListener('patient_screened', (event) => {<br>
  const update = JSON.parse(event.data);  // {patient_id, risk_level}<br>
  update_dashboard_ui(update);<br>
});<br><br>
Backend maintains a long-lived HTTP connection per client:<br>
@app.get("/api/updates")<br>
async def stream_updates(user_id: str):<br>
  async def event_generator():<br>
    while True:<br>
      update = await listen_for_updates(user_id)  # Long polling<br>
      yield f"data: {json.dumps(update)}\\n\\n"<br>
      await asyncio.sleep(0.1)<br>
  return StreamingResponse(event_generator(), media_type="text/event-stream")<br><br>
When screening is created, broadcast to all connected clients:<br>
async def create_screening(patient_id, risk_level):<br>
  # Save to database<br>
  await db.screenings.insert(...):<br>
  # Notify all connected dashboard users<br>
  broadcast({type: 'patient_screened', patient_id, risk_level})<br><br>
Pros:<br>
‚Ä¢ Low latency: Updates arrive within 100ms<br>
‚Ä¢ Efficient: Only sent when data changes<br>
‚Ä¢ Built on HTTP (no new protocols)<br><br>
Cons:<br>
‚Ä¢ Server connection per client (100 users = 100 open connections)<br>
‚Ä¢ Requires async backend (FastAPI supports it)<br><br>
<strong>APPROACH 3 ‚Äî WebSockets (Two-way, true real-time):</strong><br>
Frontend establishes persistent WebSocket connection:<br>
ws = new WebSocket("ws://localhost:8000/ws/updates");<br>
ws.onmessage = (event) => {<br>
  const update = JSON.parse(event.data);<br>
  update_dashboard_ui(update);<br>
};<br><br>
Backend:<br>
from fastapi import WebSocket<br>
@app.websocket("/ws/updates/{user_id}")<br>
async def websocket_endpoint(websocket: WebSocket, user_id: str):<br>
  await websocket.accept()<br>
  try:<br>
    while True:<br>
      # Listen for updates<br>
      update = await listen_for_updates(user_id)<br>
      await websocket.send_json(update)<br>
  except WebSocketDisconnect:<br>
    # Client disconnected, clean up<br>
    pass<br><br>
Pros:<br>
‚Ä¢ True real-time (updates within 50ms)<br>
‚Ä¢ Bidirectional (frontend can also send data without separate request)<br>
‚Ä¢ Efficient: Only sends deltas<br><br>
Cons:<br>
‚Ä¢ More complex infrastructure (WebSocket servers, load balancing)<br>
‚Ä¢ Requires WebSocket support on infrastructure (Railway, Render support it)<br><br>
<strong>MY RECOMMENDATION FOR MINDBRIGDE:</strong><br>
Start with SSE (Approach 2). Here's why:<br>
‚Ä¢ Simple to implement<br>
‚Ä¢ Real enough latency (100ms is imperceptibly fast)<br>
‚Ä¢ Less infrastructure than WebSockets<br>
‚Ä¢ Good enough for healthcare (not a live multiplayer game)<br><br>
Later, if you need <50ms latency (e.g., real-time collaboration on patient notes), move to WebSockets.<br><br>
<strong>Implementation detail ‚Äî broadcast mechanism:</strong><br>
You need a way to notify all connected clients. Use Redis pub/sub:<br><br>
import aioredis<br>
redis = await aioredis.create_redis_pool('redis://localhost')<br><br>
# When screening is created, publish event<br>
async def create_screening(patient_id, risk_level):<br>
  await db.screenings.insert(...)<br>
  await redis.publish('updates', json.dumps({<br>
    'type': 'patient_screened',<br>
    'patient_id': patient_id,<br>
    'risk_level': risk_level<br>
  }))<br><br>
# All connected SSE clients subscribe to this channel<br>
# When event published, all get notified<br><br>
<strong>Interview gold:</strong> "Real-time updates have tradeoffs: polling is simple, SSE is balanced, WebSockets are powerful. Choose based on latency requirements. For healthcare dashboards, SSE is usually the right choice."`
  },

  scaling: {
    type: "interview",
    title: "Scale to 100K Patients",
    question: "MindBridge currently serves 1 clinic with 500 patients. A large hospital network with 100,000 patients wants to onboard. What breaks and how do you fix it?",
    context: "Scaling challenges test systems thinking. Show you can identify bottlenecks before they become incidents.",
    ideal: `<strong>WHAT BREAKS AT 100K PATIENTS (200√ó growth):</strong><br><br>
<strong>1. DATABASE QUERIES SLOW DOWN</strong><br>
Current: SELECT * FROM patients takes 10ms<br>
At 100K: Same query takes 2 seconds (20√ó slower)<br>
Why: No indexes. By default, PostgreSQL scans the entire table.<br>
Fix:<br>
CREATE INDEX idx_patients_clinic ON patients(clinic_id);<br>
CREATE INDEX idx_patients_risk ON patients(risk_level);<br>
CREATE INDEX idx_Screenings_patient ON screenings(patient_id);<br><br>
Query now: 10ms again. Indexes let PostgreSQL skip to the right rows.<br><br>
<strong>2. CONNECTION POOL EXHAUSTED</strong><br>
Pool size: 10 (default)<br>
Current traffic: 10 requests/second. No problems.<br>
At 100K patients: Peak traffic hits 100 requests/second (101 case managers logging in at 9 AM).<br>
Result: 9 of 10 connections in use. Request 11 waits in queue. Then timeouts.<br><br>
Fix:<br>
Increase pool_size=50, max_overflow=50<br>
Now can handle 100 concurrent requests.<br>
Monitor connection usage to avoid surprises.<br><br>
<strong>3. SCREENING LATENCY EXPLODES</strong><br>
Current: Run 1 screening, Claude API takes 5 seconds ‚Üí User sees result in 5 seconds<br>
At 100K: Hospital wants to screen 10,000 NEW patients on Monday morning. 10,000 √ó 5 sec = 50,000 seconds = 14 hours. But they're all submitted at once (queue depth = 10K).<br><br>
Fix:<br>
Make screening async + queue:<br>
POST /api/screenings returns 202 Accepted immediately with task_id<br>
Background Celery worker processes queue of 10K jobs<br>
Case manager polls GET /screenings/task_id for status<br>
When ready: "Your screening is complete, risk level: HIGH"<br><br>
Now 10,000 patients are processed in background over 2 hours (5 concurrent workers), and the API returns instantly.<br><br>
<strong>4. STORAGE EXPLODES</strong><br>
Current: 500 patients √ó average 100KB per patient = 50MB<br>
At 100K: 10GB of data<br>
If you're using Railway or similar: May hit plan limits. Need larger database tier.<br><br>
Hospital records retention: Healthcare often requires 7 years of data retention.<br>
100K patients √ó 100KB √ó 7 years = 70GB<br><br>
Fix:<br>
Upgrade to production-grade database (not personal tier)<br>
Implement data archiving: Move old screenings to archive storage after 1 year (keep quick access for recent data)<br>
Consider separate analytics database for historical reporting<br><br>
<strong>5. AUDIT LOGGING BECOMES A BOTTLENECK</strong><br>
Every patient access = 1 audit log entry (HIPAA requirement)<br>
Current: 500 patients √ó 5 views/day = 2,500 logs/day (negligible)<br>
At 100K: 100K patients √ó 5 views/day = 500K logs/day<br>
500K inserts/day = ~6 inserts/second, not a problem YET<br><br>
At 1M patients: 5M logs/day = 58 inserts/second, OK but growing<br><br>
Fix (preemptive):<br>
Archive audit logs to separate table:<br>
CREATE TABLE audit_log_archive_2024_q1 PARTITION...<br>
Move completed months to archive (read-only)<br>
Keep current month in fast table<br>
Queries on audit_log_2024_q1 still work but don't scan massive log<br><br>
<strong>6. FRONTEND PERFORMANCE</strong><br>
Loading patient list: paginate<br>
Dashboard: Don't load all 100K rows. Load 50 at a time with infinite scroll.<br><br>
<strong>ARCHITECTURE CHANGES (Beyond just scaling):</strong><br><br>
<strong>A. Sharding (if you grow to 1M+ patients):</strong><br>
Instead of 1 database with 1M patients, have 100 databases with 10K each<br>
Route based on clinic_id or patient_id hash<br><br>
<strong>B. Read replicas:</strong><br>
Main database: Writes only<br>
2 read replicas: Dashboard queries (read-only) hit replicas<br>
Eliminates bottleneck of all queries hitting one database<br><br>
<strong>C. Microservices (if you grow to 10M+ patients):</strong><br>
Instead of 1 monolith (API + screening + audit + payment):<br>
- Screening service (isolated, scales independently)<br>
- Patient service (CRUD operations)<br>
- Audit service (logs, immutable)<br>
- each has its own database<br><br>
<strong>PERFORMANCE TARGETS AT SCALE:</strong><br>
Goal: API response < 500ms, even at peak<br>
1K concurrent users<br>
P99 latency < 2 seconds<br><br>
Achieved with:<br>
‚úì Database indexes<br>
‚úì Connection pooling<br>
‚úì Async screening pipeline<br>
‚úì Caching (Redis for reference data)<br>
‚úì CDN for static assets<br>
‚úì Rate limiting (prevent abuse)<br><br>
<strong>Interview gold:</strong> "Scaling isn't one change. It's a series of changes: indexes first, then async/queuing, then sharding. Measure constantly. Fix the actual bottleneck, not imaginary ones. Most startups over-engineer before they have scale problems."`
  },

  failover: {
    type: "interview",
    title: "Database Failover Strategy",
    question: "Your Railway PostgreSQL database crashes at 2 PM. Case managers can't access patient data. What's your disaster recovery plan?",
    context: "High availability is critical for healthcare. Show you've thought about failure modes and recovery procedures.",
    ideal: `<strong>THE DISASTER:</strong><br>
Railway's PostgreSQL server has a hardware failure at 2 PM on Tuesday. Your backend can't connect:<br>
OperationalError: could not translate host name "mindbridge-db.railway.app" to address<br><br>
Result: MindBridge is completely down. Case managers can't log in, can't access patients. If a HIGH-RISK patient tries to get help, the system is offline.<br><br>
This is unacceptable for healthcare. You need a failover strategy.<br><br>
<strong>STRATEGY 1 ‚Äî Automated Database Replication + Failover:</strong><br><br>
<strong>Setup:</strong><br>
Primary: mindbridge-db.railway.app (US-East)<br>
Standby: mindbridge-db-backup.railway.app (US-West)<br><br>
PostgreSQL replication: Primary streams all writes to Standby in real-time.<br>
Standby is read-only but fully synced. Every INSERT/UPDATE on primary appears on standby within milliseconds.<br><br>
<strong>When primary fails:</strong><br>
1. Health check: Backend tries to connect to primary. Fails 3 times.<br>
2. Automatic failover: Standby is promoted to primary (now accepts writes)<br>
3. Application switches: Update application config: DATABASEUR = "mindbridge-db-backup.railway.app"<br>
4. Resume operations: Case managers reconnect (maybe 10-second interruption)<br><br>
Tools that automate this:<br>
‚Ä¢ Patroni (manages failover automatically)<br>
‚Ä¢ PgBouncer (connection pooling with failover built-in)<br>
‚Ä¢ Cloud provider's managed failover (Railway, Render, Digital Ocean provide this)<br><br>
<strong>STRATEGY 2 ‚Äî Active-Active (No downtime, more complex):</strong><br><br>
Two PostgreSQL clusters, both accepting writes. Bidirectional replication.<br>
If primary fails: DOMIcan already writing to secondary. Zero downtime.<br><br>
Challenges: handling write conflicts (if both clusters receive the same INSERT simultaneously). Complex.<br><br>
<strong>STRATEGY 3 ‚Äî Backup & Restore (slower recovery):</strong><br><br>
Take hourly backups of PostgreSQL to cloud storage (S3, Google Cloud Storage):<br>
11 AM: Full backup (complete database snapshot)<br>
2 PM: Database fails<br>
2:05 PM: Database is restored from 11 AM snapshot<br>
2:15 PM: Service restored (15-minute downtime)<br><br>
Application data loss: 1 hour (1 PM-2 PM screzenings lost)<br><br>
Better than nothing, but worse than replication.<br><br>
<strong>MY RECOMMENDATION ‚Äî Failover with Patroni (Middle ground):</strong><br><br>
Using Patroni + PostgreSQL managed service on Railway/Render:<br><br>
<strong>Backup strategy (RPO = Recovery Point Objective):</strong><br>
- RPO: How much data can you afford to lose? Healthcare: <5 minutes<br>
- Replication stream (synchronous): Primary waits for standby to confirm write before ACKing to app<br>
- Result: Zero data loss from primary failure<br><br>
<strong>Recovery time (RTO = Recovery Time Objective):</strong><br>
- RTO: How long can you afford to be down? Healthcare: <10 minutes<br>
- Automatic failover: Standby promoted within 1 minute<br>
- Application reconnection: Connections reset, app reconnects within 2 minutes<br>
- Result: ~3 minutes downtime<br><br>
<strong>Implementation:</strong><br>
PostgreSQL Primary (sync replication) ‚Üí PostgreSQL Standby<br>
<br>
Connection string with automatic failover:<br>
postgresql://user:pass@primary,backup/mindbridge?sslmode=require&target_session_attrs=read-write<br><br>
This connection string tries primary first. If it fails, automatically connects to backup.<br><br>
<strong>Verification & drills:</strong><br>
Every quarter, simulate: Kill the primary database server. Confirm:<br>
1. Standby was promoted (monitoring shows "now primary")<br>
2. Application reconnected automatically<br>
3. Case managers could access their data<br>
4. No data loss since last transaction<br><br>
Document exact steps taken + time to recovery. If it took 15 minutes manually, work on automation.<br><br>
<strong>Bonus ‚Äî Async Standby Replication for Different Regions:</strong><br><br>
If you want geographic redundancy (survive full region outage):<br><br>
Primary: US-East (Railway)<br>
Standby Sync: US-East (same region, fast failover)<br>
Standby Async: EU-West (different region, slower)<br><br>
US-East fails: Standby Sync takes over (fast)<br>
US-East + EU both fail: Business is over anyway (unlikely)<br><br>
You generally don't use EU-West for normal failover (latency), but it's there as insurance.<br><br>
<strong>Monitoring & Alerting:</strong><br>
Continuous health check:<br>
SELECT 1;  # Simple connectivity test, every 10 seconds<br><br>
If 3 failed attempts ‚Üí Alert ops immediately<br>
If 10 failed attempts ‚Üí Trigger automatic failover<br><br>
Alert channels: Email + Slack + Page on-call engineer<br><br>
<strong>Interview gold:</strong> "Healthcare systems can't be down. Plan for failure before it happens. Replication + automatic failover means case managers never notice a database failure. RPO < 5 min, RTO < 10 min. Drill it quarterly so you're confident it actually works."`
  },

  frontend_arch: {
    type: "interview",
    title: "Walk Through MindBridge Frontend Architecture",
    question: "Walk me through the MindBridge frontend architecture. How is it structured, what decisions did you make, and why?",
    context: "This is your home turf. You built it. Nobody knows it better than you. Use the STAR framework: Structure ‚Üí Approach ‚Üí Result.",
    ideal: `<strong>STRUCTURE:</strong> "MindBridge uses Next.js 14 with the App Router for the frontend, deployed on Vercel. Three pages: Login (app/page.tsx), Dashboard (app/dashboard/page.tsx), and Patient Detail (app/patients/[id]/page.tsx)."<br><br>
<strong>ARCHITECTURE DECISIONS:</strong><br>
"I used dynamic routing with bracket notation for the patient detail view ‚Äî [id] matches any patient UUID from the database. This is Next.js App Router file-based routing: every folder inside /app becomes a URL segment, every page.tsx becomes a page."<br><br>
"The login page is a Client Component using 'use client' and useRouter for post-submit redirect. The dashboard and patient detail are Server Components since they just display data ‚Äî keeping them server-side means faster loads and better SEO."<br><br>
"Styling is Tailwind CSS throughout ‚Äî utility classes gave me a consistent design system without a dedicated designer. The constraint of predefined values (slate-900, blue-600) actually produces more consistent results than freeform CSS."<br><br>
<strong>HIPAA DESIGN CHOICE:</strong><br>
"I added a demo environment banner to make clear all patient data is fictional. In production, I'd add NextAuth.js middleware that blocks /dashboard and /patients/* without a valid session ‚Äî unauthenticated users redirect to login automatically."<br><br>
<strong>RESULT:</strong><br>
"The frontend is live at mind-bridge-health-ai.vercel.app. Every git push to main auto-deploys via Vercel's CI/CD pipeline in under 60 seconds. Employers can click the live demo link right now."<br><br>
<strong>WHY THIS ANSWER WORKS:</strong> Shows architecture thinking, explains tradeoffs, mentions HIPAA awareness, ends with live evidence.`
  },

  nextjs_vs_react: {
    type: "interview",
    title: "Why Next.js Over Plain React?",
    question: "Why did you choose Next.js for MindBridge instead of plain React with Vite or Create React App?",
    context: "Show you understand the tradeoffs. This isn't about memorizing features ‚Äî it's about making deliberate decisions.",
    ideal: `<strong>Three reasons Next.js was the right choice for MindBridge:</strong><br><br>
<strong>1. Server-Side Rendering for Healthcare:</strong><br>
Patient dashboards need to load fast. Server Components render on the server and send HTML to the browser ‚Äî no waiting for JavaScript to load before seeing data. For a clinician checking a patient before an appointment, every second matters. Plain React would send an empty HTML shell, then load JS, then fetch data, then render ‚Äî three round trips. Next.js does it in one.<br><br>
<strong>2. File-Based Routing (Zero Config):</strong><br>
With plain React + React Router, I'd write routing configuration manually. With Next.js, creating app/patients/[id]/page.tsx automatically creates the /patients/:id route. For a solo developer moving fast, that's hours saved per week.<br><br>
<strong>3. Vercel Integration:</strong><br>
Next.js is made by the same team as Vercel. Zero-config deployment, automatic CI/CD, edge network ‚Äî push to GitHub, live in 60 seconds. With plain React on a custom server, that's a week of DevOps work.<br><br>
<strong>When plain React would be better:</strong><br>
If MindBridge were a highly interactive app (think Google Docs, real-time collaboration), where SEO doesn't matter and all rendering is client-side anyway, plain React + Vite would be faster to build and lighter to run.<br><br>
<strong>Interview gold:</strong> "I chose Next.js not because it's popular, but because the specific requirements ‚Äî fast loads for clinical workflows, quick deployment, file-based routing for a small team ‚Äî made it the right tool."`
  },

  add_auth: {
    type: "interview",
    title: "Add Authentication to Protect the Dashboard",
    question: "The MindBridge dashboard is currently publicly accessible. How would you add proper authentication to protect patient data?",
    context: "This tests both technical implementation knowledge AND HIPAA awareness. Show you think about security as architecture, not afterthought.",
    ideal: `<strong>CURRENT STATE:</strong> Any URL like /dashboard is accessible without logging in. Fine for portfolio demo with fake data, unacceptable for production with real PHI.<br><br>
<strong>IMPLEMENTATION PLAN ‚Äî NextAuth.js:</strong><br><br>
<strong>Step 1 ‚Äî Install:</strong> npm install next-auth<br><br>
<strong>Step 2 ‚Äî Create auth handler:</strong><br>
File: app/api/auth/[...nextauth]/route.ts<br>
This single file handles all auth routes automatically: /api/auth/signin, /api/auth/callback, /api/auth/session.<br><br>
Configure CredentialsProvider to validate against FastAPI backend:<br>
CredentialsProvider({ async authorize(credentials) {<br>
  const res = await fetch('https://api.mindbridge.railway.app/auth/verify', { method: 'POST', body: JSON.stringify(credentials) });<br>
  if (res.ok) return await res.json();<br>
  return null;<br>
}})<br><br>
<strong>Step 3 ‚Äî Add middleware (the key piece):</strong><br>
File: middleware.ts at project root<br>
export { default } from 'next-auth/middleware';<br>
export const config = { matcher: ['/dashboard/:path*', '/patients/:path*'] };<br><br>
This runs before EVERY request to /dashboard or /patients. Unauthenticated users are redirected to /login automatically. No code changes needed in the page components.<br><br>
<strong>Step 4 ‚Äî Access session in components:</strong><br>
const session = await getServerSession(); // Server-side, no API call<br>
if (!session) redirect('/'); // Belt and suspenders<br><br>
<strong>HIPAA-SPECIFIC ADDITIONS:</strong><br>
- JWT tokens expire after 8 hours (one clinical shift)<br>
- Failed login attempts logged to audit_log<br>
- Session invalidated on logout (can't reuse old tokens)<br>
- MFA required for admin roles<br><br>
<strong>Interview gold:</strong> "Authentication in healthcare isn't just username/password. It's session expiry aligned with shift lengths, MFA for privileged roles, and audit logging of every login and logout. That's what distinguishes a HIPAA-compliant system from a generic web app."`
  },

  vercel_build_fail: {
    type: "simulation",
    title: "Vercel Build Fails on Deploy",
    question: "You push to GitHub and Vercel's deployment fails with: 'Error: Build failed. Exit code 1'. The site reverts to the previous version. How do you debug it?",
    context: "This is a real scenario you'll face. Show systematic debugging, not panic.",
    ideal: `<strong>STEP 1 ‚Äî Read the build logs (always start here):</strong><br>
Go to Vercel Dashboard ‚Üí Deployments ‚Üí click the failed deployment ‚Üí View Build Logs.<br>
Scroll to the RED error. It will tell you exactly what failed.<br>
Don't guess ‚Äî read the error.<br><br>
<strong>COMMON NEXT.JS BUILD FAILURES:</strong><br><br>
<strong>TypeScript error:</strong><br>
"Type 'string' is not assignable to type 'number'"<br>
Fix: Your type definition doesn't match what you're passing. Find the line number in the error, fix the type.<br><br>
<strong>Missing module:</strong><br>
"Cannot find module 'some-package'"<br>
Fix: Package installed locally but not in package.json. Run: npm install some-package, commit package.json and package-lock.json.<br><br>
<strong>Next.js 15 async params (you've already seen this one):</strong><br>
"Error: params.id is undefined"<br>
Fix: Add async + await params as Promise. The exact bug you fixed today.<br><br>
<strong>Environment variable missing:</strong><br>
"process.env.NEXT_PUBLIC_API_URL is undefined"<br>
Fix: Variable exists in .env.local but wasn't added to Vercel's environment variables dashboard.<br>
Go to: Vercel ‚Üí Project ‚Üí Settings ‚Üí Environment Variables ‚Üí Add it.<br><br>
<strong>STEP 2 ‚Äî Reproduce locally:</strong><br>
npm run build<br>
If it fails locally, you can fix it faster. If it passes locally but fails on Vercel, it's an environment variable or dependency issue.<br><br>
<strong>STEP 3 ‚Äî Fix and push:</strong><br>
Once fixed locally, push to GitHub. Vercel auto-triggers a new build. Previous version stays live until new build succeeds.<br><br>
<strong>The safety net:</strong><br>
Vercel NEVER takes down your live site for a failed build. Previous deployment stays live. Case managers continue working while you fix the error. That's why CI/CD is safe for production.`
  },

  nextjs_404: {
    type: "simulation",
    title: "Dynamic Route Returns 404",
    question: "You create app/patients/id/page.tsx and navigate to /patients/1 ‚Äî you get a 404. What's wrong and how do you fix it?",
    context: "This is the exact bug you hit today. Own it ‚Äî you know the answer cold.",
    ideal: `<strong>THE CAUSE:</strong><br>
The folder is named 'id' (no brackets) instead of '[id]' (with brackets).<br><br>
In Next.js App Router, square brackets are REQUIRED for dynamic segments:<br>
app/patients/id/page.tsx ‚Üí matches ONLY the literal URL /patients/id (not useful)<br>
app/patients/[id]/page.tsx ‚Üí matches /patients/1, /patients/2, /patients/any-uuid<br><br>
<strong>THE FIX:</strong><br>
Rename the folder from 'id' to '[id]' ‚Äî brackets included.<br>
On Windows: Right-click ‚Üí Rename ‚Üí type [id]<br>
Or in terminal: mv app/patients/id app/patients/[id]<br><br>
<strong>SECOND ISSUE ‚Äî Next.js 15 async params:</strong><br>
Even with the correct folder name, Next.js 15 requires params to be awaited:<br><br>
WRONG (Next.js 14 style):<br>
export default function Page({ params }: { params: { id: string } }) {<br>
  const patient = data[params.id]; // params.id is undefined in Next.js 15<br>
}<br><br>
CORRECT (Next.js 15 style):<br>
export default async function Page({ params }: { params: Promise<{ id: string }> }) {<br>
  const { id } = await params; // Must await the Promise<br>
  const patient = data[id];<br>
}<br><br>
<strong>How to remember:</strong><br>
Next.js 15 made params async to support streaming and server components better. If you see 404 on dynamic routes, check: (1) brackets in folder name, (2) async/await on params.<br><br>
<strong>Interview gold:</strong> "I hit this exact bug in production on Day 1 of my frontend build. Fixed it in 2 minutes once I understood the pattern. Now I always check folder names and Next.js version when dynamic routes return 404."`,
  },

  server_client: {
    type: "concept",
    title: "Server vs Client Components in Next.js",
    question: "Explain the difference between Server Components and Client Components in Next.js. When does MindBridge use each?",
    context: "This is one of the most common Next.js interview questions. Show you understand the WHY, not just the syntax.",
    ideal: `<strong>SERVER COMPONENTS (default in Next.js App Router):</strong><br>
Render on the server. HTML is sent to the browser. JavaScript is NOT sent to the browser for server components.<br><br>
Characteristics:<br>
- Can access databases, file system, secrets directly<br>
- Cannot use useState, useEffect, onClick, onChange<br>
- Cannot use browser APIs (window, document, localStorage)<br>
- Faster: Less JavaScript shipped to browser<br>
- Better SEO: Content is in the HTML, search engines can read it<br><br>
<strong>CLIENT COMPONENTS ('use client' at top of file):</strong><br>
Render in the browser. Full React interactivity available.<br><br>
Characteristics:<br>
- CAN use useState, useEffect, onClick, useRouter<br>
- CAN use browser APIs<br>
- Cannot access server-only resources directly (database, secrets)<br>
- More JavaScript shipped to browser<br><br>
<strong>MindBridge examples:</strong><br><br>
Login page = CLIENT COMPONENT because:<br>
'use client'<br>
import { useRouter } from 'next/navigation';<br>
// Needs useRouter for redirect after form submit<br>
// Needs onClick for the Sign In button<br><br>
Dashboard = SERVER COMPONENT because:<br>
// Just displays data ‚Äî no interactivity needed<br>
// Could fetch from database directly (skipping API layer)<br>
// Faster, no JS overhead<br><br>
Patient Detail = SERVER COMPONENT because:<br>
// Just renders patient data<br>
// async function with await params<br>
// No user interactions needed<br><br>
<strong>Rule of thumb:</strong><br>
Start with Server Component (default). Add 'use client' only when you need: onClick, onChange, useState, useEffect, useRouter, or any browser API.<br><br>
<strong>Interview gold:</strong> "I default to Server Components for performance. Each Client Component adds JavaScript to the browser bundle. In a healthcare app where clinicians may be on older hospital computers, minimizing JavaScript = better performance = faster patient care."`
  },

  cicd_concept: {
    type: "concept",
    title: "CI/CD Pipeline in MindBridge",
    question: "Explain CI/CD and walk me through exactly how MindBridge's pipeline works from git push to live deployment.",
    context: "CI/CD is a must-know for any engineering role. Show you've lived it, not just read about it.",
    ideal: `<strong>What CI/CD means:</strong><br>
CI (Continuous Integration): Every code push automatically builds and tests the code.<br>
CD (Continuous Deployment): If the build passes, automatically deploy to production.<br><br>
The goal: Remove manual steps from deployment. No more "can you deploy this for me?" ‚Äî push to main, it's live.<br><br>
<strong>MindBridge's exact CI/CD pipeline:</strong><br><br>
<strong>STEP 1 ‚Äî Developer pushes code:</strong><br>
git add . && git commit -m "Add demo banner" && git push origin main<br>
Git push takes ~2 seconds.<br><br>
<strong>STEP 2 ‚Äî GitHub receives the push:</strong><br>
GitHub stores the new commit. Triggers a webhook notification to Vercel: "New code pushed to fidelis-emmanuel/MindBridge-Health-AI main branch."<br><br>
<strong>STEP 3 ‚Äî Vercel starts build:</strong><br>
Vercel clones the repository. Navigates to Root Directory: frontend/patient-portal. Runs: npm install (installs dependencies). Runs: npm run build (compiles Next.js for production). Checks for TypeScript errors, missing modules, any build failures.<br><br>
<strong>STEP 4a ‚Äî Build succeeds:</strong><br>
Vercel deploys compiled files to its global edge network (100+ locations worldwide). Updates the production URL (mind-bridge-health-ai.vercel.app) to serve new version. Total time: ~60 seconds from git push to live.<br><br>
<strong>STEP 4b ‚Äî Build fails:</strong><br>
Vercel keeps the PREVIOUS version live. No downtime. Developer receives email: "Build failed." Developer reads logs, fixes the error, pushes again.<br><br>
<strong>Why this matters for healthcare:</strong><br>
"Deploying broken code to a healthcare system could prevent case managers from accessing patient data or show incorrect risk levels. CI/CD means broken code NEVER reaches production ‚Äî the pipeline is the safety net."<br><br>
<strong>What we'd add in production:</strong><br>
Automated tests run in CI before deployment: npm test. If tests fail, build fails, code doesn't deploy. This catches regressions before real users see them.<br><br>
<strong>Interview gold:</strong> "CI/CD isn't just convenience ‚Äî it's patient safety. If a deployment breaks MindBridge's risk assessment display, case managers might miss a HIGH-risk patient. The pipeline prevents that."`
  },

  mindbridge_e2e: {
    type: "concept",
    title: "MindBridge End-to-End System Walkthrough",
    question: "Walk me through the complete MindBridge Health AI system ‚Äî from the moment a case manager opens the browser to the moment they see a patient's risk score. Every layer.",
    context: "This is your home turf question. You built every layer of this. An interviewer asking this is giving you 5 minutes of free talking time. Use it.",
    ideal: `<strong>THE FULL STACK JOURNEY:</strong><br><br>
<strong>LAYER 1 ‚Äî Browser (Next.js Frontend on Vercel):</strong><br>
Case manager navigates to mind-bridge-health-ai.vercel.app. Vercel's edge network (100+ locations globally) serves the Next.js app from the nearest server. Login page renders ‚Äî Server Component sends HTML directly, no JS loading needed.<br><br>
<strong>LAYER 2 ‚Äî Authentication:</strong><br>
Case manager enters credentials. 'use client' login component triggers useRouter. POST /api/auth/verify sent to FastAPI backend. FastAPI checks email against PostgreSQL users table, bcrypt.verify() checks password hash (plain passwords never stored). JWT token issued, stored in httpOnly cookie (XSS-proof). Case manager is now authenticated.<br><br>
<strong>LAYER 3 ‚Äî Dashboard Load:</strong><br>
Dashboard page (Server Component) loads. GET /api/patients sent to FastAPI with Bearer JWT token. FastAPI middleware validates JWT, extracts clinic_id. PostgreSQL Row-Level Security + WHERE clinic_id = user.clinic_id ‚Äî case manager sees ONLY their clinic's patients. Response: 10 patients with risk levels, diagnoses, last assessment dates.<br><br>
<strong>LAYER 4 ‚Äî Risk Screening:</strong><br>
Case manager clicks "Screen Patient" for Marcus Thompson. POST /api/screenings sent to FastAPI. FastAPI validates JWT (authenticated) and role (has 'analyst' permission). Patient data fetched from PostgreSQL. Structured prompt sent to Claude API: medication_adherence, appointments_missed, crisis_calls_30days, diagnosis. Claude returns: risk_level=HIGH, primary_factor="Medication non-adherence", action="Immediate outreach". ACID transaction writes: screening result + patient risk update + audit log entry ‚Äî all three succeed or none do.<br><br>
<strong>LAYER 5 ‚Äî HIPAA Compliance (runs on every request):</strong><br>
Every API call logs to immutable audit_log: user_id, patient_id, action, timestamp, IP. Encryption at rest (AES-256 PostgreSQL volumes) and in transit (TLS 1.3). JWT expires after 8 hours ‚Äî aligns with clinical shift length.<br><br>
<strong>LAYER 6 ‚Äî Report Generation:</strong><br>
Case manager clicks "Generate Report." Python-docx creates Word document. openpyxl creates Excel spreadsheet. ReportLab creates PDF. All three formats generated from same data. Reports saved to /reports folder (excluded from git by .gitignore ‚Äî HIPAA compliance).<br><br>
<strong>THE TECH STACK SUMMARY:</strong><br>
Frontend: Next.js 14 (Vercel) ‚Üí FastAPI backend (Railway) ‚Üí PostgreSQL 17 (Railway) ‚Üí Claude AI (Anthropic) ‚Üí Multi-format reports<br><br>
<strong>Interview gold:</strong> "I built every layer of this system, from database schema to frontend components. The domain expertise from 10 years in behavioral health shaped every architectural decision ‚Äî the alert thresholds, the HIPAA audit patterns, the report formats. That's not something you get from a computer science degree."`
  },

  econnrefused: {
    type: "simulation",
    title: "Debug ECONNREFUSED Error",
    question: "Your Next.js API route returns: 'AggregateError: ECONNREFUSED'. The database credentials look correct. Walk me through your debugging process step by step.",
    context: "This is a real error you encountered today. Own it ‚Äî you know exactly what caused it and how to fix it.",
    ideal: `<strong>ECONNREFUSED means:</strong><br>
The connection was actively refused by the target server. Your code reached the right address but nothing answered. Not a credentials problem ‚Äî a networking problem.<br><br>
<strong>STEP 1 ‚Äî Check the URL format:</strong><br>
Print the first 30 characters of the database URL:<br>
console.log("DB URL prefix:", process.env.DATABASE_URL?.substring(0, 30));<br><br>
This reveals if the URL is even being read, and what host it's pointing to.<br><br>
<strong>STEP 2 ‚Äî Identify internal vs public URL:</strong><br>
Two types of Railway database URLs:<br>
- Internal: postgres.railway.internal:5432 ‚Äî ONLY works inside Railway's network<br>
- Public: switchback.proxy.rlwy.net:56330 ‚Äî works from anywhere<br><br>
If you're running locally or on Vercel, you MUST use the public URL. The internal URL is for Railway service-to-service communication only.<br><br>
<strong>STEP 3 ‚Äî Check .env.local location:</strong><br>
Next.js only reads .env.local from the project root ‚Äî the same folder as package.json.<br>
If .env.local is in the wrong directory (e.g., the repo root instead of frontend/patient-portal), Next.js never reads it. The environment variable is undefined. The connection fails.<br><br>
<strong>STEP 4 ‚Äî Restart the dev server:</strong><br>
Next.js reads .env.local ONLY on startup. If you change the file while the server is running, the old value is still in memory.<br>
Fix: Ctrl+C ‚Üí npm run dev ‚Äî always restart after changing .env.local.<br><br>
<strong>STEP 5 ‚Äî Verify SSL config:</strong><br>
Railway requires SSL. Add to Pool config:<br>
ssl: { rejectUnauthorized: false }<br><br>
Without this, Railway rejects the connection even with correct credentials.<br><br>
<strong>Root causes in order of likelihood:</strong><br>
1. Wrong URL (internal vs public) ‚Äî most common<br>
2. .env.local in wrong directory<br>
3. Dev server not restarted after .env.local change<br>
4. Missing SSL config<br><br>
<strong>Interview gold:</strong> "ECONNREFUSED is a network error, not a credentials error. The first question is always: can this machine reach that host? Internal Railway URLs are invisible from outside Railway's network ‚Äî that's by design for security."`
  },

  gitguardian: {
    type: "simulation",
    title: "GitGuardian: Exposed Credentials Alert",
    question: "You receive an email from GitGuardian: 'PostgreSQL URI exposed in your GitHub repository fidelis-emmanuel/MindBridge-Health-AI'. The repo was made public yesterday. What do you do in the next 30 minutes?",
    context: "This happened to you today. You handled it correctly. Now explain it as if teaching a junior developer.",
    ideal: `<strong>STEP 1 ‚Äî Assess severity immediately (2 minutes):</strong><br>
How long was the repo public? The shorter the window, the lower the risk.<br>
What was exposed? PostgreSQL connection string = full database access including all patient data.<br>
Is the database in production with real patient data? If yes, treat as critical breach.<br><br>
<strong>STEP 2 ‚Äî Rotate the credential immediately (5 minutes):</strong><br>
Go to Railway ‚Üí Postgres ‚Üí Database tab ‚Üí Config ‚Üí Regenerate Password.<br>
This invalidates the exposed password instantly ‚Äî even if someone already copied it, it no longer works.<br>
Do this BEFORE anything else. Rotation is the fastest way to close the security window.<br><br>
<strong>STEP 3 ‚Äî Remove from code (10 minutes):</strong><br>
Find every file with the hardcoded URL:<br>
git grep -r "postgresql://" ec9c774<br><br>
Replace hardcoded URL with environment variable:<br>
# REMOVE:<br>
DATABASE_PUBLIC_URL = "postgresql://postgres:PASSWORD@host:port/railway"<br>
# REPLACE WITH:<br>
import os<br>
DATABASE_PUBLIC_URL = os.environ.get("DATABASE_PUBLIC_URL")<br><br>
Commit and push immediately:<br>
git commit -m "Security: Remove hardcoded database credentials"<br>
git push<br><br>
<strong>STEP 4 ‚Äî Clean git history (15 minutes):</strong><br>
The credential is now gone from current code but still visible in old commits. Anyone can run git log and find it.<br>
pip install git-filter-repo<br>
git filter-repo --path scripts/generate_railway_report.py --invert-paths<br>
git push origin main --force<br><br>
Force push rewrites history. The old commits with credentials are permanently removed from GitHub.<br><br>
<strong>STEP 5 ‚Äî Verify (5 minutes):</strong><br>
Try connecting with the OLD password. Should fail with authentication error.<br>
Check GitHub ‚Äî search the repo for the old password string. Should return zero results.<br><br>
<strong>HIPAA implications:</strong><br>
If this were a production database with real patient PHI:<br>
- Document the incident: what was exposed, when, for how long<br>
- Assess if PHI was accessed (check database access logs)<br>
- If PHI was accessed by unauthorized party: 72-hour breach notification rule applies<br>
- Notify patients and HHS within 72 hours<br><br>
<strong>Prevention going forward:</strong><br>
- Never hardcode credentials ‚Äî always os.environ.get()<br>
- Add .env* to .gitignore before first commit<br>
- Use git-secrets or similar pre-commit hooks to block credential commits<br>
- Review .gitignore before making any repo public<br><br>
<strong>Interview gold:</strong> "I handled a real credential exposure during my MindBridge project. Detected by GitGuardian, rotated within 5 minutes, removed from code, cleaned git history with git-filter-repo. Total resolution: under 30 minutes. The key is rotating first ‚Äî that closes the security window while you fix the code."`
  },

  fullstack_connect: {
    type: "interview",
    title: "Walk Through Connecting Frontend to Database",
    question: "Walk me through how you connected the MindBridge Next.js frontend to the Railway PostgreSQL database. What decisions did you make and why?",
    context: "This is a Day 12 achievement. You built the full connection today. Own every architectural decision.",
    ideal: `<strong>THE ARCHITECTURE DECISION:</strong><br>
Two options to connect Next.js to PostgreSQL:<br>
Option A: Next.js ‚Üí FastAPI backend ‚Üí PostgreSQL (traditional full-stack)<br>
Option B: Next.js Server Component ‚Üí PostgreSQL directly (simpler for portfolio)<br><br>
I chose Option B because FastAPI wasn't deployed on Railway yet ‚Äî only the database was. Server Components can securely query PostgreSQL directly because they run on the server, never in the browser. No credentials are exposed to the client.<br><br>
<strong>STEP 1 ‚Äî Install PostgreSQL client:</strong><br>
npm install pg && npm install --save-dev @types/pg<br>
The pg package gives Next.js the ability to speak PostgreSQL protocol directly.<br><br>
<strong>STEP 2 ‚Äî Create the API route:</strong><br>
app/api/patients/route.ts ‚Äî a Next.js API route that queries Railway and returns JSON.<br>
Used Pool with ssl: { rejectUnauthorized: false } for Railway's SSL requirement.<br><br>
<strong>STEP 3 ‚Äî Environment variables (the HIPAA lesson):</strong><br>
Created .env.local in the patient-portal directory (not the repo root ‚Äî that was the first bug).<br>
Added DATABASE_URL with the Railway PUBLIC URL (not the internal URL ‚Äî that was the second bug).<br>
Restarted the dev server after changing .env.local ‚Äî Next.js only reads it on startup.<br><br>
<strong>STEP 4 ‚Äî Move to Server Component:</strong><br>
The API route used localhost:3000 which doesn't exist on Vercel. Fixed by querying PostgreSQL directly in the Server Component ‚Äî no fetch call needed. Server Components run on the server, so they connect directly to the database.<br><br>
<strong>STEP 5 ‚Äî Deploy to Vercel:</strong><br>
Added DATABASE_URL to Vercel's Environment Variables dashboard. Redeployed. Live dashboard now shows real Railway patients.<br><br>
<strong>Result:</strong><br>
mind-bridge-health-ai.vercel.app/dashboard pulls live patient data from Railway PostgreSQL. The full stack is connected: Browser ‚Üí Vercel ‚Üí Next.js Server Component ‚Üí Railway PostgreSQL.<br><br>
<strong>Interview gold:</strong> "The decision to query PostgreSQL directly in Server Components is only safe because Server Components never run in the browser. The DATABASE_URL secret never leaves the server. That's the security model ‚Äî and it's why defaulting to Server Components is the right architectural choice."`
  },

  env_vars: {
    type: "concept",
    title: "Environment Variables ‚Äî Local vs Production",
    question: "Explain the difference between .env.local, environment variables in Vercel, and hardcoded credentials. Why does each exist and when do you use each?",
    context: "You learned this the hard way today. Security and deployment concepts combined.",
    ideal: `<strong>THE SPECTRUM (least to most secure):</strong><br><br>
<strong>WORST ‚Äî Hardcoded in source code:</strong><br>
DATABASE_URL = "postgresql://postgres:PASSWORD@host/db"<br><br>
Problem: Committed to git. If repo is ever public (accidentally or intentionally), credentials are exposed. GitGuardian detected this in MindBridge within 24 hours of the repo going public.<br>
Never do this for any real credentials.<br><br>
<strong>GOOD ‚Äî .env.local (local development only):</strong><br>
File named .env.local in your project directory.<br>
Add .env* to .gitignore ‚Äî file is never committed to git.<br>
Next.js reads it automatically on startup (not hot-reloaded ‚Äî must restart server).<br>
Access in code: process.env.DATABASE_URL<br><br>
Rules:<br>
- Must be in the same directory as package.json<br>
- Never commit it<br>
- Only works locally ‚Äî Vercel cannot read your local files<br>
- Restart dev server after every change<br><br>
<strong>PRODUCTION ‚Äî Environment variables in Vercel dashboard:</strong><br>
Go to Vercel ‚Üí Project ‚Üí Settings ‚Üí Environment Variables.<br>
Add DATABASE_URL with the real value.<br>
Vercel bakes this into the build at deploy time.<br>
Access in code: same ‚Äî process.env.DATABASE_URL<br><br>
Key insight: The code is identical whether running locally or on Vercel. The ENVIRONMENT provides the right value in each context. That's the entire point of environment variables.<br><br>
<strong>NEXT_PUBLIC_ prefix (special case):</strong><br>
Variables without NEXT_PUBLIC_ are server-only ‚Äî never sent to the browser.<br>
Variables WITH NEXT_PUBLIC_ are included in the browser bundle ‚Äî visible to anyone.<br>
DATABASE_URL = server only (correct ‚Äî never expose database credentials to browser)<br>
NEXT_PUBLIC_API_URL = browser-safe (public API URLs are fine)<br><br>
<strong>The .env.local location bug (Day 12 lesson):</strong><br>
Repo root: E:\\MindBridge Health Care\\.env.local ‚Üê Next.js CANNOT see this<br>
Project root: E:\\MindBridge Health Care\\frontend\\patient-portal\\.env.local ‚Üê Next.js reads this<br><br>
Next.js looks for .env.local relative to the directory where package.json lives. Always put it there.<br><br>
<strong>Interview gold:</strong> "Environment variables solve two problems: security (credentials not in code) and flexibility (different values in dev vs production without changing code). The pattern is always the same: os.environ.get() in Python, process.env.VARIABLE in Next.js. The deployment platform provides the actual values."`
  },

  nextauth_concept: {
    type: "concept",
    title: "NextAuth.js Deep Dive",
    question: "Explain NextAuth.js ‚Äî what it is, what it handles automatically, and how MindBridge uses it.",
    context: "Authentication is one of the most common interview topics. Show you understand it at the architectural level, not just 'I installed a library.'",
    ideal: `<strong>What NextAuth.js is:</strong><br>
NextAuth.js is a complete authentication solution for Next.js. It handles everything you'd otherwise build manually: JWT signing and verification, session management, CSRF protection, secure cookie handling, OAuth provider integration, and credential-based login.<br><br>
<strong>What it handles automatically:</strong><br>
- JWT token signing with NEXTAUTH_SECRET<br>
- httpOnly cookie storage (XSS-proof)<br>
- Session refresh and expiry<br>
- CSRF token generation<br>
- Callback URL validation<br>
- All auth API routes via [...nextauth] catch-all<br><br>
<strong>Three files in MindBridge:</strong><br>
1. app/api/auth/[...nextauth]/route.ts ‚Äî The auth handler. Configures providers, session strategy, JWT callbacks. CredentialsProvider validates demo@mindbridge.health / MindBridge2026! and returns user object with role.<br><br>
2. middleware.ts ‚Äî Protects routes at the edge using withAuth. Matcher: ['/dashboard/:path*', '/patients/:path*']. Unauthenticated requests redirect to login before page component ever runs.<br><br>
3. app/page.tsx ‚Äî Login form calls signIn('credentials', { redirect: false }). Checks result.ok ‚Äî success pushes to /dashboard, failure shows error message.<br><br>
<strong>HIPAA-specific configuration:</strong><br>
- maxAge: 8 * 60 * 60 ‚Äî 8 hours, one clinical shift<br>
- strategy: 'jwt' ‚Äî stateless tokens, no database session table needed<br>
- httpOnly cookies ‚Äî session token invisible to JavaScript<br><br>
<strong>Interview gold:</strong> "I chose NextAuth over building auth from scratch because security primitives are easy to get wrong. NextAuth's JWT signing, CSRF protection, and cookie security are battle-tested. My job is to configure it correctly for healthcare requirements, not reinvent it."`
  },

  middleware_concept: {
    type: "concept",
    title: "Next.js Middleware ‚Äî How Route Protection Works",
    question: "Explain exactly how Next.js middleware protects routes. What runs, when, and what happens to unauthenticated requests?",
    context: "Understanding middleware execution order is important for system design interviews. Show you know what happens at the edge.",
    ideal: `<strong>What middleware is:</strong><br>
Middleware runs at the edge ‚Äî before a request reaches any page component, API route, or cached content. It intercepts every matching request and can redirect, rewrite, or add headers before anything else executes.<br><br>
<strong>Execution order:</strong><br>
1. Browser sends GET /dashboard<br>
2. Next.js checks: does middleware.ts match this path?<br>
3. matcher: ['/dashboard/:path*'] ‚Äî YES, this matches<br>
4. withAuth runs: checks for valid NextAuth session cookie<br>
5a. Cookie valid ‚Üí request passes through to dashboard page<br>
5b. Cookie missing/expired ‚Üí redirect to signIn page (/) immediately<br>
6. Dashboard page component never executes for unauthenticated requests<br><br>
<strong>Why this matters for security:</strong><br>
Without middleware, you'd need to add session checks to every page component individually. One missed check = exposed patient data. Middleware is a single enforcement point ‚Äî impossible to forget.<br><br>
<strong>The matcher config:</strong><br>
export const config = {<br>
  matcher: ['/dashboard/:path*', '/patients/:path*']<br>
}<br><br>
:path* means "match this route and all sub-routes." /dashboard matches. /dashboard/reports matches. /dashboard/anything matches.<br><br>
<strong>What withAuth does specifically:</strong><br>
Reads the next-auth.session-token httpOnly cookie. Verifies the JWT signature using NEXTAUTH_SECRET. If valid: attach session to request and continue. If invalid/missing: redirect to pages.signIn URL.<br><br>
<strong>Interview gold:</strong> "Middleware-based route protection is more secure than page-level checks because it's centralized. Change one file to add a new protected route. One config to see all protected routes. Defense in depth: even if a page component has a bug, middleware still blocks unauthenticated access."`
  },

  jwt_hipaa: {
    type: "concept",
    title: "JWT Sessions and HIPAA Compliance",
    question: "How does MindBridge's JWT session configuration satisfy HIPAA security requirements? Walk through each HIPAA requirement and how it's met.",
    context: "Healthcare interviews always test HIPAA knowledge. Show you've mapped technical implementation to specific compliance requirements.",
    ideal: `<strong>HIPAA Security Rule ‚Äî Technical Safeguards for Sessions:</strong><br><br>
<strong>1. Automatic Logoff (¬ß164.312(a)(2)(iii)):</strong><br>
HIPAA requires: Implement electronic procedures that terminate an electronic session after a predetermined time of inactivity.<br>
MindBridge implementation: maxAge: 8 * 60 * 60 in NextAuth config. JWT expires after 8 hours regardless of activity. Case manager must re-authenticate for each new shift.<br>
Why 8 hours: Aligns with standard clinical shift length. A case manager who forgets to log out has their session expire at end of shift automatically.<br><br>
<strong>2. Unique User Identification (¬ß164.312(a)(2)(i)):</strong><br>
HIPAA requires: Assign a unique name and/or number for identifying and tracking user identity.<br>
MindBridge implementation: JWT payload includes user_id, email, and role. Every API request includes this token. Every audit log entry records user_id. No shared accounts ‚Äî each clinician has unique credentials.<br><br>
<strong>3. Encryption in Transit (¬ß164.312(e)(2)(ii)):</strong><br>
HIPAA requires: Implement a mechanism to encrypt and decrypt electronic PHI in transit.<br>
MindBridge implementation: NextAuth session tokens stored in Secure cookies (HTTPS-only). TLS 1.3 encrypts all traffic. httpOnly prevents JavaScript access to tokens.<br><br>
<strong>4. Audit Controls (¬ß164.312(b)):</strong><br>
HIPAA requires: Hardware, software, and/or procedural mechanisms that record and examine activity in information systems that contain or use ePHI.<br>
MindBridge implementation: Every login logged to audit_log (user_id, timestamp, IP, action='LOGIN'). Every logout logged. Failed login attempts logged. Session token contains user identity for correlation.<br><br>
<strong>5. Person or Entity Authentication (¬ß164.312(d)):</strong><br>
HIPAA requires: Implement procedures to verify that a person or entity seeking access to ePHI is the one claimed.<br>
MindBridge implementation: CredentialsProvider validates email + bcrypt password hash. In production: MFA required for admin roles. JWT signed with RS256 ‚Äî cannot be forged without the private key.<br><br>
<strong>Interview gold:</strong> "I designed MindBridge's auth by starting with HIPAA requirements and mapping each one to a technical control. The 8-hour session isn't arbitrary ‚Äî it's a specific response to ¬ß164.312(a)(2)(iii). That's the difference between compliance-aware engineering and just installing a library."`
  },

  auth_interview: {
    type: "interview",
    title: "How Did You Implement Authentication in MindBridge?",
    question: "Walk me through how you added authentication to the MindBridge dashboard. What did you build, what decisions did you make, and what would you do differently in production?",
    context: "This is a direct question about Day 13's work. You built it ‚Äî own every decision. Use the structure: What I built ‚Üí Why I built it that way ‚Üí What production would look like.",
    ideal: `<strong>WHAT I BUILT:</strong><br>
Three components working together: NextAuth handler, middleware route protection, and updated login form.<br><br>
The NextAuth handler at app/api/auth/[...nextauth]/route.ts configures CredentialsProvider with demo credentials and JWT sessions with 8-hour expiry. The [...nextauth] catch-all route automatically handles all auth endpoints ‚Äî signin, signout, session, CSRF.<br><br>
middleware.ts at the project root uses withAuth to protect /dashboard and /patients/* routes at the edge. Before any request reaches those pages, NextAuth verifies the session token. Invalid or missing token = redirect to login.<br><br>
The login page calls signIn('credentials', { redirect: false }) and handles success/failure explicitly ‚Äî success pushes to /dashboard, failure shows an error message without a page reload.<br><br>
<strong>KEY DECISIONS:</strong><br>
redirect: false in signIn() ‚Äî gives me control over error handling. The default redirect: true would redirect to an error page on failure, which is bad UX for a clinical tool.<br><br>
8-hour JWT expiry ‚Äî aligns with clinical shift length. HIPAA ¬ß164.312(a)(2)(iii) requires automatic logoff. 8 hours is the standard clinical shift.<br><br>
Middleware over page-level checks ‚Äî centralized enforcement. One file protects all protected routes. Impossible to accidentally expose a route by forgetting to add a check.<br><br>
<strong>WHAT PRODUCTION WOULD LOOK LIKE:</strong><br>
Replace hardcoded credentials with PostgreSQL lookup: query users table, bcrypt.verify() the password hash. Add MFA (TOTP) for admin roles. Log every login attempt to audit_log. Add account lockout after 5 failed attempts. Consider adding OAuth (Microsoft/Google) for SSO with hospital identity providers.<br><br>
<strong>Interview gold:</strong> "The demo implementation took 3 files and 30 minutes. The production implementation adds database validation, MFA, audit logging, and SSO. The architecture is identical ‚Äî I just swap the authorize() function body and add logging middleware."`
  },

  hipaa_auth_design: {
    type: "interview",
    title: "Design HIPAA-Compliant Authentication",
    question: "Design a complete authentication system for a healthcare application from scratch. What are the HIPAA requirements and how does each technical decision address them?",
    context: "System design + HIPAA compliance combined. This is a senior-level question. Show you can connect regulatory requirements to architectural decisions.",
    ideal: `<strong>START WITH HIPAA REQUIREMENTS (not technology):</strong><br>
¬ß164.312(a)(2)(i): Unique user identification ‚Äî no shared accounts<br>
¬ß164.312(a)(2)(iii): Automatic logoff ‚Äî session expiry<br>
¬ß164.312(b): Audit controls ‚Äî log all access<br>
¬ß164.312(d): Person authentication ‚Äî verify identity<br>
¬ß164.312(e)(2)(ii): Encryption in transit ‚Äî TLS for all connections<br><br>
<strong>LAYER 1 ‚Äî Credential Security:</strong><br>
Never store plain passwords. Use bcrypt with cost factor 12:<br>
hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt(12))<br>
Cost factor 12 = ~250ms to verify. Slow enough to prevent brute force, fast enough for login.<br><br>
Enforce password complexity: minimum 12 characters, uppercase, number, special character. Healthcare credentials need to be strong.<br><br>
<strong>LAYER 2 ‚Äî Session Management:</strong><br>
JWT tokens signed with RS256 (asymmetric). Private key signs, public key verifies. Even if public key leaks, tokens can't be forged.<br>
Expiry: 8 hours (clinical shift). Refresh tokens: 7 days (for "remember this device" on personal devices only).<br>
Store in httpOnly, Secure, SameSite=Strict cookies. httpOnly = JavaScript can't read. Secure = HTTPS only. SameSite=Strict = CSRF protection.<br><br>
<strong>LAYER 3 ‚Äî Multi-Factor Authentication:</strong><br>
Required for: admin roles, accessing PHI in bulk, password resets.<br>
Optional for: standard case managers (recommended but not required).<br>
Implementation: TOTP (Google Authenticator compatible). Generate secret per user, store encrypted in database. Verify 6-digit code on login.<br><br>
<strong>LAYER 4 ‚Äî Audit Logging:</strong><br>
Log every authentication event to immutable audit table:<br>
INSERT INTO audit_log (user_id, action, ip_address, user_agent, success, timestamp)<br>
VALUES (user.id, 'LOGIN', request.ip, request.headers['user-agent'], true, NOW())<br><br>
Log: successful logins, failed attempts, logouts, password changes, MFA events.<br>
Retain for 6 years (HIPAA minimum retention).<br><br>
<strong>LAYER 5 ‚Äî Account Protection:</strong><br>
Lockout after 5 failed attempts (15-minute lockout).<br>
Alert user and security team on suspicious activity (login from new country, 3 AM login).<br>
Force password reset every 90 days for privileged accounts.<br><br>
<strong>LAYER 6 ‚Äî Session Termination:</strong><br>
Automatic logoff at 8 hours.<br>
Manual logout invalidates token server-side (maintain token blacklist in Redis).<br>
Force logout all sessions on password change.<br><br>
<strong>Interview gold:</strong> "HIPAA authentication isn't about picking the right library. It's about mapping each regulatory requirement to a technical control, then building those controls so they're impossible to bypass. Start with the requirement, then design the solution."`
  },

  session_expired: {
    type: "simulation",
    title: "Session Expired Mid-Shift",
    question: "A case manager calls support: 'I was in the middle of entering a patient note and got kicked out. I lost everything I typed. This is unacceptable.' How do you respond technically and professionally?",
    context: "Auth edge cases have real clinical impact. Show you understand both the technical fix and the human consequences.",
    ideal: `<strong>WHAT HAPPENED TECHNICALLY:</strong><br>
The 8-hour JWT session expired while the case manager was actively typing. Next.js middleware detected the expired token on the next API call or page navigation and redirected to login. The unsaved note was lost because it existed only in the browser's DOM ‚Äî never persisted to the database.<br><br>
<strong>PROFESSIONAL RESPONSE (what you say to the case manager):</strong><br>
"I completely understand your frustration ‚Äî losing clinical documentation is a serious problem and I'm sorry that happened. The session timeout is a HIPAA security requirement, but how we handle it is absolutely something we can improve. Let me explain what happened and what we're going to fix."<br><br>
<strong>IMMEDIATE TECHNICAL FIX ‚Äî Auto-save drafts:</strong><br>
Save the note content to localStorage every 30 seconds while the case manager is typing:<br>
useEffect(() => {<br>
  const interval = setInterval(() => {<br>
    localStorage.setItem('draft_note_' + patientId, noteContent);<br>
  }, 30000);<br>
  return () => clearInterval(interval);<br>
}, [noteContent]);<br><br>
On page load, check for saved draft:<br>
const saved = localStorage.getItem('draft_note_' + patientId);<br>
if (saved) showBanner("You have an unsaved draft. Restore it?");<br><br>
<strong>BETTER FIX ‚Äî Session expiry warning:</strong><br>
Show a warning 10 minutes before session expires:<br>
"Your session expires in 10 minutes. Save your work or click here to extend your session."<br><br>
On click: call /api/auth/session to refresh the token. Session resets to 8 hours.<br><br>
<strong>BEST FIX ‚Äî Optimistic saving:</strong><br>
Don't wait for the case manager to click Save. Auto-save to the database every 60 seconds as a draft:<br>
POST /api/notes/draft { patient_id, content, saved_at }<br><br>
When session expires and they log back in: "You have an unsaved draft from 2:47 PM. Continue where you left off?"<br><br>
<strong>The HIPAA balance:</strong><br>
The 8-hour timeout is non-negotiable ‚Äî it's a regulatory requirement. But how the application handles the expiry IS negotiable. A good healthcare app warns before expiry, saves drafts, and restores work after re-authentication. The security requirement and the clinical UX don't have to conflict.<br><br>
<strong>Interview gold:</strong> "Security requirements and user experience don't have to conflict. The session timeout is HIPAA-mandated. But auto-save, expiry warnings, and draft restoration make the timeout invisible to case managers 99% of the time. That's clinical-aware engineering."`
  },

  railway_deploy_fail: {
    type: "simulation",
    title: "Railway Deployment Fails ‚Äî No Start Command",
    question: "You push your FastAPI backend to Railway and the deployment fails with: 'No start command was found.' The logs show Railpack detected Python but couldn't find how to start the app. How do you diagnose and fix this?",
    context: "Deployment failures on Railway are common when deploying from subdirectories. Show you understand how Railway's build system works.",
    ideal: `<strong>WHAT HAPPENED:</strong><br>
Railway's Railpack build system scanned the repository root and couldn't find a recognizable Python app entry point. The FastAPI app is in the backend/ subdirectory, so Railpack couldn't detect it automatically.<br><br>
<strong>DIAGNOSIS STEPS:</strong><br>
1. Check if Root Directory is set correctly in Railway Settings ‚Üí Source ‚Üí Root Directory<br>
Should be: backend<br>
If empty, Railway scans the entire repo and gets confused<br><br>
2. Check if railway.toml exists in the backend/ folder<br>
The startCommand in railway.toml should override Railpack's detection<br><br>
3. Check if the start command is set manually in Settings ‚Üí Deploy ‚Üí Start Command<br><br>
<strong>FIX OPTIONS (in order of preference):</strong><br><br>
Option 1 ‚Äî Set Root Directory:<br>
Railway Settings ‚Üí Source ‚Üí Add Root Directory ‚Üí type "backend"<br>
Railpack now scans only the backend/ folder and finds main.py<br><br>
Option 2 ‚Äî Set Start Command manually:<br>
Railway Settings ‚Üí Deploy ‚Üí Start Command:<br>
uvicorn app.main:app --host 0.0.0.0 --port $PORT<br><br>
Option 3 ‚Äî Add railway.toml to backend/:<br>
[deploy]<br>
startCommand = "uvicorn app.main:app --host 0.0.0.0 --port $PORT"<br><br>
<strong>ROOT CAUSE LESSON:</strong><br>
Railway expects apps at the repo root by default. Monorepos (frontend + backend in same repo) always need explicit Root Directory configuration. This is a one-time setup per service.<br><br>
<strong>Interview gold:</strong> "Railway's Nixpacks is powerful but opinionated. When deploying from subdirectories, always set Root Directory explicitly. I learned this the hard way and now it's the first thing I configure for any new Railway service."`
  },

  db_unavailable: {
    type: "simulation",
    title: "Database Unavailable on Startup ‚Äî Healthcheck Fails",
    question: "Your FastAPI service deploys to Railway but the healthcheck fails. Logs show the database pool creation throws an error during lifespan startup, crashing the app before it can respond to /health. How do you fix this without compromising database connectivity?",
    context: "This is a real production issue. Healthchecks and database connectivity need to be decoupled. Show you understand graceful degradation.",
    ideal: `<strong>WHAT HAPPENED:</strong><br>
The lifespan function tried to create the asyncpg pool during startup. The database was temporarily unavailable (wrong URL, network issue, DB restarting). The exception propagated and crashed the entire FastAPI startup ‚Äî the app never started, so /health never responded, so Railway marked the deployment as failed.<br><br>
<strong>THE WRONG APPROACH:</strong><br>
@asynccontextmanager<br>
async def lifespan(app):<br>
    db_pool = await asyncpg.create_pool(DATABASE_URL)  # Crashes if DB unavailable<br>
    yield<br><br>
<strong>THE RIGHT APPROACH ‚Äî Graceful degradation:</strong><br>
@asynccontextmanager<br>
async def lifespan(app):<br>
    global db_pool<br>
    try:<br>
        db_pool = await asyncpg.create_pool(DATABASE_URL, min_size=2, max_size=10, ssl="require")<br>
        print("‚úÖ Database pool created")<br>
    except Exception as e:<br>
        print(f"‚ö†Ô∏è Database pool failed: {e}")<br>
        db_pool = None  # App starts without database<br>
    yield<br>
    if db_pool:<br>
        await db_pool.close()<br><br>
<strong>UPDATE /health TO REFLECT DB STATUS:</strong><br>
@app.get("/health")<br>
async def health_check():<br>
    return {<br>
        "status": "healthy",<br>
        "database": "connected" if db_pool else "unavailable"<br>
    }<br><br>
This way /health always returns 200, Railway healthcheck passes, and the database: "unavailable" field tells you something needs fixing without taking down the service.<br><br>
<strong>UPDATE /api/patients TO HANDLE NULL POOL:</strong><br>
@app.get("/api/patients")<br>
async def get_patients():<br>
    if not db_pool:<br>
        raise HTTPException(503, "Database unavailable")<br>
    ...<br><br>
<strong>Interview gold:</strong> "Healthchecks and database connectivity are separate concerns. The app being alive is different from the database being reachable. Decoupling them means Railway can restart a pod without a cascade failure just because the DB had a 5-second hiccup."`
  },

  cors_blocked: {
    type: "simulation",
    title: "CORS Blocking Vercel ‚Üí Railway API Calls",
    question: "Your Next.js frontend on Vercel tries to call your Railway FastAPI backend. The browser console shows: 'Access to fetch at https://mindbridge-health-ai-production.up.railway.app/api/patients from origin https://mind-bridge-health-ai.vercel.app has been blocked by CORS policy.' How do you fix it?",
    context: "CORS errors are extremely common in full-stack development. Show you understand what causes them and exactly how to fix them.",
    ideal: `<strong>WHAT CORS IS:</strong><br>
CORS (Cross-Origin Resource Sharing) is a browser security policy. When JavaScript on origin-A tries to fetch from origin-B, the browser first sends a preflight OPTIONS request to origin-B asking: "Do you allow requests from origin-A?" If origin-B doesn't respond with the right headers, the browser blocks the request before it even reaches your API code.<br><br>
<strong>WHY IT'S HAPPENING:</strong><br>
Vercel origin: https://mind-bridge-health-ai.vercel.app<br>
Railway origin: https://mindbridge-health-ai-production.up.railway.app<br>
Different domains = cross-origin = CORS applies<br><br>
<strong>THE FIX ‚Äî Add CORSMiddleware to FastAPI:</strong><br>
from fastapi.middleware.cors import CORSMiddleware<br><br>
app.add_middleware(<br>
    CORSMiddleware,<br>
    allow_origins=[<br>
        "http://localhost:3000",<br>
        "https://mind-bridge-health-ai.vercel.app"<br>
    ],<br>
    allow_credentials=True,<br>
    allow_methods=["GET", "POST", "PUT", "DELETE"],<br>
    allow_headers=["Authorization", "Content-Type"],<br>
)<br><br>
<strong>COMMON MISTAKES:</strong><br>
‚ùå allow_origins=["*"] ‚Äî Never use wildcard with allow_credentials=True. Browsers reject this combination.<br>
‚ùå Missing the staging URL ‚Äî Add all environments: localhost, staging, production<br>
‚ùå Trailing slash ‚Äî "https://mind-bridge-health-ai.vercel.app/" ‚â† "https://mind-bridge-health-ai.vercel.app"<br>
‚ùå Wrong order ‚Äî CORSMiddleware must be added BEFORE other middleware<br><br>
<strong>HOW TO VERIFY IT'S WORKING:</strong><br>
Open browser DevTools ‚Üí Network tab ‚Üí find the failed request ‚Üí look at Response Headers:<br>
Access-Control-Allow-Origin: https://mind-bridge-health-ai.vercel.app ‚úÖ<br><br>
<strong>Interview gold:</strong> "CORS is browser-enforced, not server-enforced. The server receives the request either way ‚Äî CORS only affects browser clients. This is why Postman and curl work fine but browsers block it. The fix is always server-side: add the correct response headers."`
  },

  fastapi_deploy_interview: {
    type: "interview",
    title: "Walk Me Through Your FastAPI Deployment",
    question: "Tell me about deploying the MindBridge FastAPI backend to production. What decisions did you make, what went wrong, and how did you fix it?",
    context: "This is a direct question about Day 14's work. Use the structure: architecture ‚Üí key decisions ‚Üí debugging ‚Üí lessons learned.",
    ideal: `<strong>THE ARCHITECTURE:</strong><br>
FastAPI backend deployed to Railway, connected to Railway PostgreSQL, exposed via public Railway domain. Vercel frontend calls the Railway API. Full production stack with no localhost dependencies.<br><br>
<strong>KEY TECHNICAL DECISIONS:</strong><br><br>
1. asyncpg over psycopg2:<br>
FastAPI is async ‚Äî using a synchronous database driver means every DB call blocks the entire thread. asyncpg is fully async, letting FastAPI handle hundreds of concurrent requests while waiting for DB responses. Critical for a healthcare platform where multiple case managers access the system simultaneously.<br><br>
2. Connection pooling (min=2, max=10):<br>
Opening a PostgreSQL connection takes ~100ms. With pooling, connections are reused ‚Äî query latency drops to single-digit milliseconds. min_size=2 keeps warm connections ready. max_size=10 handles traffic bursts without overwhelming the database.<br><br>
3. Non-fatal database startup:<br>
Wrapped pool creation in try/except. If the database is temporarily unavailable during deployment, the app still starts and Railway healthcheck passes. The /health endpoint reports database: "unavailable" so we know to investigate without a full deployment failure.<br><br>
<strong>WHAT WENT WRONG AND HOW I FIXED IT:</strong><br><br>
Problem 1 ‚Äî No start command:<br>
Railway couldn't detect the FastAPI app because it was in a backend/ subdirectory. Fixed by setting Root Directory to "backend" in Railway Settings and manually setting the start command: uvicorn app.main:app --host 0.0.0.0 --port $PORT<br><br>
Problem 2 ‚Äî DATABASE_URL empty:<br>
Railway auto-generates DATABASE_PUBLIC_URL for PostgreSQL services, not DATABASE_URL. The app was reading DATABASE_URL which was empty, defaulting to localhost:5432. Fixed by renaming DATABASE_PUBLIC_URL to DATABASE_URL in Railway's Variables tab.<br><br>
Problem 3 ‚Äî Port mismatch:<br>
Generated the Railway domain with port 8000 but uvicorn was running on port 8080. Fixed by regenerating the domain with the correct port.<br><br>
<strong>LESSONS LEARNED:</strong><br>
Railway's auto-generated variable names don't always match what your code expects. Always verify environment variable names in the Variables tab after setup. The debug pattern: add explicit logging of os.environ values to confirm what the app actually receives at runtime.<br><br>
<strong>Interview gold:</strong> "Every production deployment teaches you something. The DATABASE_PUBLIC_URL vs DATABASE_URL issue took 30 minutes to debug but now it's the first thing I check on any Railway deployment. That's how production experience compounds."`
  },

  async_vs_sync: {
    type: "interview",
    title: "Why Async Database Calls Matter in FastAPI",
    question: "Why did you choose asyncpg over psycopg2 for MindBridge? Explain the performance difference between async and sync database calls in a FastAPI context.",
    context: "This tests deep understanding of async programming. Show you know WHY async matters, not just that it's a best practice.",
    ideal: `<strong>THE CORE PROBLEM WITH SYNC IN ASYNC FRAMEWORKS:</strong><br>
FastAPI uses a single-threaded async event loop (uvicorn + asyncio). When you make a synchronous database call with psycopg2, the entire thread blocks ‚Äî it sits idle waiting for PostgreSQL to respond. During that wait, no other requests can be processed.<br><br>
<strong>CONCRETE EXAMPLE:</strong><br>
Imagine 50 case managers log in simultaneously at shift start:<br><br>
With psycopg2 (sync):<br>
Request 1: connect to DB ‚Üí wait 100ms ‚Üí get data ‚Üí respond<br>
Request 2: BLOCKED until Request 1 completes<br>
Request 3: BLOCKED until Request 2 completes<br>
50 requests √ó 100ms = 5 seconds for the last case manager<br><br>
With asyncpg (async):<br>
Request 1: send DB query ‚Üí yield control while waiting<br>
Request 2: send DB query ‚Üí yield control while waiting<br>
Request 3: send DB query ‚Üí yield control while waiting<br>
All 50 queries in-flight simultaneously ‚Üí all respond in ~100ms<br><br>
<strong>THE CODE DIFFERENCE:</strong><br>
# Sync (blocks event loop):<br>
def get_patients():<br>
    conn = psycopg2.connect(DATABASE_URL)<br>
    return conn.execute("SELECT * FROM patients")<br><br>
# Async (yields control while waiting):<br>
async def get_patients():<br>
    async with db_pool.acquire() as conn:<br>
        return await conn.fetch("SELECT * FROM patients")<br><br>
<strong>WHY THIS MATTERS FOR HEALTHCARE:</strong><br>
Clinical workflows have synchronized access patterns ‚Äî shift changes, morning rounds, crisis response. Multiple clinicians access the system simultaneously. Synchronous database calls under these conditions cause cascading delays that directly impact patient care response times.<br><br>
<strong>WHEN SYNC IS ACCEPTABLE:</strong><br>
Simple scripts, CLIs, one-off data migrations ‚Äî anywhere you have one user doing one thing. Never acceptable in a production API with concurrent users.<br><br>
<strong>Interview gold:</strong> "asyncpg isn't a preference ‚Äî it's architecturally necessary for FastAPI. Using psycopg2 in FastAPI is like putting a traffic light on a highway. The framework is designed for concurrency; the database driver must match."`
  },

  connection_pooling_deep: {
    type: "concept",
    title: "Connection Pooling Deep Dive",
    question: "Explain connection pooling from first principles. What problem does it solve, how does it work, and how should you configure pool sizes for a healthcare application?",
    context: "Connection pooling appears in almost every backend interview. Show you understand it at the implementation level, not just 'it makes things faster.'",
    ideal: `<strong>THE PROBLEM WITHOUT POOLING:</strong><br>
Every database query requires: TCP handshake ‚Üí SSL negotiation ‚Üí PostgreSQL authentication ‚Üí query execution ‚Üí connection teardown. Steps 1-4 take ~100ms before your actual query runs. For a dashboard loading 10 patients, that's 1 second of pure connection overhead before any data moves.<br><br>
<strong>HOW A POOL WORKS:</strong><br>
A pool pre-creates N connections at startup and keeps them open permanently. When a request needs the database, it borrows a connection from the pool (microseconds), runs the query, returns the connection. No TCP handshakes, no SSL negotiations, no authentication on every request.<br><br>
asyncpg pool lifecycle:<br>
1. App starts ‚Üí create_pool() opens min_size connections immediately<br>
2. Request arrives ‚Üí pool.acquire() returns an available connection<br>
3. Query runs<br>
4. async with block exits ‚Üí connection returned to pool automatically<br>
5. Next request reuses that connection instantly<br>
6. If all connections busy ‚Üí wait up to pool_timeout seconds<br>
7. If load spikes ‚Üí pool grows up to max_size connections<br>
8. App shuts down ‚Üí pool.close() cleanly closes all connections<br><br>
<strong>CONFIGURING POOL SIZES:</strong><br>
Rule of thumb: pool_size = (num_cores √ó 2) + effective_spindle_count<br>
For MindBridge on Railway (1 core): min=2, max=10<br><br>
Too small (min=1, max=3): Requests queue up under load, response times spike<br>
Too large (max=100): Overwhelms PostgreSQL ‚Äî each DB connection consumes ~5-10MB RAM<br><br>
For healthcare specifically:<br>
min_size=2: Always 2 warm connections ready ‚Äî instant response for overnight on-call clinicians<br>
max_size=10: Handles shift-change surge (50 case managers) by queuing requests fairly<br>
ssl="require": HIPAA encryption in transit requirement<br><br>
<strong>MONITORING POOL HEALTH:</strong><br>
Watch for: pool exhaustion (requests timing out), connection leaks (pool never returns connections), stale connections (pool_pre_ping=True prevents this in SQLAlchemy)<br><br>
<strong>Interview gold:</strong> "Pool sizing is a tradeoff between memory on the database server and latency under load. I start with (cores √ó 2) + 2, monitor p95 latency and connection wait times, then tune. The goal is zero connection wait time at peak load without exhausting database memory."`
  },

  railway_env_vars: {
    type: "concept",
    title: "Railway Environment Variables ‚Äî Complete Guide",
    question: "Explain Railway's environment variable system. What types exist, how are they injected, and what are the common pitfalls?",
    context: "Environment variable issues caused real debugging time on Day 14. Show you understand the system deeply enough to never hit these issues again.",
    ideal: `<strong>TYPES OF RAILWAY ENVIRONMENT VARIABLES:</strong><br><br>
1. Service Variables (most common):<br>
Set per-service in Variables tab. Only available to that service.<br>
Example: DATABASE_URL for the FastAPI service<br><br>
2. Shared Variables (project-level):<br>
Set in Project Settings ‚Üí Shared Variables. Available to ALL services in the project.<br>
Good for: API keys used by multiple services, project-wide config<br><br>
3. Auto-generated Variables:<br>
Railway creates these automatically for managed services:<br>
DATABASE_URL ‚Üí internal connection string (postgres.railway.internal)<br>
DATABASE_PUBLIC_URL ‚Üí public connection string (switchback.proxy.rlwy.net)<br>
PGHOST, PGPORT, PGDATABASE, PGUSER, PGPASSWORD ‚Üí individual components<br>
PORT ‚Üí the port your service should listen on (set by Railway)<br><br>
4. Reference Variables:<br>
Reference another service's variable: \${{Postgres.DATABASE_URL}}<br>
Stays in sync automatically if the referenced value changes<br><br>
<strong>HOW INJECTION WORKS:</strong><br>
Variables are baked into the container environment at deploy time. Available via os.environ.get("KEY"). No .env file exists ‚Äî load_dotenv() does nothing (or can interfere). Changes to variables trigger a redeploy to take effect.<br><br>
<strong>COMMON PITFALLS:</strong><br>
‚ùå Using DATABASE_URL when Railway generated DATABASE_PUBLIC_URL<br>
Fix: Rename the variable or update your code to use DATABASE_PUBLIC_URL<br><br>
‚ùå Using internal URL from external service<br>
postgres.railway.internal only works Railway ‚Üí Railway<br>
Fix: Always use DATABASE_PUBLIC_URL for services connecting from outside Railway<br><br>
‚ùå Invisible characters in variable names<br>
Copy-pasting variable names can include invisible Unicode characters<br>
Fix: Type variable names manually, never paste them<br><br>
‚ùå Wrong environment (production vs staging)<br>
Variables are environment-specific. Production variables don't exist in staging.<br>
Fix: Set variables in each environment separately<br><br>
<strong>BEST PRACTICE ‚Äî Reference Variables:</strong><br>
Instead of copy-pasting the PostgreSQL URL into your FastAPI service:<br>
DATABASE_URL = \${{Postgres.DATABASE_PUBLIC_URL}}<br><br>
If Railway rotates the PostgreSQL password, this updates automatically. No manual copy-paste, no stale credentials.<br><br>
<strong>Interview gold:</strong> "The DATABASE_PUBLIC_URL vs DATABASE_URL confusion is Railway's most common gotcha. I now always use Reference Variables (\${{Postgres.DATABASE_PUBLIC_URL}}) so credentials stay in sync automatically and I never have to copy-paste sensitive values."`
  },

  full_stack_architecture: {
    type: "interview",
    title: "Walk Me Through Your Full Stack Architecture",
    question: "Describe the complete MindBridge architecture. How does a request flow from a clinician's browser to the database and back? What decisions did you make at each layer?",
    context: "This is the most important interview question you'll face. Practice until you can answer it in under 3 minutes with confidence.",
    ideal: `<strong>THE THREE LAYERS:</strong><br><br>
<strong>Layer 1 ‚Äî Frontend (Vercel + Next.js):</strong><br>
Next.js 16 deployed on Vercel's global CDN. When a clinician visits the app, they hit the login page. NextAuth.js handles authentication ‚Äî credentials validated, JWT token issued with 8-hour expiry aligned to clinical shift length. Token stored in httpOnly cookie ‚Äî invisible to JavaScript, CSRF-protected.<br><br>
Next.js middleware runs at the edge on every request to /dashboard and /patients/*. No valid JWT = instant redirect to login. The dashboard page component never executes for unauthenticated requests.<br><br>
<strong>Layer 2 ‚Äî Backend (Railway + FastAPI):</strong><br>
FastAPI deployed on Railway. When the dashboard loads, a Server Component calls GET /api/patients on the FastAPI service. FastAPI validates the request, acquires a connection from the asyncpg pool, queries PostgreSQL, and returns JSON.<br><br>
Key decisions: asyncpg over psycopg2 for non-blocking queries. Connection pool (min=2, max=10) eliminates 100ms connection overhead on every request. CORS configured for Vercel origin only ‚Äî no wildcard.<br><br>
<strong>Layer 3 ‚Äî Database (Railway + PostgreSQL):</strong><br>
PostgreSQL managed by Railway. SSL required for all connections ‚Äî satisfies HIPAA ¬ß164.312(e)(2)(ii) encryption in transit. Patient data includes risk levels, medication adherence, crisis calls, diagnoses.<br><br>
<strong>COMPLETE REQUEST FLOW:</strong><br>
1. Clinician opens dashboard<br>
2. Next.js middleware checks JWT cookie ‚Üí valid ‚Üí continue<br>
3. Server Component calls FastAPI /api/patients<br>
4. FastAPI acquires pool connection ‚Üí queries PostgreSQL<br>
5. Patient data returned as JSON<br>
6. Server Component renders HTML with patient data<br>
7. HTML delivered to clinician's browser via Vercel CDN<br><br>
<strong>Interview gold:</strong> "Every architectural decision maps to a clinical requirement. 8-hour sessions = shift alignment. Server Components = credentials never reach browser. asyncpg = concurrent case manager access during shift changes. I didn't just pick technologies ‚Äî I mapped requirements to solutions."`
  },

  week3_technical_review: {
    type: "interview",
    title: "Week 3 Technical Review ‚Äî Everything You Built",
    question: "Summarize everything you built in Week 3. For each major component, explain what it does, why you built it that way, and what you'd improve in a production system with real users.",
    context: "This is a comprehensive review of Days 11-15. Use this to practice telling the full MindBridge story confidently.",
    ideal: `<strong>DAY 11 ‚Äî Next.js Frontend + Vercel Deployment:</strong><br>
Built: Login page, dashboard with patient table, CI/CD pipeline via GitHub ‚Üí Vercel.<br>
Why: Next.js Server Components let the dashboard query PostgreSQL server-side ‚Äî patient data never passes through the browser. Vercel provides global CDN with zero configuration.<br>
Production improvement: Add error boundaries, loading skeletons, and offline handling for poor clinical connectivity environments.<br><br>
<strong>DAY 12 ‚Äî Railway PostgreSQL Connection:</strong><br>
Built: Next.js API route, dashboard Server Component querying Railway PostgreSQL directly, environment variable management.<br>
Why: Server Components eliminate the localhost dependency that breaks Vercel deployments. Environment variables in Vercel dashboard keep credentials out of code.<br>
Production improvement: Add database migrations with Prisma or Alembic instead of manual SQL. Add connection health monitoring.<br><br>
<strong>SECURITY INCIDENT ‚Äî GitGuardian:</strong><br>
What happened: Exposed Railway credentials in public GitHub repo. Detected within 24 hours.<br>
Response: Rotated password immediately, removed hardcoded URLs, cleaned git history with git-filter-repo. Total resolution: under 30 minutes.<br>
Production improvement: Pre-commit hooks with detect-secrets to prevent exposure before push.<br><br>
<strong>DAY 13 ‚Äî NextAuth.js Authentication:</strong><br>
Built: CredentialsProvider, JWT sessions, Next.js middleware route protection, updated login form.<br>
Why: NextAuth handles JWT signing, CSRF protection, and httpOnly cookies ‚Äî security primitives I'd likely get wrong building from scratch. 8-hour expiry satisfies HIPAA ¬ß164.312(a)(2)(iii).<br>
Production improvement: Replace demo credentials with PostgreSQL user lookup + bcrypt verification. Add MFA for admin roles. Add login attempt rate limiting.<br><br>
<strong>DAY 14 ‚Äî FastAPI Deployment on Railway:</strong><br>
Built: FastAPI with asyncpg connection pooling, /health and /api/patients endpoints, Railway deployment with Nixpacks.<br>
Why: asyncpg is non-blocking ‚Äî essential for FastAPI's async architecture. Connection pooling eliminates per-request connection overhead.<br>
Production improvement: Add Pydantic response models for type-safe API contracts. Add request logging middleware. Add rate limiting per user.<br><br>
<strong>DAY 15 ‚Äî Full Stack Wired End-to-End:</strong><br>
Built: Next.js dashboard calling FastAPI instead of PostgreSQL directly. Portfolio README with architecture diagram.<br>
Why: Separating frontend from database through an API layer enables independent scaling, versioning, and security boundaries.<br>
Production improvement: Add API versioning (/api/v1/patients). Add response caching for non-sensitive data. Add OpenAPI documentation.<br><br>
<strong>Interview gold:</strong> "Week 3 built the complete production foundation. Week 4 adds AI agents on top of this stack ‚Äî patient risk scoring, clinical documentation assistance, and database management automation. The architecture was designed from day one to support AI capabilities."`
  },

  server_vs_client: {
    type: "concept",
    title: "Server vs Client Components in Next.js",
    question: "Explain the difference between Server Components and Client Components in Next.js. When does MindBridge use each and why?",
    context: "This is a core Next.js concept that appears in every frontend interview. Show you understand the rendering model deeply.",
    ideal: `<strong>SERVER COMPONENTS (default in Next.js App Router):</strong><br>
Run on the server. Can access databases, file system, environment variables directly. Never sent to the browser ‚Äî only the rendered HTML output is sent. Cannot use browser APIs (window, document), React hooks (useState, useEffect), or event handlers.<br><br>
MindBridge dashboard page.tsx is a Server Component:<br>
- Calls FastAPI backend directly from the server<br>
- DATABASE_URL never reaches the browser<br>
- Rendered HTML sent to Vercel's edge network<br>
- Patient data rendered server-side ‚Äî faster initial load<br><br>
<strong>CLIENT COMPONENTS ('use client' directive):</strong><br>
Run in the browser. Can use React hooks, event handlers, browser APIs. Must fetch data via API calls ‚Äî cannot access databases directly. JavaScript bundle sent to browser.<br><br>
MindBridge login page.tsx is a Client Component:<br>
- Uses useState for email/password form state<br>
- Uses useRouter for programmatic navigation after login<br>
- Calls signIn() from next-auth/react (client-side library)<br>
- Must be 'use client' because it uses hooks and event handlers<br><br>
<strong>THE DECISION FRAMEWORK:</strong><br>
Use Server Component when: fetching data, accessing secrets, no interactivity needed<br>
Use Client Component when: user interaction, React hooks, browser APIs, real-time updates<br><br>
<strong>COMMON MISTAKE:</strong><br>
Making everything 'use client' because it's familiar from older React. This sends more JavaScript to the browser, exposes environment variables, and loses server-side rendering benefits.<br><br>
<strong>Interview gold:</strong> "The App Router's default of Server Components is a security feature as much as a performance feature. Sensitive data ‚Äî API keys, database queries, patient information ‚Äî stays on the server by default. You have to explicitly opt into client-side rendering with 'use client'."`
  },

  next_public_vars: {
    type: "concept",
    title: "NEXT_PUBLIC_ Environment Variables",
    question: "Explain Next.js environment variables. What is NEXT_PUBLIC_, when should you use it, and what should never have it?",
    context: "Environment variable mistakes are a common source of security vulnerabilities. Show you understand the exposure model.",
    ideal: `<strong>HOW NEXT.JS HANDLES ENV VARS:</strong><br>
Next.js reads from .env.local (local dev) and deployment platform variables (Vercel). Variables WITHOUT NEXT_PUBLIC_ are only available server-side ‚Äî in Server Components, API routes, and middleware. Variables WITH NEXT_PUBLIC_ are bundled into the JavaScript sent to the browser ‚Äî available everywhere including client components.<br><br>
<strong>SAFE TO USE NEXT_PUBLIC_:</strong><br>
NEXT_PUBLIC_API_URL ‚Äî Railway FastAPI URL (not a secret, visible in Network tab anyway)<br>
NEXT_PUBLIC_APP_NAME ‚Äî Display text<br>
NEXT_PUBLIC_VERSION ‚Äî Version number<br>
NEXT_PUBLIC_POSTHOG_KEY ‚Äî Analytics keys designed to be public<br><br>
<strong>NEVER USE NEXT_PUBLIC_:</strong><br>
DATABASE_URL ‚Äî Contains database password<br>
NEXTAUTH_SECRET ‚Äî Signs JWT tokens, exposure = session forgery<br>
ANTHROPIC_API_KEY ‚Äî Paid API key, exposure = billing fraud<br>
Any password, token, or private key<br><br>
<strong>THE EXPOSURE TEST:</strong><br>
Ask: "Would I be comfortable if this value appeared in the browser's JavaScript bundle, visible to anyone who opens DevTools ‚Üí Sources?"<br>
Yes ‚Üí NEXT_PUBLIC_ is fine<br>
No ‚Üí Never add NEXT_PUBLIC_<br><br>
<strong>VERCEL'S WARNING:</strong><br>
Vercel shows a warning on every NEXT_PUBLIC_ variable: "This exposes the value to the browser." This is expected behavior ‚Äî it's confirming you made a conscious choice, not warning of an error.<br><br>
<strong>Interview gold:</strong> "The NEXT_PUBLIC_ prefix is a deliberate security boundary. Anything without it is server-only by default ‚Äî a secure default. You have to actively choose to expose a value to the browser. I treat that choice like a security review: would I be comfortable with this in the browser's source code?"`
  },

  stale_clinical_data: {
    type: "simulation",
    title: "Stale Clinical Data Incident",
    question: "A psychiatrist reports that a patient showing as LOW risk on the dashboard attempted self-harm. The patient's risk level was updated to HIGH in the database 2 hours ago but the dashboard still shows LOW. How do you investigate and fix this?",
    context: "Caching clinical data has patient safety implications. Show you understand the technical and ethical dimensions of this incident.",
    ideal: `<strong>IMMEDIATE RESPONSE:</strong><br>
This is a patient safety incident, not just a technical bug. Immediate steps:<br>
1. Confirm the database shows HIGH risk ‚Äî verify the source of truth<br>
2. Hard refresh the dashboard ‚Äî confirm it still shows LOW<br>
3. Check when the last deployment was ‚Äî could be a build-time prerender issue<br>
4. Escalate to clinical leadership immediately ‚Äî do not wait for technical fix<br><br>
<strong>TECHNICAL INVESTIGATION:</strong><br>
Check 1 ‚Äî Is force-dynamic set on dashboard?<br>
If missing, Next.js prerenders the page at build time. The snapshot from 2 hours ago (before risk update) is served to every clinician.<br>
Fix: export const dynamic = 'force-dynamic'<br><br>
Check 2 ‚Äî Is cache: 'no-store' set on the fetch call?<br>
async function getPatients() {<br>
  const res = await fetch(API_URL, { cache: 'no-store' }) // Required!<br>
}<br>
Without no-store, Next.js caches the fetch response. Risk level changes in the database don't propagate until cache expires.<br><br>
Check 3 ‚Äî Is FastAPI caching responses?<br>
Check for any @cache decorators or Redis caching on the /api/patients endpoint<br>
Clinical data endpoints must never be cached<br><br>
Check 4 ‚Äî Is the database update actually committed?<br>
Run: SELECT risk_level, updated_at FROM patients WHERE id = X<br>
Confirm the update exists and wasn't rolled back<br><br>
<strong>THE FIX:</strong><br>
export const dynamic = 'force-dynamic' + cache: 'no-store' together guarantee:<br>
- Page never prerendered at build time<br>
- Fetch never returns cached data<br>
- Every dashboard load = fresh database query<br><br>
<strong>POST-INCIDENT:</strong><br>
Add real-time risk alerts ‚Äî don't wait for clinicians to refresh the dashboard. WebSocket or Server-Sent Events push HIGH risk changes immediately to all active sessions.<br><br>
<strong>Interview gold:</strong> "This incident illustrates why healthcare applications need different defaults than consumer apps. Caching improves performance but can directly harm patients when clinical data is involved. Every caching decision in MindBridge is a clinical safety decision first."`
  },

  demo_login: {
    type: "interview",
    title: "Login Page Demo Script",
    question: "You're on a video call with a hiring manager. You've just navigated to mind-bridge-health-ai.vercel.app. Walk them through the login page.",
    context: "First impressions matter. The login page sets up every technical talking point that follows. Practice until this feels completely natural.",
    ideal: `<strong>OPENING LINE:</strong><br>
"This is MindBridge Health AI ‚Äî a HIPAA-compliant behavioral health platform I built from scratch over the last 3 weeks."<br><br>
<strong>AUTHENTICATION TALKING POINTS:</strong><br>
"The login page uses NextAuth.js with JWT authentication. Sessions expire after exactly 8 hours ‚Äî that's intentional. It aligns with a standard clinical shift length, satisfying HIPAA's automatic logoff requirement under ¬ß164.312(a)(2)(iii)."<br><br>
"The 256-bit encryption and HIPAA compliance indicators reflect real architectural decisions. All connections use TLS 1.3, session tokens are stored in httpOnly cookies so JavaScript can't access them, and every protected route is blocked at the edge by Next.js middleware before the page component even executes."<br><br>
<strong>DEMO CREDENTIALS:</strong><br>
Email: demo@mindbridge.health<br>
Password: MindBridge2026!<br><br>
<strong>LIKELY HIRING MANAGER QUESTIONS:</strong><br>
Q: "What happens if someone tries to access the dashboard without logging in?"<br>
A: "Next.js middleware intercepts the request at the edge and redirects to login immediately. The dashboard page component never executes for unauthenticated requests."<br><br>
Q: "Why 8 hours specifically?"<br>
A: "HIPAA ¬ß164.312(a)(2)(iii) requires automatic logoff after a predetermined time. 8 hours aligns with one clinical shift ‚Äî a case manager who forgets to log out has their session expire automatically at end of shift."<br><br>
Q: "Is this production-ready authentication?"<br>
A: "The architecture is production-ready. For a real deployment I'd replace the demo credentials with PostgreSQL user lookup and bcrypt password verification, add MFA for admin roles, and implement login attempt rate limiting."<br><br>
<strong>TRANSITION TO DASHBOARD:</strong><br>
"Let me log in and show you the patient dashboard where the clinical data lives."`
  },

  demo_dashboard: {
    type: "interview",
    title: "Dashboard Demo Script",
    question: "You've just logged in and the dashboard is showing. Walk the hiring manager through what they're seeing.",
    context: "The dashboard is the centerpiece of the demo. Connect every visual element to a technical decision and a clinical requirement.",
    ideal: `<strong>OPENING:</strong><br>
"After authentication, case managers land on the Patient Dashboard. You can see 10 active patients with real-time risk stratification ‚Äî 4 HIGH risk, 3 MEDIUM, and 3 LOW."<br><br>
<strong>DATA SOURCE TALKING POINT:</strong><br>
"This data is live ‚Äî it's not hardcoded. It's coming from a PostgreSQL database hosted on Railway. Every time this dashboard loads, my Next.js Server Component calls the FastAPI backend which queries PostgreSQL via an asyncpg connection pool."<br><br>
<strong>WHY SERVER COMPONENTS:</strong><br>
"Notice there's no request to the FastAPI backend in the browser's Network tab. That's intentional ‚Äî the fetch happens on Vercel's servers, not in the browser. Patient data never travels through the browser's JavaScript layer. This is a security feature as much as a performance feature."<br><br>
<strong>CLINICAL DATA WALKTHROUGH:</strong><br>
"Let me show you what this data means clinically. Take David Wilson ‚Äî HIGH risk, 25% medication adherence, 5 missed appointments, 3 crisis calls in 30 days, Schizoaffective Disorder bipolar type. In a real clinical setting this patient triggers immediate outreach today.<br><br>
Compare that to Christopher Lee ‚Äî LOW risk, 95% medication adherence, zero missed appointments, zero crisis calls. Social Anxiety Disorder well managed. Routine check-in, no urgency.<br><br>
The AI agent I'm building next week will automate this triage ‚Äî identifying patients like David Wilson automatically and alerting the right case manager."<br><br>
<strong>LIKELY HIRING MANAGER QUESTIONS:</strong><br>
Q: "How often does this data refresh?"<br>
A: "Every page load fetches fresh data. I use cache: 'no-store' on the fetch call and force-dynamic on the page ‚Äî clinical data should never be stale. A patient who escalated to HIGH risk since the last cache refresh could be missed."<br><br>
Q: "How would you handle 500 patients instead of 10?"<br>
A: "Add pagination to the API ‚Äî GET /api/patients?page=1&limit=25. Add database indexes on risk_level and clinic_id. The connection pool handles concurrent load already."<br><br>
<strong>TRANSITION TO API:</strong><br>
"Let me show you the FastAPI backend directly so you can see the raw data flow."`
  },

  demo_api: {
    type: "interview",
    title: "FastAPI Backend Demo Script",
    question: "You've navigated to the FastAPI health endpoint and /api/patients. Walk the hiring manager through what they're seeing.",
    context: "The API demo shows you understand the full stack. Connect the JSON response to the clinical data on the dashboard.",
    ideal: `<strong>HEALTH ENDPOINT ‚Äî mindbridge-health-ai-production.up.railway.app/health:</strong><br>
"This is the health check endpoint. It tells Railway the service is running and the database is connected. Railway hits this endpoint on every deployment ‚Äî if it returns 200, the deployment succeeds. If it fails, Railway rolls back automatically."<br><br>
"Notice database: connected. That confirms the asyncpg connection pool successfully established connections to PostgreSQL at startup. I designed this to be non-fatal ‚Äî if the database is temporarily unavailable, the app still starts and Railway doesn't roll back a good deployment."<br><br>
<strong>PATIENTS ENDPOINT ‚Äî /api/patients:</strong><br>
"This is the raw JSON the dashboard consumes. Notice the source field ‚Äî FastAPI + Railway PostgreSQL ‚Äî confirming the complete data chain."<br><br>
"Three endpoints total: /health for Railway, /api/patients for the dashboard, and /api/patients/{id} for individual patient detail pages."<br><br>
<strong>FASTAPI CHOICE TALKING POINT:</strong><br>
"I chose FastAPI over Django or Flask for three reasons. First, it's async-native ‚Äî behavioral health platforms have concurrent access during shift changes. Django is synchronous by default and would bottleneck. Second, auto-generated OpenAPI docs at /docs ‚Äî the API is self-documenting. Third, Pydantic validation is built in ‚Äî patient data has strict requirements."<br><br>
<strong>ASYNCPG TALKING POINT:</strong><br>
"The backend uses asyncpg instead of psycopg2. Without asyncpg, every database query blocks the entire thread. With asyncpg, 50 case managers logging in simultaneously get responses in under 100ms. For a clinical tool where delayed access affects patient care ‚Äî that's a requirement, not a preference."<br><br>
<strong>LIKELY HIRING MANAGER QUESTIONS:</strong><br>
Q: "How do you secure this API in production?"<br>
A: "Add JWT verification middleware ‚Äî every request must include a valid Bearer token. Rate limiting per user. Request logging for audit trails. HTTPS only ‚Äî Railway handles TLS termination."<br><br>
Q: "What would you add next?"<br>
A: "API versioning at /api/v1/. Pydantic response models for type-safe contracts. An AI agent layer that queries the database intelligently ‚Äî that's Week 4."`
  },

  demo_architecture: {
    type: "interview",
    title: "Full Architecture Demo Script",
    question: "The hiring manager asks: 'Can you draw out the architecture and walk me through how everything connects?' Practice your complete architecture explanation.",
    context: "This is the most important demo moment. Show systems thinking. Connect every layer to a clinical or security requirement.",
    ideal: `<strong>THE THREE LAYERS:</strong><br>
"MindBridge has three production layers ‚Äî all live, all cloud-deployed, no localhost anywhere."<br><br>
<strong>LAYER 1 ‚Äî Frontend:</strong><br>
"Next.js 16 on Vercel's global CDN. NextAuth.js handles authentication with 8-hour JWT sessions stored in httpOnly cookies. Next.js middleware protects clinical routes at the edge ‚Äî unauthenticated requests never reach page components. Server Components fetch data server-side so credentials and patient data never touch the browser's JavaScript layer."<br><br>
<strong>LAYER 2 ‚Äî Backend:</strong><br>
"FastAPI on Railway. Async by design ‚Äî asyncpg connection pool handles concurrent case manager access. CORS configured for specific origins only. /health endpoint enables Railway's automatic deployment validation and rollback."<br><br>
<strong>LAYER 3 ‚Äî Database:</strong><br>
"PostgreSQL on Railway. SSL required for all connections ‚Äî satisfies HIPAA ¬ß164.312(e)(2)(ii) encryption in transit. Connection pool eliminates per-request connection overhead."<br><br>
<strong>COMPLETE REQUEST FLOW:</strong><br>
"When a case manager opens the dashboard:<br>
1. Next.js middleware checks JWT cookie at the edge<br>
2. Valid token ‚Äî Server Component executes<br>
3. Server Component calls FastAPI /api/patients<br>
4. FastAPI acquires warm pool connection<br>
5. SELECT query runs on PostgreSQL<br>
6. JSON returned to Server Component<br>
7. HTML rendered server-side<br>
8. Delivered to browser via Vercel CDN<br>
Total time: under 200ms"<br><br>
<strong>SECURITY STORY:</strong><br>
"Every layer has a security control. Edge middleware blocks unauthenticated access. httpOnly cookies prevent XSS. Server Components keep credentials server-side. SSL encrypts database connections. Environment variables keep credentials out of code ‚Äî I learned that the hard way when GitGuardian detected exposed credentials within 24 hours of making the repo public. Rotated the password in 5 minutes, cleaned git history with git-filter-repo, total resolution under 30 minutes."<br><br>
<strong>WHAT'S NEXT:</strong><br>
"Week 4 adds an AI agent layer ‚Äî natural language queries against the database, automated patient risk alerts, clinical documentation generation. The architecture was designed from day one to support AI capabilities on top of this foundation."<br><br>
<strong>CLOSING LINE:</strong><br>
"Everything you've seen is live in production right now. The GitHub repo is public ‚Äî you can see every commit, every architectural decision, the security incident and how I handled it. That's the kind of transparency I bring to every project."`
  }
};


let sessionCompleted = 0;
let sessionRatings = [];
let currentScenarioKey = null;
const scenarioOrder = Object.keys(scenarios);

function loadScenario(key) {
  currentScenarioKey = key;
  const s = scenarios[key];
  if (!s) return;

  // Hide welcome, show content
  document.getElementById('welcome').style.display = 'none';
  const content = document.getElementById('scenario-content');
  content.style.display = 'flex';

  // Update active button
  document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById('btn-' + key);
  if (btn) btn.classList.add('active');

  // Set type badge
  const badge = document.getElementById('scenario-type-badge');
  const typeMap = {
    simulation: ['type-sim', 'üé≠ Simulation'],
    interview: ['type-int', 'üé§ Interview'],
    concept: ['type-con', 'üí° Concept']
  };
  const [cls, label] = typeMap[s.type] || ['type-con', 'üí° Concept'];
  badge.className = 'scenario-type ' + cls;
  badge.textContent = label;

  // Set question
  document.getElementById('scenario-question').textContent = s.question;

  // Set context
  const ctx = document.getElementById('scenario-context');
  if (s.context) {
    ctx.textContent = s.context;
    ctx.style.display = 'block';
  } else {
    ctx.style.display = 'none';
  }

  // Reset answer area
  document.getElementById('user-answer').value = '';
  document.getElementById('ideal-answer').classList.remove('show');
  document.getElementById('rating-section').classList.remove('show');
  document.getElementById('feedback-panel').classList.remove('show');
  document.getElementById('reveal-btn').style.display = 'inline-block';
  document.getElementById('loading-indicator').classList.remove('show');

  // Scroll to top
  document.getElementById('stage').scrollTop = 0;
}

function revealAnswer() {
  const s = scenarios[currentScenarioKey];
  if (!s) return;

  document.getElementById('reveal-btn').style.display = 'none';
  document.getElementById('ideal-text').innerHTML = s.ideal;
  document.getElementById('ideal-answer').classList.add('show');
  document.getElementById('rating-section').classList.add('show');

  // Scroll to ideal answer
  setTimeout(() => {
    document.getElementById('ideal-answer').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function rateAnswer(rating) {
  const s = scenarios[currentScenarioKey];
  if (!s) return;

  sessionRatings.push(rating);
  sessionCompleted++;
  updateStats();

  const feedback = document.getElementById('feedback-panel');
  const title = document.getElementById('feedback-title');
  const text = document.getElementById('feedback-text');
  const tags = document.getElementById('feedback-tags');

  const messages = {
    1: {
      icon: '‚ùå', color: '#ef4444',
      title: 'No worries ‚Äî this is how you learn!',
      text: 'The ideal answer is now in your memory. Run through this scenario again tomorrow. Repetition is how expertise is built. Most candidates never practice like this.',
      tagStyle: 'background:#ef444420; color:#ef4444; border:1px solid #ef444440;',
      tags: ['Review Tomorrow', 'Keep Going', 'Part of the Process']
    },
    2: {
      icon: 'üòì', color: '#f59e0b',
      title: 'Good attempt ‚Äî you have the foundation!',
      text: 'You knew parts of it. Focus on the specific points you missed. In interviews, a partial answer is far better than silence. Build on what you know.',
      tagStyle: 'background:#f59e0b20; color:#f59e0b; border:1px solid #f59e0b40;',
      tags: ['Building Knowledge', 'Getting There', 'Review Key Points']
    },
    3: {
      icon: '‚úì', color: '#22c55e',
      title: 'Solid! You understand this topic.',
      text: "You've got the core concepts. Keep practicing to sharpen the precise language ‚Äî interviewers are impressed by specificity. You're interview-ready on this topic.",
      tagStyle: 'background:#22c55e20; color:#22c55e; border:1px solid #22c55e40;',
      tags: ['Interview Ready', 'Strong Foundation', 'Sharpen Details']
    },
    4: {
      icon: '‚≠ê', color: '#4f8ef7',
      title: 'Excellent! This answer is yours.',
      text: "You nailed it. When this comes up in an interview, you'll answer with confidence. Your 10 years of clinical experience + this technical depth is a powerful combination.",
      tagStyle: 'background:#4f8ef720; color:#4f8ef7; border:1px solid #4f8ef740;',
      tags: ['Mastered', 'üíº Interview Ready', 'üöÄ Keep Going']
    }
  };

  const m = messages[rating];
  title.innerHTML = `<span style="color:${m.color}">${m.icon}</span> ${m.title}`;
  text.textContent = m.text;
  tags.innerHTML = m.tags.map(t =>
    `<span class="feedback-tag" style="${m.tagStyle}">${t}</span>`
  ).join('');

  feedback.classList.add('show');

  setTimeout(() => {
    feedback.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function nextScenario() {
  const keys = Object.keys(scenarios);
  const idx = keys.indexOf(currentScenarioKey);
  const nextKey = keys[(idx + 1) % keys.length];
  loadScenario(nextKey);
}

function updateStats() {
  document.getElementById('stat-completed').textContent = sessionCompleted;
  if (sessionRatings.length > 0) {
    const avg = (sessionRatings.reduce((a, b) => a + b, 0) / sessionRatings.length).toFixed(1);
    document.getElementById('stat-score').textContent = avg + '/4';
  }
}
</script>
</body>
</html>